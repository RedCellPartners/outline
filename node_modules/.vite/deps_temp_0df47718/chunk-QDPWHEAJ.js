import {
  usePopover,
  usePopoverArrow,
  usePopoverDisclosure,
  usePopoverState
} from "./chunk-MVKBUG3V.js";
import {
  MenuContext,
  ensureFocus,
  getNextActiveElementOnBlur,
  removeIndexFromArray,
  useMenuContext
} from "./chunk-NVIKVDCQ.js";
import {
  canUseDOM,
  closest,
  contains,
  getDocument,
  getWindow,
  hasFocusWithin,
  isPortalEvent,
  isSelfTarget,
  unstable_IdContext,
  unstable_useIdState,
  useClickable,
  useForkRef,
  useIsomorphicEffect,
  useLiveRef,
  useSealedState,
  useTabbable,
  useWarning,
  warning
} from "./chunk-BQDU2HTA.js";
import {
  _createForOfIteratorHelperLoose,
  _objectSpread2,
  _objectSpread22,
  _objectWithoutPropertiesLoose,
  createComponent,
  createHook,
  useCreateElement,
  useRole
} from "./chunk-EDJXIEOR.js";
import {
  require_react_dom
} from "./chunk-BCULJ5QE.js";
import {
  require_react
} from "./chunk-NSZELEHI.js";
import {
  __name,
  __toESM
} from "./chunk-4OCRLPSA.js";

// node_modules/reakit-utils/es/createEvent.js
function createEvent(element, type, eventInit) {
  if (typeof Event === "function") {
    return new Event(type, eventInit);
  }
  var event = getDocument(element).createEvent("Event");
  event.initEvent(type, eventInit === null || eventInit === void 0 ? void 0 : eventInit.bubbles, eventInit === null || eventInit === void 0 ? void 0 : eventInit.cancelable);
  return event;
}
__name(createEvent, "createEvent");

// node_modules/reakit/es/Checkbox/Checkbox.js
var import_react = __toESM(require_react());
var CHECKBOX_STATE_KEYS = ["state", "setState"];
var CHECKBOX_KEYS = [].concat(CHECKBOX_STATE_KEYS, ["value", "checked"]);
function getChecked(options) {
  if (typeof options.checked !== "undefined") {
    return options.checked;
  }
  if (typeof options.value === "undefined") {
    return !!options.state;
  }
  var state = Array.isArray(options.state) ? options.state : [];
  return state.indexOf(options.value) !== -1;
}
__name(getChecked, "getChecked");
function fireChange(element, onChange) {
  var event = createEvent(element, "change");
  Object.defineProperties(event, {
    type: {
      value: "change"
    },
    target: {
      value: element
    },
    currentTarget: {
      value: element
    }
  });
  onChange === null || onChange === void 0 ? void 0 : onChange(event);
}
__name(fireChange, "fireChange");
function useIndeterminateState(ref, options) {
  (0, import_react.useEffect)(function() {
    var element = ref.current;
    if (!element) {
      true ? warning(options.state === "indeterminate", "Can't set indeterminate state because `ref` wasn't passed to component.", "See https://reakit.io/docs/checkbox/#indeterminate-state") : void 0;
      return;
    }
    if (options.state === "indeterminate") {
      element.indeterminate = true;
    } else if (element.indeterminate) {
      element.indeterminate = false;
    }
  }, [options.state, ref]);
}
__name(useIndeterminateState, "useIndeterminateState");
var useCheckbox = createHook({
  name: "Checkbox",
  compose: useClickable,
  keys: CHECKBOX_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions(_ref, _ref2) {
    var value = _ref2.value, checked = _ref2.checked;
    var _ref$unstable_clickOn = _ref.unstable_clickOnEnter, unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? false : _ref$unstable_clickOn, options = _objectWithoutPropertiesLoose(_ref, ["unstable_clickOnEnter"]);
    return _objectSpread2({
      unstable_clickOnEnter,
      value,
      checked: getChecked(_objectSpread2({
        checked
      }, options))
    }, options);
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps(options, _ref3) {
    var htmlRef = _ref3.ref, htmlOnChange = _ref3.onChange, htmlOnClick = _ref3.onClick, htmlProps = _objectWithoutPropertiesLoose(_ref3, ["ref", "onChange", "onClick"]);
    var ref = (0, import_react.useRef)(null);
    var _React$useState = (0, import_react.useState)(true), isNativeCheckbox = _React$useState[0], setIsNativeCheckbox = _React$useState[1];
    var onChangeRef = useLiveRef(htmlOnChange);
    var onClickRef = useLiveRef(htmlOnClick);
    (0, import_react.useEffect)(function() {
      var element = ref.current;
      if (!element) {
        true ? warning(true, "Can't determine whether the element is a native checkbox because `ref` wasn't passed to the component", "See https://reakit.io/docs/checkbox") : void 0;
        return;
      }
      if (element.tagName !== "INPUT" || element.type !== "checkbox") {
        setIsNativeCheckbox(false);
      }
    }, []);
    useIndeterminateState(ref, options);
    var onChange = (0, import_react.useCallback)(function(event) {
      var element = event.currentTarget;
      if (options.disabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      if (onChangeRef.current) {
        if (!isNativeCheckbox) {
          element.checked = !element.checked;
        }
        onChangeRef.current(event);
      }
      if (!options.setState) return;
      if (typeof options.value === "undefined") {
        options.setState(!options.checked);
      } else {
        var state = Array.isArray(options.state) ? options.state : [];
        var index = state.indexOf(options.value);
        if (index === -1) {
          options.setState([].concat(state, [options.value]));
        } else {
          options.setState(removeIndexFromArray(state, index));
        }
      }
    }, [options.disabled, isNativeCheckbox, options.setState, options.value, options.checked, options.state]);
    var onClick = (0, import_react.useCallback)(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented) return;
      if (isNativeCheckbox) return;
      fireChange(event.currentTarget, onChange);
    }, [isNativeCheckbox, onChange]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      role: !isNativeCheckbox ? "checkbox" : void 0,
      type: isNativeCheckbox ? "checkbox" : void 0,
      value: isNativeCheckbox ? options.value : void 0,
      checked: options.checked,
      "aria-checked": options.state === "indeterminate" ? "mixed" : options.checked,
      onChange,
      onClick
    }, htmlProps);
  }, "useProps")
});
var Checkbox = createComponent({
  as: "input",
  memo: true,
  useHook: useCheckbox
});

// node_modules/reakit-utils/es/fireBlurEvent.js
function createFocusEvent(element, type, eventInit) {
  if (eventInit === void 0) {
    eventInit = {};
  }
  if (typeof FocusEvent === "function") {
    return new FocusEvent(type, eventInit);
  }
  return createEvent(element, type, eventInit);
}
__name(createFocusEvent, "createFocusEvent");
function fireBlurEvent(element, eventInit) {
  var event = createFocusEvent(element, "blur", eventInit);
  var defaultAllowed = element.dispatchEvent(event);
  var bubbleInit = _objectSpread22(_objectSpread22({}, eventInit), {}, {
    bubbles: true
  });
  element.dispatchEvent(createFocusEvent(element, "focusout", bubbleInit));
  return defaultAllowed;
}
__name(fireBlurEvent, "fireBlurEvent");

// node_modules/reakit-utils/es/fireKeyboardEvent.js
function createKeyboardEvent(element, type, eventInit) {
  if (eventInit === void 0) {
    eventInit = {};
  }
  if (typeof KeyboardEvent === "function") {
    return new KeyboardEvent(type, eventInit);
  }
  var event = getDocument(element).createEvent("KeyboardEvent");
  event.initKeyboardEvent(type, eventInit.bubbles, eventInit.cancelable, getWindow(element), eventInit.key, eventInit.location, eventInit.ctrlKey, eventInit.altKey, eventInit.shiftKey, eventInit.metaKey);
  return event;
}
__name(createKeyboardEvent, "createKeyboardEvent");
function fireKeyboardEvent(element, type, eventInit) {
  return element.dispatchEvent(createKeyboardEvent(element, type, eventInit));
}
__name(fireKeyboardEvent, "fireKeyboardEvent");

// node_modules/reakit/es/reverse-30eaa122.js
function groupItems(items) {
  var groups = [[]];
  var _loop = /* @__PURE__ */ __name(function _loop2() {
    var item = _step.value;
    var group = groups.find(function(g) {
      return !g[0] || g[0].groupId === item.groupId;
    });
    if (group) {
      group.push(item);
    } else {
      groups.push([item]);
    }
  }, "_loop");
  for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done; ) {
    _loop();
  }
  return groups;
}
__name(groupItems, "groupItems");
function flatten(grid) {
  var flattened = [];
  for (var _iterator = _createForOfIteratorHelperLoose(grid), _step; !(_step = _iterator()).done; ) {
    var row = _step.value;
    flattened.push.apply(flattened, row);
  }
  return flattened;
}
__name(flatten, "flatten");
function reverse(array) {
  return array.slice().reverse();
}
__name(reverse, "reverse");

// node_modules/reakit/es/getCurrentId-5aa9849e.js
function findFirstEnabledItem(items, excludeId) {
  if (excludeId) {
    return items.find(function(item) {
      return !item.disabled && item.id !== excludeId;
    });
  }
  return items.find(function(item) {
    return !item.disabled;
  });
}
__name(findFirstEnabledItem, "findFirstEnabledItem");
function getCurrentId(options, passedId) {
  var _findFirstEnabledItem;
  if (passedId || passedId === null) {
    return passedId;
  }
  if (options.currentId || options.currentId === null) {
    return options.currentId;
  }
  return (_findFirstEnabledItem = findFirstEnabledItem(options.items || [])) === null || _findFirstEnabledItem === void 0 ? void 0 : _findFirstEnabledItem.id;
}
__name(getCurrentId, "getCurrentId");

// node_modules/reakit/es/findEnabledItemById-8ddca752.js
function findEnabledItemById(items, id) {
  if (!id) return void 0;
  return items === null || items === void 0 ? void 0 : items.find(function(item) {
    return item.id === id && !item.disabled;
  });
}
__name(findEnabledItemById, "findEnabledItemById");

// node_modules/reakit/es/__keys-6742f591.js
var COMPOSITE_STATE_KEYS = ["baseId", "unstable_idCountRef", "setBaseId", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget"];
var COMPOSITE_KEYS = COMPOSITE_STATE_KEYS;
var COMPOSITE_GROUP_KEYS = COMPOSITE_KEYS;
var COMPOSITE_ITEM_KEYS = COMPOSITE_GROUP_KEYS;
var COMPOSITE_ITEM_WIDGET_KEYS = COMPOSITE_ITEM_KEYS;

// node_modules/reakit/es/userFocus-e16425e3.js
function userFocus(element) {
  element.userFocus = true;
  element.focus();
  element.userFocus = false;
}
__name(userFocus, "userFocus");
function hasUserFocus(element) {
  return !!element.userFocus;
}
__name(hasUserFocus, "hasUserFocus");
function setUserFocus(element, value) {
  element.userFocus = value;
}
__name(setUserFocus, "setUserFocus");

// node_modules/reakit/es/Composite/Composite.js
var import_react2 = __toESM(require_react());
var isIE11 = canUseDOM && "msCrypto" in window;
function canProxyKeyboardEvent(event) {
  if (!isSelfTarget(event)) return false;
  if (event.metaKey) return false;
  if (event.key === "Tab") return false;
  return true;
}
__name(canProxyKeyboardEvent, "canProxyKeyboardEvent");
function useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {
  var eventHandlerRef = useLiveRef(htmlEventHandler);
  return (0, import_react2.useCallback)(function(event) {
    var _eventHandlerRef$curr;
    (_eventHandlerRef$curr = eventHandlerRef.current) === null || _eventHandlerRef$curr === void 0 ? void 0 : _eventHandlerRef$curr.call(eventHandlerRef, event);
    if (event.defaultPrevented) return;
    if (virtual && canProxyKeyboardEvent(event)) {
      var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;
      if (currentElement) {
        if (!fireKeyboardEvent(currentElement, event.type, event)) {
          event.preventDefault();
        }
        if (event.currentTarget.contains(currentElement)) {
          event.stopPropagation();
        }
      }
    }
  }, [virtual, currentItem]);
}
__name(useKeyboardEventProxy, "useKeyboardEventProxy");
function useActiveElementRef(elementRef) {
  var activeElementRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(function() {
    var document = getDocument(elementRef.current);
    var onFocus = /* @__PURE__ */ __name(function onFocus2(event) {
      var target = event.target;
      activeElementRef.current = target;
    }, "onFocus");
    document.addEventListener("focus", onFocus, true);
    return function() {
      document.removeEventListener("focus", onFocus, true);
    };
  }, []);
  return activeElementRef;
}
__name(useActiveElementRef, "useActiveElementRef");
function findFirstEnabledItemInTheLastRow(items) {
  return findFirstEnabledItem(flatten(reverse(groupItems(items))));
}
__name(findFirstEnabledItemInTheLastRow, "findFirstEnabledItemInTheLastRow");
function isItem(items, element) {
  return items === null || items === void 0 ? void 0 : items.some(function(item) {
    return !!element && item.ref.current === element;
  });
}
__name(isItem, "isItem");
function useScheduleUserFocus(currentItem) {
  var currentItemRef = useLiveRef(currentItem);
  var _React$useReducer = (0, import_react2.useReducer)(function(n) {
    return n + 1;
  }, 0), scheduled = _React$useReducer[0], schedule = _React$useReducer[1];
  (0, import_react2.useEffect)(function() {
    var _currentItemRef$curre;
    var currentElement = (_currentItemRef$curre = currentItemRef.current) === null || _currentItemRef$curre === void 0 ? void 0 : _currentItemRef$curre.ref.current;
    if (scheduled && currentElement) {
      userFocus(currentElement);
    }
  }, [scheduled]);
  return schedule;
}
__name(useScheduleUserFocus, "useScheduleUserFocus");
var useComposite = createHook({
  name: "Composite",
  compose: [useTabbable],
  keys: COMPOSITE_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions2(options) {
    return _objectSpread2(_objectSpread2({}, options), {}, {
      currentId: getCurrentId(options)
    });
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps2(options, _ref) {
    var htmlRef = _ref.ref, htmlOnFocusCapture = _ref.onFocusCapture, htmlOnFocus = _ref.onFocus, htmlOnBlurCapture = _ref.onBlurCapture, htmlOnKeyDown = _ref.onKeyDown, htmlOnKeyDownCapture = _ref.onKeyDownCapture, htmlOnKeyUpCapture = _ref.onKeyUpCapture, htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "onFocusCapture", "onFocus", "onBlurCapture", "onKeyDown", "onKeyDownCapture", "onKeyUpCapture"]);
    var ref = (0, import_react2.useRef)(null);
    var currentItem = findEnabledItemById(options.items, options.currentId);
    var previousElementRef = (0, import_react2.useRef)(null);
    var onFocusCaptureRef = useLiveRef(htmlOnFocusCapture);
    var onFocusRef = useLiveRef(htmlOnFocus);
    var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var scheduleUserFocus = useScheduleUserFocus(currentItem);
    var activeElementRef = isIE11 ? useActiveElementRef(ref) : void 0;
    (0, import_react2.useEffect)(function() {
      var element = ref.current;
      if (options.unstable_moves && !currentItem) {
        true ? warning(!element, "Can't focus composite component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite") : void 0;
        element === null || element === void 0 ? void 0 : element.focus();
      }
    }, [options.unstable_moves, currentItem]);
    var onKeyDownCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDownCapture);
    var onKeyUpCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUpCapture);
    var onFocusCapture = (0, import_react2.useCallback)(function(event) {
      var _onFocusCaptureRef$cu;
      (_onFocusCaptureRef$cu = onFocusCaptureRef.current) === null || _onFocusCaptureRef$cu === void 0 ? void 0 : _onFocusCaptureRef$cu.call(onFocusCaptureRef, event);
      if (event.defaultPrevented) return;
      if (!options.unstable_virtual) return;
      var previousActiveElement = (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || event.relatedTarget;
      var previousActiveElementWasItem = isItem(options.items, previousActiveElement);
      if (isSelfTarget(event) && previousActiveElementWasItem) {
        event.stopPropagation();
        previousElementRef.current = previousActiveElement;
      }
    }, [options.unstable_virtual, options.items]);
    var onFocus = (0, import_react2.useCallback)(function(event) {
      var _onFocusRef$current;
      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented) return;
      if (options.unstable_virtual) {
        if (isSelfTarget(event)) {
          scheduleUserFocus();
        }
      } else if (isSelfTarget(event)) {
        var _options$setCurrentId;
        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);
      }
    }, [options.unstable_virtual, options.setCurrentId]);
    var onBlurCapture = (0, import_react2.useCallback)(function(event) {
      var _onBlurCaptureRef$cur;
      (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);
      if (event.defaultPrevented) return;
      if (!options.unstable_virtual) return;
      var currentElement = (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) || null;
      var nextActiveElement = getNextActiveElementOnBlur(event);
      var nextActiveElementIsItem = isItem(options.items, nextActiveElement);
      if (isSelfTarget(event) && nextActiveElementIsItem) {
        if (nextActiveElement === currentElement) {
          if (previousElementRef.current && previousElementRef.current !== nextActiveElement) {
            fireBlurEvent(previousElementRef.current, event);
          }
        } else if (currentElement) {
          fireBlurEvent(currentElement, event);
        }
        event.stopPropagation();
      } else {
        var targetIsItem = isItem(options.items, event.target);
        if (!targetIsItem && currentElement) {
          fireBlurEvent(currentElement, event);
        }
      }
    }, [options.unstable_virtual, options.items, currentItem]);
    var onKeyDown = (0, import_react2.useCallback)(function(event) {
      var _onKeyDownRef$current, _options$groups;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented) return;
      if (options.currentId !== null) return;
      if (!isSelfTarget(event)) return;
      var isVertical = options.orientation !== "horizontal";
      var isHorizontal = options.orientation !== "vertical";
      var isGrid = !!((_options$groups = options.groups) !== null && _options$groups !== void 0 && _options$groups.length);
      var up = /* @__PURE__ */ __name(function up2() {
        if (isGrid) {
          var item = findFirstEnabledItemInTheLastRow(options.items);
          if (item !== null && item !== void 0 && item.id) {
            var _options$move;
            (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item.id);
          }
        } else {
          var _options$last;
          (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
        }
      }, "up");
      var keyMap = {
        ArrowUp: (isGrid || isVertical) && up,
        ArrowRight: (isGrid || isHorizontal) && options.first,
        ArrowDown: (isGrid || isVertical) && options.first,
        ArrowLeft: (isGrid || isHorizontal) && options.last,
        Home: options.first,
        End: options.last,
        PageUp: options.first,
        PageDown: options.last
      };
      var action = keyMap[event.key];
      if (action) {
        event.preventDefault();
        action();
      }
    }, [options.currentId, options.orientation, options.groups, options.items, options.move, options.last, options.first]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      id: options.baseId,
      onFocus,
      onFocusCapture,
      onBlurCapture,
      onKeyDownCapture,
      onKeyDown,
      onKeyUpCapture,
      "aria-activedescendant": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || void 0 : void 0
    }, htmlProps);
  }, "useProps"),
  useComposeProps: /* @__PURE__ */ __name(function useComposeProps(options, htmlProps) {
    htmlProps = useRole(options, htmlProps, true);
    var tabbableHTMLProps = useTabbable(options, htmlProps, true);
    if (options.unstable_virtual || options.currentId === null) {
      return _objectSpread2({
        tabIndex: 0
      }, tabbableHTMLProps);
    }
    return _objectSpread2(_objectSpread2({}, htmlProps), {}, {
      ref: tabbableHTMLProps.ref
    });
  }, "useComposeProps")
});
var Composite = createComponent({
  as: "div",
  useHook: useComposite,
  useCreateElement: /* @__PURE__ */ __name(function useCreateElement$1(type, props, children) {
    true ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/composite") : void 0;
    return useCreateElement(type, props, children);
  }, "useCreateElement$1")
});

// node_modules/reakit-utils/es/isTextField.js
function isTextField(element) {
  try {
    var isTextInput = element instanceof HTMLInputElement && element.selectionStart !== null;
    var isTextArea = element.tagName === "TEXTAREA";
    var isContentEditable = element.contentEditable === "true";
    return isTextInput || isTextArea || isContentEditable || false;
  } catch (error) {
    return false;
  }
}
__name(isTextField, "isTextField");

// node_modules/reakit/es/Id/Id.js
var import_react3 = __toESM(require_react());
var ID_STATE_KEYS = ["baseId", "unstable_idCountRef", "setBaseId"];
var ID_KEYS = [].concat(ID_STATE_KEYS, ["id"]);
var unstable_useId = createHook({
  keys: ID_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions3(options, htmlProps) {
    var generateId = (0, import_react3.useContext)(unstable_IdContext);
    var _React$useState = (0, import_react3.useState)(function() {
      if (options.unstable_idCountRef) {
        options.unstable_idCountRef.current += 1;
        return "-" + options.unstable_idCountRef.current;
      }
      if (options.baseId) {
        return "-" + generateId("");
      }
      return "";
    }), suffix = _React$useState[0];
    var baseId = (0, import_react3.useMemo)(function() {
      return options.baseId || generateId();
    }, [options.baseId, generateId]);
    var id = htmlProps.id || options.id || "" + baseId + suffix;
    return _objectSpread2(_objectSpread2({}, options), {}, {
      id
    });
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps3(options, htmlProps) {
    return _objectSpread2({
      id: options.id
    }, htmlProps);
  }, "useProps")
});
var unstable_Id = createComponent({
  as: "div",
  useHook: unstable_useId
});

// node_modules/reakit-utils/es/fireEvent.js
function fireEvent(element, type, eventInit) {
  return element.dispatchEvent(createEvent(element, type, eventInit));
}
__name(fireEvent, "fireEvent");

// node_modules/reakit/es/setTextFieldValue-0a221f4e.js
function setTextFieldValue(element, value) {
  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
    var _Object$getOwnPropert;
    var proto = Object.getPrototypeOf(element);
    var setValue = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(proto, "value")) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.set;
    if (setValue) {
      setValue.call(element, value);
      fireEvent(element, "input", {
        bubbles: true
      });
    }
  }
}
__name(setTextFieldValue, "setTextFieldValue");

// node_modules/reakit/es/Composite/CompositeItem.js
var import_react4 = __toESM(require_react());
function getWidget(itemElement) {
  return itemElement.querySelector("[data-composite-item-widget]");
}
__name(getWidget, "getWidget");
function useItem(options) {
  return (0, import_react4.useMemo)(function() {
    var _options$items;
    return (_options$items = options.items) === null || _options$items === void 0 ? void 0 : _options$items.find(function(item) {
      return options.id && item.id === options.id;
    });
  }, [options.items, options.id]);
}
__name(useItem, "useItem");
function targetIsAnotherItem(event, items) {
  if (isSelfTarget(event)) return false;
  for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done; ) {
    var item = _step.value;
    if (item.ref.current === event.target) {
      return true;
    }
  }
  return false;
}
__name(targetIsAnotherItem, "targetIsAnotherItem");
var useCompositeItem = createHook({
  name: "CompositeItem",
  compose: [useClickable, unstable_useId],
  keys: COMPOSITE_ITEM_KEYS,
  propsAreEqual: /* @__PURE__ */ __name(function propsAreEqual(prev, next) {
    if (!next.id || prev.id !== next.id) {
      return useClickable.unstable_propsAreEqual(prev, next);
    }
    var prevCurrentId = prev.currentId, prevMoves = prev.unstable_moves, prevProps = _objectWithoutPropertiesLoose(prev, ["currentId", "unstable_moves"]);
    var nextCurrentId = next.currentId, nextMoves = next.unstable_moves, nextProps = _objectWithoutPropertiesLoose(next, ["currentId", "unstable_moves"]);
    if (nextCurrentId !== prevCurrentId) {
      if (next.id === nextCurrentId || next.id === prevCurrentId) {
        return false;
      }
    } else if (prevMoves !== nextMoves) {
      return false;
    }
    return useClickable.unstable_propsAreEqual(prevProps, nextProps);
  }, "propsAreEqual"),
  useOptions: /* @__PURE__ */ __name(function useOptions4(options) {
    return _objectSpread2(_objectSpread2({}, options), {}, {
      id: options.id,
      currentId: getCurrentId(options),
      unstable_clickOnSpace: options.unstable_hasActiveWidget ? false : options.unstable_clickOnSpace
    });
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps4(options, _ref) {
    var _options$items2;
    var htmlRef = _ref.ref, _ref$tabIndex = _ref.tabIndex, htmlTabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, htmlOnMouseDown = _ref.onMouseDown, htmlOnFocus = _ref.onFocus, htmlOnBlurCapture = _ref.onBlurCapture, htmlOnKeyDown = _ref.onKeyDown, htmlOnClick = _ref.onClick, htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "tabIndex", "onMouseDown", "onFocus", "onBlurCapture", "onKeyDown", "onClick"]);
    var ref = (0, import_react4.useRef)(null);
    var id = options.id;
    var trulyDisabled = options.disabled && !options.focusable;
    var isCurrentItem = options.currentId === id;
    var isCurrentItemRef = useLiveRef(isCurrentItem);
    var hasFocusedComposite = (0, import_react4.useRef)(false);
    var item = useItem(options);
    var onMouseDownRef = useLiveRef(htmlOnMouseDown);
    var onFocusRef = useLiveRef(htmlOnFocus);
    var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onClickRef = useLiveRef(htmlOnClick);
    var shouldTabIndex = !options.unstable_virtual && !options.unstable_hasActiveWidget && isCurrentItem || // We don't want to set tabIndex="-1" when using CompositeItem as a
    // standalone component, without state props.
    !((_options$items2 = options.items) !== null && _options$items2 !== void 0 && _options$items2.length);
    (0, import_react4.useEffect)(function() {
      var _options$registerItem;
      if (!id) return void 0;
      (_options$registerItem = options.registerItem) === null || _options$registerItem === void 0 ? void 0 : _options$registerItem.call(options, {
        id,
        ref,
        disabled: !!trulyDisabled
      });
      return function() {
        var _options$unregisterIt;
        (_options$unregisterIt = options.unregisterItem) === null || _options$unregisterIt === void 0 ? void 0 : _options$unregisterIt.call(options, id);
      };
    }, [id, trulyDisabled, options.registerItem, options.unregisterItem]);
    (0, import_react4.useEffect)(function() {
      var element = ref.current;
      if (!element) {
        true ? warning(true, "Can't focus composite item component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite") : void 0;
        return;
      }
      if (options.unstable_moves && isCurrentItemRef.current) {
        userFocus(element);
      }
    }, [options.unstable_moves]);
    var onMouseDown = (0, import_react4.useCallback)(function(event) {
      var _onMouseDownRef$curre;
      (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
      setUserFocus(event.currentTarget, true);
    }, []);
    var onFocus = (0, import_react4.useCallback)(function(event) {
      var _onFocusRef$current, _options$setCurrentId;
      var shouldFocusComposite = hasUserFocus(event.currentTarget);
      setUserFocus(event.currentTarget, false);
      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented) return;
      if (isPortalEvent(event)) return;
      if (!id) return;
      if (targetIsAnotherItem(event, options.items)) return;
      (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, id);
      if (shouldFocusComposite && options.unstable_virtual && options.baseId && isSelfTarget(event)) {
        var target = event.target;
        var composite = getDocument(target).getElementById(options.baseId);
        if (composite) {
          hasFocusedComposite.current = true;
          ensureFocus(composite);
        }
      }
    }, [id, options.items, options.setCurrentId, options.unstable_virtual, options.baseId]);
    var onBlurCapture = (0, import_react4.useCallback)(function(event) {
      var _onBlurCaptureRef$cur;
      (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);
      if (event.defaultPrevented) return;
      if (options.unstable_virtual && hasFocusedComposite.current) {
        hasFocusedComposite.current = false;
        event.preventDefault();
        event.stopPropagation();
      }
    }, [options.unstable_virtual]);
    var onKeyDown = (0, import_react4.useCallback)(function(event) {
      var _onKeyDownRef$current;
      if (!isSelfTarget(event)) return;
      var isVertical = options.orientation !== "horizontal";
      var isHorizontal = options.orientation !== "vertical";
      var isGrid = !!(item !== null && item !== void 0 && item.groupId);
      var keyMap = {
        ArrowUp: (isGrid || isVertical) && options.up,
        ArrowRight: (isGrid || isHorizontal) && options.next,
        ArrowDown: (isGrid || isVertical) && options.down,
        ArrowLeft: (isGrid || isHorizontal) && options.previous,
        Home: /* @__PURE__ */ __name(function Home() {
          if (!isGrid || event.ctrlKey) {
            var _options$first;
            (_options$first = options.first) === null || _options$first === void 0 ? void 0 : _options$first.call(options);
          } else {
            var _options$previous;
            (_options$previous = options.previous) === null || _options$previous === void 0 ? void 0 : _options$previous.call(options, true);
          }
        }, "Home"),
        End: /* @__PURE__ */ __name(function End() {
          if (!isGrid || event.ctrlKey) {
            var _options$last;
            (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
          } else {
            var _options$next;
            (_options$next = options.next) === null || _options$next === void 0 ? void 0 : _options$next.call(options, true);
          }
        }, "End"),
        PageUp: /* @__PURE__ */ __name(function PageUp() {
          if (isGrid) {
            var _options$up;
            (_options$up = options.up) === null || _options$up === void 0 ? void 0 : _options$up.call(options, true);
          } else {
            var _options$first2;
            (_options$first2 = options.first) === null || _options$first2 === void 0 ? void 0 : _options$first2.call(options);
          }
        }, "PageUp"),
        PageDown: /* @__PURE__ */ __name(function PageDown() {
          if (isGrid) {
            var _options$down;
            (_options$down = options.down) === null || _options$down === void 0 ? void 0 : _options$down.call(options, true);
          } else {
            var _options$last2;
            (_options$last2 = options.last) === null || _options$last2 === void 0 ? void 0 : _options$last2.call(options);
          }
        }, "PageDown")
      };
      var action = keyMap[event.key];
      if (action) {
        event.preventDefault();
        action();
        return;
      }
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented) return;
      if (event.key.length === 1 && event.key !== " ") {
        var widget = getWidget(event.currentTarget);
        if (widget && isTextField(widget)) {
          widget.focus();
          setTextFieldValue(widget, "");
        }
      } else if (event.key === "Delete" || event.key === "Backspace") {
        var _widget = getWidget(event.currentTarget);
        if (_widget && isTextField(_widget)) {
          event.preventDefault();
          setTextFieldValue(_widget, "");
        }
      }
    }, [options.orientation, item, options.up, options.next, options.down, options.previous, options.first, options.last]);
    var onClick = (0, import_react4.useCallback)(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented) return;
      var element = event.currentTarget;
      var widget = getWidget(element);
      if (widget && !hasFocusWithin(widget)) {
        widget.focus();
      }
    }, []);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      id,
      tabIndex: shouldTabIndex ? htmlTabIndex : -1,
      "aria-selected": options.unstable_virtual && isCurrentItem ? true : void 0,
      onMouseDown,
      onFocus,
      onBlurCapture,
      onKeyDown,
      onClick
    }, htmlProps);
  }, "useProps")
});
var CompositeItem = createComponent({
  as: "button",
  memo: true,
  useHook: useCompositeItem
});

// node_modules/reakit-utils/es/applyState.js
function isUpdater(argument) {
  return typeof argument === "function";
}
__name(isUpdater, "isUpdater");
function applyState(argument, currentValue) {
  if (isUpdater(argument)) {
    return argument(currentValue);
  }
  return argument;
}
__name(applyState, "applyState");

// node_modules/reakit/es/Composite/CompositeState.js
var import_react5 = __toESM(require_react());
function isElementPreceding(element1, element2) {
  return Boolean(element2.compareDocumentPosition(element1) & Node.DOCUMENT_POSITION_PRECEDING);
}
__name(isElementPreceding, "isElementPreceding");
function findDOMIndex(items, item) {
  return items.findIndex(function(currentItem) {
    if (!currentItem.ref.current || !item.ref.current) {
      return false;
    }
    return isElementPreceding(item.ref.current, currentItem.ref.current);
  });
}
__name(findDOMIndex, "findDOMIndex");
function getMaxLength(rows) {
  var maxLength = 0;
  for (var _iterator = _createForOfIteratorHelperLoose(rows), _step; !(_step = _iterator()).done; ) {
    var length = _step.value.length;
    if (length > maxLength) {
      maxLength = length;
    }
  }
  return maxLength;
}
__name(getMaxLength, "getMaxLength");
function verticalizeItems(items) {
  var groups = groupItems(items);
  var maxLength = getMaxLength(groups);
  var verticalized = [];
  for (var i = 0; i < maxLength; i += 1) {
    for (var _iterator = _createForOfIteratorHelperLoose(groups), _step; !(_step = _iterator()).done; ) {
      var group = _step.value;
      if (group[i]) {
        verticalized.push(_objectSpread2(_objectSpread2({}, group[i]), {}, {
          // If there's no groupId, it means that it's not a grid composite,
          // but a single row instead. So, instead of verticalizing it, that
          // is, assigning a different groupId based on the column index, we
          // keep it undefined so they will be part of the same group.
          // It's useful when using up/down on one-dimensional composites.
          groupId: group[i].groupId ? "" + i : void 0
        }));
      }
    }
  }
  return verticalized;
}
__name(verticalizeItems, "verticalizeItems");
function createEmptyItem(groupId) {
  return {
    id: "__EMPTY_ITEM__",
    disabled: true,
    ref: {
      current: null
    },
    groupId
  };
}
__name(createEmptyItem, "createEmptyItem");
function fillGroups(groups, currentId, shift) {
  var maxLength = getMaxLength(groups);
  for (var _iterator = _createForOfIteratorHelperLoose(groups), _step; !(_step = _iterator()).done; ) {
    var group = _step.value;
    for (var i = 0; i < maxLength; i += 1) {
      var item = group[i];
      if (!item || shift && item.disabled) {
        var isFrist = i === 0;
        var previousItem = isFrist && shift ? findFirstEnabledItem(group) : group[i - 1];
        group[i] = previousItem && currentId !== (previousItem === null || previousItem === void 0 ? void 0 : previousItem.id) && shift ? previousItem : createEmptyItem(previousItem === null || previousItem === void 0 ? void 0 : previousItem.groupId);
      }
    }
  }
  return groups;
}
__name(fillGroups, "fillGroups");
var nullItem = {
  id: null,
  ref: {
    current: null
  }
};
function placeItemsAfter(items, id, shouldInsertNullItem) {
  var index = items.findIndex(function(item) {
    return item.id === id;
  });
  return [].concat(items.slice(index + 1), shouldInsertNullItem ? [nullItem] : [], items.slice(0, index));
}
__name(placeItemsAfter, "placeItemsAfter");
function getItemsInGroup(items, groupId) {
  return items.filter(function(item) {
    return item.groupId === groupId;
  });
}
__name(getItemsInGroup, "getItemsInGroup");
var map = {
  horizontal: "vertical",
  vertical: "horizontal"
};
function getOppositeOrientation(orientation) {
  return orientation && map[orientation];
}
__name(getOppositeOrientation, "getOppositeOrientation");
function addItemAtIndex(array, item, index) {
  if (!(index in array)) {
    return [].concat(array, [item]);
  }
  return [].concat(array.slice(0, index), [item], array.slice(index));
}
__name(addItemAtIndex, "addItemAtIndex");
function sortBasedOnDOMPosition(items) {
  var pairs = items.map(function(item, index) {
    return [index, item];
  });
  var isOrderDifferent = false;
  pairs.sort(function(_ref, _ref2) {
    var indexA = _ref[0], a = _ref[1];
    var indexB = _ref2[0], b = _ref2[1];
    var elementA = a.ref.current;
    var elementB = b.ref.current;
    if (!elementA || !elementB) return 0;
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(function(_ref3) {
      var _ = _ref3[0], item = _ref3[1];
      return item;
    });
  }
  return items;
}
__name(sortBasedOnDOMPosition, "sortBasedOnDOMPosition");
function setItemsBasedOnDOMPosition(items, setItems) {
  var sortedItems = sortBasedOnDOMPosition(items);
  if (items !== sortedItems) {
    setItems(sortedItems);
  }
}
__name(setItemsBasedOnDOMPosition, "setItemsBasedOnDOMPosition");
function getCommonParent(items) {
  var _firstItem$ref$curren;
  var firstItem = items[0], nextItems = items.slice(1);
  var parentElement = firstItem === null || firstItem === void 0 ? void 0 : (_firstItem$ref$curren = firstItem.ref.current) === null || _firstItem$ref$curren === void 0 ? void 0 : _firstItem$ref$curren.parentElement;
  var _loop = /* @__PURE__ */ __name(function _loop2() {
    var parent = parentElement;
    if (nextItems.every(function(item) {
      return parent.contains(item.ref.current);
    })) {
      return {
        v: parentElement
      };
    }
    parentElement = parentElement.parentElement;
  }, "_loop");
  while (parentElement) {
    var _ret = _loop();
    if (typeof _ret === "object") return _ret.v;
  }
  return getDocument(parentElement).body;
}
__name(getCommonParent, "getCommonParent");
function useIntersectionObserver(items, setItems) {
  var previousItems = (0, import_react5.useRef)([]);
  (0, import_react5.useEffect)(function() {
    var callback = /* @__PURE__ */ __name(function callback2() {
      var hasPreviousItems = !!previousItems.current.length;
      if (hasPreviousItems) {
        setItemsBasedOnDOMPosition(items, setItems);
      }
      previousItems.current = items;
    }, "callback");
    var root = getCommonParent(items);
    var observer = new IntersectionObserver(callback, {
      root
    });
    for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done; ) {
      var item = _step.value;
      if (item.ref.current) {
        observer.observe(item.ref.current);
      }
    }
    return function() {
      observer.disconnect();
    };
  }, [items]);
}
__name(useIntersectionObserver, "useIntersectionObserver");
function useTimeoutObserver(items, setItems) {
  (0, import_react5.useEffect)(function() {
    var callback = /* @__PURE__ */ __name(function callback2() {
      return setItemsBasedOnDOMPosition(items, setItems);
    }, "callback");
    var timeout = setTimeout(callback, 250);
    return function() {
      return clearTimeout(timeout);
    };
  });
}
__name(useTimeoutObserver, "useTimeoutObserver");
function useSortBasedOnDOMPosition(items, setItems) {
  if (typeof IntersectionObserver === "function") {
    useIntersectionObserver(items, setItems);
  } else {
    useTimeoutObserver(items, setItems);
  }
}
__name(useSortBasedOnDOMPosition, "useSortBasedOnDOMPosition");
function reducer(state, action) {
  var virtual = state.unstable_virtual, rtl = state.rtl, orientation = state.orientation, items = state.items, groups = state.groups, currentId = state.currentId, loop = state.loop, wrap = state.wrap, pastIds = state.pastIds, shift = state.shift, moves = state.unstable_moves, includesBaseElement = state.unstable_includesBaseElement, initialVirtual = state.initialVirtual, initialRTL = state.initialRTL, initialOrientation = state.initialOrientation, initialCurrentId = state.initialCurrentId, initialLoop = state.initialLoop, initialWrap = state.initialWrap, initialShift = state.initialShift, hasSetCurrentId = state.hasSetCurrentId;
  switch (action.type) {
    case "registerGroup": {
      var _group = action.group;
      if (groups.length === 0) {
        return _objectSpread2(_objectSpread2({}, state), {}, {
          groups: [_group]
        });
      }
      var index = findDOMIndex(groups, _group);
      return _objectSpread2(_objectSpread2({}, state), {}, {
        groups: addItemAtIndex(groups, _group, index)
      });
    }
    case "unregisterGroup": {
      var _id = action.id;
      var nextGroups = groups.filter(function(group) {
        return group.id !== _id;
      });
      if (nextGroups.length === groups.length) {
        return state;
      }
      return _objectSpread2(_objectSpread2({}, state), {}, {
        groups: nextGroups
      });
    }
    case "registerItem": {
      var _item = action.item;
      var _group2 = groups.find(function(r) {
        var _r$ref$current;
        return (_r$ref$current = r.ref.current) === null || _r$ref$current === void 0 ? void 0 : _r$ref$current.contains(_item.ref.current);
      });
      var nextItem = _objectSpread2({
        groupId: _group2 === null || _group2 === void 0 ? void 0 : _group2.id
      }, _item);
      var _index = findDOMIndex(items, nextItem);
      var nextState = _objectSpread2(_objectSpread2({}, state), {}, {
        items: addItemAtIndex(items, nextItem, _index)
      });
      if (!hasSetCurrentId && !moves && initialCurrentId === void 0) {
        var _findFirstEnabledItem;
        return _objectSpread2(_objectSpread2({}, nextState), {}, {
          currentId: (_findFirstEnabledItem = findFirstEnabledItem(nextState.items)) === null || _findFirstEnabledItem === void 0 ? void 0 : _findFirstEnabledItem.id
        });
      }
      return nextState;
    }
    case "unregisterItem": {
      var _id2 = action.id;
      var nextItems = items.filter(function(item) {
        return item.id !== _id2;
      });
      if (nextItems.length === items.length) {
        return state;
      }
      var nextPastIds = pastIds.filter(function(pastId) {
        return pastId !== _id2;
      });
      var _nextState = _objectSpread2(_objectSpread2({}, state), {}, {
        pastIds: nextPastIds,
        items: nextItems
      });
      if (currentId && currentId === _id2) {
        var nextId = includesBaseElement ? null : getCurrentId(_objectSpread2(_objectSpread2({}, _nextState), {}, {
          currentId: nextPastIds[0]
        }));
        return _objectSpread2(_objectSpread2({}, _nextState), {}, {
          currentId: nextId
        });
      }
      return _nextState;
    }
    case "move": {
      var _id3 = action.id;
      if (_id3 === void 0) {
        return state;
      }
      var filteredPastIds = pastIds.filter(function(pastId) {
        return pastId !== currentId && pastId !== _id3;
      });
      var _nextPastIds = currentId ? [currentId].concat(filteredPastIds) : filteredPastIds;
      var _nextState2 = _objectSpread2(_objectSpread2({}, state), {}, {
        pastIds: _nextPastIds
      });
      if (_id3 === null) {
        return _objectSpread2(_objectSpread2({}, _nextState2), {}, {
          unstable_moves: moves + 1,
          currentId: getCurrentId(_nextState2, _id3)
        });
      }
      var _item2 = findEnabledItemById(items, _id3);
      return _objectSpread2(_objectSpread2({}, _nextState2), {}, {
        unstable_moves: _item2 ? moves + 1 : moves,
        currentId: getCurrentId(_nextState2, _item2 === null || _item2 === void 0 ? void 0 : _item2.id)
      });
    }
    case "next": {
      if (currentId == null) {
        return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
          type: "first"
        }));
      }
      var isHorizontal = orientation !== "vertical";
      var isRTL = rtl && isHorizontal;
      var allItems = isRTL ? reverse(items) : items;
      var currentItem = allItems.find(function(item) {
        return item.id === currentId;
      });
      if (!currentItem) {
        return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
          type: "first"
        }));
      }
      var isGrid = !!currentItem.groupId;
      var currentIndex = allItems.indexOf(currentItem);
      var _nextItems = allItems.slice(currentIndex + 1);
      var nextItemsInGroup = getItemsInGroup(_nextItems, currentItem.groupId);
      if (action.allTheWay) {
        var _nextItem2 = findFirstEnabledItem(isRTL ? getItemsInGroup(allItems, currentItem.groupId) : reverse(nextItemsInGroup));
        return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
          type: "move",
          id: _nextItem2 === null || _nextItem2 === void 0 ? void 0 : _nextItem2.id
        }));
      }
      var oppositeOrientation = getOppositeOrientation(
        // If it's a grid and orientation is not set, it's a next/previous
        // call, which is inherently horizontal. up/down will call next with
        // orientation set to vertical by default (see below on up/down cases).
        isGrid ? orientation || "horizontal" : orientation
      );
      var canLoop = loop && loop !== oppositeOrientation;
      var canWrap = isGrid && wrap && wrap !== oppositeOrientation;
      var hasNullItem = (
        // `previous` and `up` will set action.hasNullItem, but when calling
        // next directly, hasNullItem will only be true if it's not a grid and
        // loop is set to true, which means that pressing right or down keys on
        // grids will never focus the composite element. On one-dimensional
        // composites that don't loop, pressing right or down keys also doesn't
        // focus the composite element.
        action.hasNullItem || !isGrid && canLoop && includesBaseElement
      );
      if (canLoop) {
        var loopItems = canWrap && !hasNullItem ? allItems : getItemsInGroup(allItems, currentItem.groupId);
        var sortedItems = placeItemsAfter(loopItems, currentId, hasNullItem);
        var _nextItem3 = findFirstEnabledItem(sortedItems, currentId);
        return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
          type: "move",
          id: _nextItem3 === null || _nextItem3 === void 0 ? void 0 : _nextItem3.id
        }));
      }
      if (canWrap) {
        var _nextItem4 = findFirstEnabledItem(
          // We can use nextItems, which contains all the next items, including
          // items from other groups, to wrap between groups. However, if there
          // is a null item (the composite element), we'll only use the next
          // items in the group. So moving next from the last item will focus
          // the composite element (null). On grid composites, horizontal
          // navigation never focuses the composite element, only vertical.
          hasNullItem ? nextItemsInGroup : _nextItems,
          currentId
        );
        var _nextId = hasNullItem ? (_nextItem4 === null || _nextItem4 === void 0 ? void 0 : _nextItem4.id) || null : _nextItem4 === null || _nextItem4 === void 0 ? void 0 : _nextItem4.id;
        return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
          type: "move",
          id: _nextId
        }));
      }
      var _nextItem = findFirstEnabledItem(nextItemsInGroup, currentId);
      if (!_nextItem && hasNullItem) {
        return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
          type: "move",
          id: null
        }));
      }
      return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
        type: "move",
        id: _nextItem === null || _nextItem === void 0 ? void 0 : _nextItem.id
      }));
    }
    case "previous": {
      var _isGrid = !!groups.length;
      var _hasNullItem = !_isGrid && includesBaseElement;
      var _nextState3 = reducer(_objectSpread2(_objectSpread2({}, state), {}, {
        items: reverse(items)
      }), _objectSpread2(_objectSpread2({}, action), {}, {
        type: "next",
        hasNullItem: _hasNullItem
      }));
      return _objectSpread2(_objectSpread2({}, _nextState3), {}, {
        items
      });
    }
    case "down": {
      var shouldShift = shift && !action.allTheWay;
      var verticalItems = verticalizeItems(flatten(fillGroups(groupItems(items), currentId, shouldShift)));
      var _canLoop = loop && loop !== "horizontal";
      var _hasNullItem2 = _canLoop && includesBaseElement;
      var _nextState4 = reducer(_objectSpread2(_objectSpread2({}, state), {}, {
        orientation: "vertical",
        items: verticalItems
      }), _objectSpread2(_objectSpread2({}, action), {}, {
        type: "next",
        hasNullItem: _hasNullItem2
      }));
      return _objectSpread2(_objectSpread2({}, _nextState4), {}, {
        orientation,
        items
      });
    }
    case "up": {
      var _shouldShift = shift && !action.allTheWay;
      var _verticalItems = verticalizeItems(reverse(flatten(fillGroups(groupItems(items), currentId, _shouldShift))));
      var _hasNullItem3 = includesBaseElement;
      var _nextState5 = reducer(_objectSpread2(_objectSpread2({}, state), {}, {
        orientation: "vertical",
        items: _verticalItems
      }), _objectSpread2(_objectSpread2({}, action), {}, {
        type: "next",
        hasNullItem: _hasNullItem3
      }));
      return _objectSpread2(_objectSpread2({}, _nextState5), {}, {
        orientation,
        items
      });
    }
    case "first": {
      var firstItem = findFirstEnabledItem(items);
      return reducer(state, _objectSpread2(_objectSpread2({}, action), {}, {
        type: "move",
        id: firstItem === null || firstItem === void 0 ? void 0 : firstItem.id
      }));
    }
    case "last": {
      var _nextState6 = reducer(_objectSpread2(_objectSpread2({}, state), {}, {
        items: reverse(items)
      }), _objectSpread2(_objectSpread2({}, action), {}, {
        type: "first"
      }));
      return _objectSpread2(_objectSpread2({}, _nextState6), {}, {
        items
      });
    }
    case "sort": {
      return _objectSpread2(_objectSpread2({}, state), {}, {
        items: sortBasedOnDOMPosition(items),
        groups: sortBasedOnDOMPosition(groups)
      });
    }
    case "setVirtual":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        unstable_virtual: applyState(action.virtual, virtual)
      });
    case "setRTL":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        rtl: applyState(action.rtl, rtl)
      });
    case "setOrientation":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        orientation: applyState(action.orientation, orientation)
      });
    case "setCurrentId": {
      var nextCurrentId = getCurrentId(_objectSpread2(_objectSpread2({}, state), {}, {
        currentId: applyState(action.currentId, currentId)
      }));
      return _objectSpread2(_objectSpread2({}, state), {}, {
        currentId: nextCurrentId,
        hasSetCurrentId: true
      });
    }
    case "setLoop":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        loop: applyState(action.loop, loop)
      });
    case "setWrap":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        wrap: applyState(action.wrap, wrap)
      });
    case "setShift":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        shift: applyState(action.shift, shift)
      });
    case "setIncludesBaseElement": {
      return _objectSpread2(_objectSpread2({}, state), {}, {
        unstable_includesBaseElement: applyState(action.includesBaseElement, includesBaseElement)
      });
    }
    case "reset":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        unstable_virtual: initialVirtual,
        rtl: initialRTL,
        orientation: initialOrientation,
        currentId: getCurrentId(_objectSpread2(_objectSpread2({}, state), {}, {
          currentId: initialCurrentId
        })),
        loop: initialLoop,
        wrap: initialWrap,
        shift: initialShift,
        unstable_moves: 0,
        pastIds: []
      });
    case "setItems": {
      return _objectSpread2(_objectSpread2({}, state), {}, {
        items: action.items
      });
    }
    default:
      throw new Error();
  }
}
__name(reducer, "reducer");
function useAction(fn) {
  return (0, import_react5.useCallback)(fn, []);
}
__name(useAction, "useAction");
function useIsUnmountedRef() {
  var isUnmountedRef = (0, import_react5.useRef)(false);
  useIsomorphicEffect(function() {
    return function() {
      isUnmountedRef.current = true;
    };
  }, []);
  return isUnmountedRef;
}
__name(useIsUnmountedRef, "useIsUnmountedRef");
function useCompositeState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  var _useSealedState = useSealedState(initialState), _useSealedState$unsta = _useSealedState.unstable_virtual, virtual = _useSealedState$unsta === void 0 ? false : _useSealedState$unsta, _useSealedState$rtl = _useSealedState.rtl, rtl = _useSealedState$rtl === void 0 ? false : _useSealedState$rtl, orientation = _useSealedState.orientation, currentId = _useSealedState.currentId, _useSealedState$loop = _useSealedState.loop, loop = _useSealedState$loop === void 0 ? false : _useSealedState$loop, _useSealedState$wrap = _useSealedState.wrap, wrap = _useSealedState$wrap === void 0 ? false : _useSealedState$wrap, _useSealedState$shift = _useSealedState.shift, shift = _useSealedState$shift === void 0 ? false : _useSealedState$shift, unstable_includesBaseElement = _useSealedState.unstable_includesBaseElement, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["unstable_virtual", "rtl", "orientation", "currentId", "loop", "wrap", "shift", "unstable_includesBaseElement"]);
  var idState = unstable_useIdState(sealed);
  var _React$useReducer = (0, import_react5.useReducer)(reducer, {
    unstable_virtual: virtual,
    rtl,
    orientation,
    items: [],
    groups: [],
    currentId,
    loop,
    wrap,
    shift,
    unstable_moves: 0,
    pastIds: [],
    unstable_includesBaseElement: unstable_includesBaseElement != null ? unstable_includesBaseElement : currentId === null,
    initialVirtual: virtual,
    initialRTL: rtl,
    initialOrientation: orientation,
    initialCurrentId: currentId,
    initialLoop: loop,
    initialWrap: wrap,
    initialShift: shift
  }), _React$useReducer$ = _React$useReducer[0], pastIds = _React$useReducer$.pastIds, initialVirtual = _React$useReducer$.initialVirtual, initialRTL = _React$useReducer$.initialRTL, initialOrientation = _React$useReducer$.initialOrientation, initialCurrentId = _React$useReducer$.initialCurrentId, initialLoop = _React$useReducer$.initialLoop, initialWrap = _React$useReducer$.initialWrap, initialShift = _React$useReducer$.initialShift, hasSetCurrentId = _React$useReducer$.hasSetCurrentId, state = _objectWithoutPropertiesLoose(_React$useReducer$, ["pastIds", "initialVirtual", "initialRTL", "initialOrientation", "initialCurrentId", "initialLoop", "initialWrap", "initialShift", "hasSetCurrentId"]), dispatch = _React$useReducer[1];
  var _React$useState = (0, import_react5.useState)(false), hasActiveWidget = _React$useState[0], setHasActiveWidget = _React$useState[1];
  var isUnmountedRef = useIsUnmountedRef();
  var setItems = (0, import_react5.useCallback)(function(items) {
    return dispatch({
      type: "setItems",
      items
    });
  }, []);
  useSortBasedOnDOMPosition(state.items, setItems);
  return _objectSpread2(_objectSpread2(_objectSpread2({}, idState), state), {}, {
    unstable_hasActiveWidget: hasActiveWidget,
    unstable_setHasActiveWidget: setHasActiveWidget,
    registerItem: useAction(function(item) {
      if (isUnmountedRef.current) return;
      dispatch({
        type: "registerItem",
        item
      });
    }),
    unregisterItem: useAction(function(id) {
      if (isUnmountedRef.current) return;
      dispatch({
        type: "unregisterItem",
        id
      });
    }),
    registerGroup: useAction(function(group) {
      if (isUnmountedRef.current) return;
      dispatch({
        type: "registerGroup",
        group
      });
    }),
    unregisterGroup: useAction(function(id) {
      if (isUnmountedRef.current) return;
      dispatch({
        type: "unregisterGroup",
        id
      });
    }),
    move: useAction(function(id) {
      return dispatch({
        type: "move",
        id
      });
    }),
    next: useAction(function(allTheWay) {
      return dispatch({
        type: "next",
        allTheWay
      });
    }),
    previous: useAction(function(allTheWay) {
      return dispatch({
        type: "previous",
        allTheWay
      });
    }),
    up: useAction(function(allTheWay) {
      return dispatch({
        type: "up",
        allTheWay
      });
    }),
    down: useAction(function(allTheWay) {
      return dispatch({
        type: "down",
        allTheWay
      });
    }),
    first: useAction(function() {
      return dispatch({
        type: "first"
      });
    }),
    last: useAction(function() {
      return dispatch({
        type: "last"
      });
    }),
    sort: useAction(function() {
      return dispatch({
        type: "sort"
      });
    }),
    unstable_setVirtual: useAction(function(value) {
      return dispatch({
        type: "setVirtual",
        virtual: value
      });
    }),
    setRTL: useAction(function(value) {
      return dispatch({
        type: "setRTL",
        rtl: value
      });
    }),
    setOrientation: useAction(function(value) {
      return dispatch({
        type: "setOrientation",
        orientation: value
      });
    }),
    setCurrentId: useAction(function(value) {
      return dispatch({
        type: "setCurrentId",
        currentId: value
      });
    }),
    setLoop: useAction(function(value) {
      return dispatch({
        type: "setLoop",
        loop: value
      });
    }),
    setWrap: useAction(function(value) {
      return dispatch({
        type: "setWrap",
        wrap: value
      });
    }),
    setShift: useAction(function(value) {
      return dispatch({
        type: "setShift",
        shift: value
      });
    }),
    unstable_setIncludesBaseElement: useAction(function(value) {
      return dispatch({
        type: "setIncludesBaseElement",
        includesBaseElement: value
      });
    }),
    reset: useAction(function() {
      return dispatch({
        type: "reset"
      });
    })
  });
}
__name(useCompositeState, "useCompositeState");

// node_modules/reakit/es/__keys-d251e56b.js
var RADIO_STATE_KEYS = ["baseId", "unstable_idCountRef", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "state", "setBaseId", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget", "setState"];
var RADIO_KEYS = [].concat(RADIO_STATE_KEYS, ["value", "checked", "unstable_checkOnFocus"]);
var RADIO_GROUP_KEYS = RADIO_STATE_KEYS;

// node_modules/reakit/es/Radio/Radio.js
var import_react6 = __toESM(require_react());
function getChecked2(options) {
  if (typeof options.checked !== "undefined") {
    return options.checked;
  }
  return typeof options.value !== "undefined" && options.state === options.value;
}
__name(getChecked2, "getChecked");
function useInitialChecked(options) {
  var _React$useState = (0, import_react6.useState)(function() {
    return getChecked2(options);
  }), initialChecked = _React$useState[0];
  var _React$useState2 = (0, import_react6.useState)(options.currentId), initialCurrentId = _React$useState2[0];
  var id = options.id, setCurrentId = options.setCurrentId;
  (0, import_react6.useEffect)(function() {
    if (initialChecked && id && initialCurrentId !== id) {
      setCurrentId === null || setCurrentId === void 0 ? void 0 : setCurrentId(id);
    }
  }, [initialChecked, id, setCurrentId, initialCurrentId]);
}
__name(useInitialChecked, "useInitialChecked");
function fireChange2(element, onChange) {
  var event = createEvent(element, "change");
  Object.defineProperties(event, {
    type: {
      value: "change"
    },
    target: {
      value: element
    },
    currentTarget: {
      value: element
    }
  });
  onChange === null || onChange === void 0 ? void 0 : onChange(event);
}
__name(fireChange2, "fireChange");
var useRadio = createHook({
  name: "Radio",
  compose: useCompositeItem,
  keys: RADIO_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions5(_ref, _ref2) {
    var _options$value;
    var value = _ref2.value, checked = _ref2.checked;
    var _ref$unstable_clickOn = _ref.unstable_clickOnEnter, unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? false : _ref$unstable_clickOn, _ref$unstable_checkOn = _ref.unstable_checkOnFocus, unstable_checkOnFocus = _ref$unstable_checkOn === void 0 ? true : _ref$unstable_checkOn, options = _objectWithoutPropertiesLoose(_ref, ["unstable_clickOnEnter", "unstable_checkOnFocus"]);
    return _objectSpread2(_objectSpread2({
      checked,
      unstable_clickOnEnter,
      unstable_checkOnFocus
    }, options), {}, {
      value: (_options$value = options.value) != null ? _options$value : value
    });
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps5(options, _ref3) {
    var htmlRef = _ref3.ref, htmlOnChange = _ref3.onChange, htmlOnClick = _ref3.onClick, htmlProps = _objectWithoutPropertiesLoose(_ref3, ["ref", "onChange", "onClick"]);
    var ref = (0, import_react6.useRef)(null);
    var _React$useState3 = (0, import_react6.useState)(true), isNativeRadio = _React$useState3[0], setIsNativeRadio = _React$useState3[1];
    var checked = getChecked2(options);
    var isCurrentItemRef = useLiveRef(options.currentId === options.id);
    var onChangeRef = useLiveRef(htmlOnChange);
    var onClickRef = useLiveRef(htmlOnClick);
    useInitialChecked(options);
    (0, import_react6.useEffect)(function() {
      var element = ref.current;
      if (!element) {
        true ? warning(true, "Can't determine whether the element is a native radio because `ref` wasn't passed to the component", "See https://reakit.io/docs/radio") : void 0;
        return;
      }
      if (element.tagName !== "INPUT" || element.type !== "radio") {
        setIsNativeRadio(false);
      }
    }, []);
    var onChange = (0, import_react6.useCallback)(function(event) {
      var _onChangeRef$current, _options$setState;
      (_onChangeRef$current = onChangeRef.current) === null || _onChangeRef$current === void 0 ? void 0 : _onChangeRef$current.call(onChangeRef, event);
      if (event.defaultPrevented) return;
      if (options.disabled) return;
      (_options$setState = options.setState) === null || _options$setState === void 0 ? void 0 : _options$setState.call(options, options.value);
    }, [options.disabled, options.setState, options.value]);
    var onClick = (0, import_react6.useCallback)(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented) return;
      if (isNativeRadio) return;
      fireChange2(event.currentTarget, onChange);
    }, [onChange, isNativeRadio]);
    (0, import_react6.useEffect)(function() {
      var element = ref.current;
      if (!element) return;
      if (options.unstable_moves && isCurrentItemRef.current && options.unstable_checkOnFocus) {
        fireChange2(element, onChange);
      }
    }, [options.unstable_moves, options.unstable_checkOnFocus, onChange]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      role: !isNativeRadio ? "radio" : void 0,
      type: isNativeRadio ? "radio" : void 0,
      value: isNativeRadio ? options.value : void 0,
      name: isNativeRadio ? options.baseId : void 0,
      "aria-checked": checked,
      checked,
      onChange,
      onClick
    }, htmlProps);
  }, "useProps")
});
var Radio = createComponent({
  as: "input",
  memo: true,
  useHook: useRadio
});

// node_modules/reakit/es/__keys-f74df4e0.js
var MENU_BAR_STATE_KEYS = ["baseId", "unstable_idCountRef", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "unstable_values", "setBaseId", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget", "unstable_setValue"];
var MENU_STATE_KEYS = [].concat(MENU_BAR_STATE_KEYS, ["visible", "animated", "animating", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation", "modal", "unstable_disclosureRef", "setModal", "unstable_referenceRef", "unstable_popoverRef", "unstable_arrowRef", "unstable_popoverStyles", "unstable_arrowStyles", "unstable_originalPlacement", "unstable_update", "placement", "place"]);
var MENU_KEYS = MENU_STATE_KEYS;
var MENU_ARROW_KEYS = MENU_KEYS;
var MENU_BAR_KEYS = MENU_ARROW_KEYS;
var MENU_BUTTON_KEYS = MENU_BAR_KEYS;
var MENU_DISCLOSURE_KEYS = MENU_BUTTON_KEYS;
var MENU_GROUP_KEYS = MENU_DISCLOSURE_KEYS;
var MENU_ITEM_KEYS = MENU_GROUP_KEYS;
var MENU_ITEM_CHECKBOX_KEYS = [].concat(MENU_ITEM_KEYS, ["name"]);
var MENU_ITEM_RADIO_KEYS = MENU_ITEM_CHECKBOX_KEYS;
var MENU_SEPARATOR_KEYS = MENU_ITEM_KEYS;

// node_modules/reakit/es/Menu/MenuBar.js
var import_react7 = __toESM(require_react());
function useShortcuts(menuRef, _ref, timeout) {
  var _ref$items = _ref.items, items = _ref$items === void 0 ? [] : _ref$items, move = _ref.move;
  if (timeout === void 0) {
    timeout = 500;
  }
  var _React$useState = (0, import_react7.useState)(""), keys = _React$useState[0], setKeys = _React$useState[1];
  (0, import_react7.useEffect)(function() {
    if (!keys) return void 0;
    var timeoutId = setTimeout(function() {
      return setKeys("");
    }, timeout);
    var stop = items.find(function(s) {
      return Boolean(s.ref.current && s.ref.current.textContent && s.ref.current.textContent.toLowerCase().startsWith(keys));
    });
    if (stop) {
      move(stop.id);
    }
    return function() {
      return clearTimeout(timeoutId);
    };
  }, [keys, items, move, timeout]);
  (0, import_react7.useEffect)(function() {
    var menu = menuRef.current;
    if (!menu) return void 0;
    var onKeyDown = /* @__PURE__ */ __name(function onKeyDown2(event) {
      var _target$getAttribute;
      if (event.key.length > 1) return;
      if (event.shiftKey) return;
      if (event.metaKey) return;
      if (event.ctrlKey) return;
      if (event.altKey) return;
      var target = event.target;
      var role = (_target$getAttribute = target.getAttribute) === null || _target$getAttribute === void 0 ? void 0 : _target$getAttribute.call(target, "role");
      var targetIsMenu = target === menu;
      var targetIsMenuItem = role && role.indexOf("menuitem") !== -1 && closest(target, "[role=menu],[role=menubar]") === menu;
      if (!targetIsMenu && !targetIsMenuItem) return;
      if (/^[a-z0-9_-]$/i.test(event.key)) {
        event.stopPropagation();
        event.preventDefault();
        setKeys(function(k) {
          return "" + k + event.key;
        });
      }
    }, "onKeyDown");
    menu.addEventListener("keydown", onKeyDown);
    return function() {
      return menu.removeEventListener("keydown", onKeyDown);
    };
  }, [menuRef, setKeys]);
}
__name(useShortcuts, "useShortcuts");
var useMenuBar = createHook({
  name: "MenuBar",
  compose: useComposite,
  keys: MENU_BAR_KEYS,
  useProps: /* @__PURE__ */ __name(function useProps6(options, _ref) {
    var htmlRef = _ref.ref, htmlWrapElement = _ref.wrapElement, _ref$role = _ref.role, role = _ref$role === void 0 ? "menubar" : _ref$role, htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "wrapElement", "role"]);
    var ref = (0, import_react7.useRef)(null);
    var wrap = useMenuContext(ref, role, options);
    useShortcuts(ref, options);
    var wrapElement = (0, import_react7.useCallback)(function(element) {
      element = wrap(element);
      if (htmlWrapElement) {
        return htmlWrapElement(element);
      }
      return element;
    }, [wrap, htmlWrapElement]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      role,
      "aria-orientation": options.orientation,
      wrapElement
    }, htmlProps);
  }, "useProps")
});
var MenuBar = createComponent({
  as: "div",
  useHook: useMenuBar,
  useCreateElement: /* @__PURE__ */ __name(function useCreateElement$12(type, props, children) {
    true ? useWarning(!props["aria-label"] && !props["aria-labelledby"] && props.role !== "menubar", "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/menu") : void 0;
    return useCreateElement(type, props, children);
  }, "useCreateElement$1")
});

// node_modules/reakit/es/Menu/Menu.js
var import_react8 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function usePlacementDir(placement) {
  return (0, import_react8.useMemo)(function() {
    var _placement$split;
    return placement === null || placement === void 0 ? void 0 : (_placement$split = placement.split("-")) === null || _placement$split === void 0 ? void 0 : _placement$split[0];
  }, [placement]);
}
__name(usePlacementDir, "usePlacementDir");
var useMenu = createHook({
  name: "Menu",
  compose: [useMenuBar, usePopover],
  keys: MENU_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions6(options) {
    var parent = (0, import_react8.useContext)(MenuContext);
    var parentIsMenuBar = (parent === null || parent === void 0 ? void 0 : parent.role) === "menubar";
    return _objectSpread2(_objectSpread2({
      unstable_autoFocusOnHide: !parentIsMenuBar,
      modal: false
    }, options), {}, {
      // will be handled by MenuButton
      unstable_autoFocusOnShow: false,
      // will be handled differently from usePopover/useDialog
      hideOnEsc: false
    });
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps7(options, _ref) {
    var htmlOnKeyDown = _ref.onKeyDown, htmlProps = _objectWithoutPropertiesLoose(_ref, ["onKeyDown"]);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var parent = (0, import_react8.useContext)(MenuContext);
    var hasParent = !!parent;
    var ancestorMenuBar = parent;
    while (ancestorMenuBar && ancestorMenuBar.role !== "menubar") {
      ancestorMenuBar = ancestorMenuBar.parent;
    }
    var _ref2 = ancestorMenuBar || {}, next = _ref2.next, previous = _ref2.previous, orientation = _ref2.orientation;
    var ancestorIsHorizontal = orientation === "horizontal";
    var dir = usePlacementDir(options.placement);
    var onKeyDown = (0, import_react8.useCallback)(function(event) {
      var _onKeyDownRef$current;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented) return;
      if (event.key === "Escape") {
        var _options$hide;
        if (!hasParent) {
          event.stopPropagation();
        }
        (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
      } else if (hasParent && !isPortalEvent(event)) {
        var ArrowRight = ancestorIsHorizontal && dir !== "left" ? next : dir === "left" && options.hide;
        var ArrowLeft = ancestorIsHorizontal && dir !== "right" ? previous : dir === "right" && options.hide;
        var keyMap = {
          ArrowRight,
          ArrowLeft
        };
        var action = keyMap[event.key];
        if (action) {
          event.preventDefault();
          if (hasParent) {
            event.stopPropagation();
          }
          action();
        }
      }
    }, [hasParent, ancestorIsHorizontal, next, previous, dir, options.hide]);
    return _objectSpread2({
      role: "menu",
      onKeyDown
    }, htmlProps);
  }, "useProps")
});
var Menu = createComponent({
  as: "div",
  useHook: useMenu,
  useCreateElement: /* @__PURE__ */ __name(function useCreateElement$13(type, props, children) {
    true ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/menu") : void 0;
    return useCreateElement(type, props, children);
  }, "useCreateElement$1")
});

// node_modules/reakit/es/Menu/MenuArrow.js
var import_react9 = __toESM(require_react());
var useMenuArrow = createHook({
  name: "MenuArrow",
  compose: usePopoverArrow,
  keys: MENU_ARROW_KEYS
});
var MenuArrow = createComponent({
  as: "div",
  memo: true,
  useHook: useMenuArrow
});

// node_modules/reakit/es/Menu/MenuBarState.js
var import_react10 = __toESM(require_react());
function useMenuBarState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  var _useSealedState = useSealedState(initialState), _useSealedState$orien = _useSealedState.orientation, orientation = _useSealedState$orien === void 0 ? "horizontal" : _useSealedState$orien, _useSealedState$unsta = _useSealedState.unstable_values, initialValues = _useSealedState$unsta === void 0 ? {} : _useSealedState$unsta, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["orientation", "unstable_values"]);
  var _React$useState = (0, import_react10.useState)(initialValues), values = _React$useState[0], setValues = _React$useState[1];
  var composite = useCompositeState(_objectSpread2(_objectSpread2({}, sealed), {}, {
    orientation
  }));
  return _objectSpread2(_objectSpread2({}, composite), {}, {
    unstable_values: values,
    unstable_setValue: (0, import_react10.useCallback)(function(name, value) {
      setValues(function(vals) {
        var _objectSpread2$1;
        return _objectSpread2(_objectSpread2({}, vals), {}, (_objectSpread2$1 = {}, _objectSpread2$1[name] = typeof value === "function" ? value(vals) : value, _objectSpread2$1));
      });
    }, [])
  });
}
__name(useMenuBarState, "useMenuBarState");

// node_modules/reakit/es/findVisibleSubmenu-1553e354.js
function findVisibleSubmenu(submenus) {
  var visibleSubmenu = submenus === null || submenus === void 0 ? void 0 : submenus.find(function(submenu) {
    return submenu.current && !submenu.current.hidden;
  });
  return visibleSubmenu === null || visibleSubmenu === void 0 ? void 0 : visibleSubmenu.current;
}
__name(findVisibleSubmenu, "findVisibleSubmenu");

// node_modules/reakit/es/Menu/MenuButton.js
var import_react11 = __toESM(require_react());
var noop = /* @__PURE__ */ __name(function noop2() {
}, "noop");
var useMenuButton = createHook({
  name: "MenuButton",
  compose: usePopoverDisclosure,
  keys: MENU_BUTTON_KEYS,
  propsAreEqual: /* @__PURE__ */ __name(function propsAreEqual2(prev, next) {
    var prevPopoverStyles = prev.unstable_popoverStyles, prevArrowStyles = prev.unstable_arrowStyles, prevCurrentId = prev.currentId, prevMoves = prev.unstable_moves, prevProps = _objectWithoutPropertiesLoose(prev, ["unstable_popoverStyles", "unstable_arrowStyles", "currentId", "unstable_moves"]);
    var nextPopoverStyles = next.unstable_popoverStyles, nextArrowStyles = next.unstable_arrowStyles, nextCurrentId = next.currentId, nextMoves = next.unstable_moves, nextProps = _objectWithoutPropertiesLoose(next, ["unstable_popoverStyles", "unstable_arrowStyles", "currentId", "unstable_moves"]);
    return usePopoverDisclosure.unstable_propsAreEqual(prevProps, nextProps);
  }, "propsAreEqual"),
  useProps: /* @__PURE__ */ __name(function useProps8(options, _ref) {
    var htmlRef = _ref.ref, htmlOnClick = _ref.onClick, htmlOnKeyDown = _ref.onKeyDown, htmlOnFocus = _ref.onFocus, htmlOnMouseEnter = _ref.onMouseEnter, htmlOnMouseDown = _ref.onMouseDown, htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "onClick", "onKeyDown", "onFocus", "onMouseEnter", "onMouseDown"]);
    var parent = (0, import_react11.useContext)(MenuContext);
    var ref = (0, import_react11.useRef)(null);
    var hasPressedMouse = (0, import_react11.useRef)(false);
    var _options$placement$sp = options.placement.split("-"), dir = _options$placement$sp[0];
    var hasParent = !!parent;
    var parentIsMenuBar = (parent === null || parent === void 0 ? void 0 : parent.role) === "menubar";
    var disabled = options.disabled || htmlProps["aria-disabled"];
    var onClickRef = useLiveRef(htmlOnClick);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onFocusRef = useLiveRef(htmlOnFocus);
    var onMouseEnterRef = useLiveRef(htmlOnMouseEnter);
    var onMouseDownRef = useLiveRef(htmlOnMouseDown);
    var onKeyDown = (0, import_react11.useCallback)(function(event) {
      var _onKeyDownRef$current;
      if (event.key === "Escape") {
        var _options$hide;
        (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
      } else if (!disabled) {
        var first = options.first && function() {
          return setTimeout(options.first);
        };
        var last = options.last && function() {
          return setTimeout(options.last);
        };
        var keyMap = {
          Enter: first,
          " ": first,
          ArrowUp: (dir === "top" || dir === "bottom") && last,
          ArrowRight: dir === "right" && first,
          ArrowDown: (dir === "bottom" || dir === "top") && first,
          ArrowLeft: dir === "left" && first
        };
        var action = keyMap[event.key];
        if (action) {
          var _options$show;
          event.preventDefault();
          event.stopPropagation();
          (_options$show = options.show) === null || _options$show === void 0 ? void 0 : _options$show.call(options);
          action();
          return;
        }
      }
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
    }, [disabled, options.hide, options.first, options.last, dir, options.show]);
    var onMouseEnter = (0, import_react11.useCallback)(function(event) {
      var _onMouseEnterRef$curr;
      (_onMouseEnterRef$curr = onMouseEnterRef.current) === null || _onMouseEnterRef$curr === void 0 ? void 0 : _onMouseEnterRef$curr.call(onMouseEnterRef, event);
      if (event.defaultPrevented) return;
      if (!parent) return;
      var element = event.currentTarget;
      if (parentIsMenuBar) {
        if (findVisibleSubmenu(parent.children)) {
          element.focus();
        }
      } else {
        setTimeout(function() {
          if (hasFocusWithin(element)) {
            var _options$show2;
            (_options$show2 = options.show) === null || _options$show2 === void 0 ? void 0 : _options$show2.call(options);
          }
        }, 200);
      }
    }, [parent, parentIsMenuBar, options.show]);
    var onMouseDown = (0, import_react11.useCallback)(function(event) {
      var _onMouseDownRef$curre;
      hasPressedMouse.current = true;
      (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
    }, []);
    var onFocus = (0, import_react11.useCallback)(function(event) {
      var _onFocusRef$current;
      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented) return;
      if (disabled) return;
      if (parentIsMenuBar && !hasPressedMouse.current) {
        var _options$show3;
        (_options$show3 = options.show) === null || _options$show3 === void 0 ? void 0 : _options$show3.call(options);
      }
    }, [parentIsMenuBar, disabled, options.show]);
    var onClick = (0, import_react11.useCallback)(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented) return;
      if (hasParent && !parentIsMenuBar) {
        var _options$show4;
        (_options$show4 = options.show) === null || _options$show4 === void 0 ? void 0 : _options$show4.call(options);
      } else {
        var _options$toggle;
        (_options$toggle = options.toggle) === null || _options$toggle === void 0 ? void 0 : _options$toggle.call(options);
        if (hasPressedMouse.current && !parentIsMenuBar && !options.visible) {
          var _options$move;
          (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, null);
        }
      }
      hasPressedMouse.current = false;
    }, [hasParent, parentIsMenuBar, options.show, options.toggle, options.visible, options.move]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      "aria-haspopup": "menu",
      onKeyDown,
      onMouseEnter,
      onMouseDown,
      onFocus,
      onClick
    }, htmlProps);
  }, "useProps"),
  useComposeOptions: /* @__PURE__ */ __name(function useComposeOptions(options) {
    return _objectSpread2(_objectSpread2({}, options), {}, {
      // Toggling is handled by MenuButton
      toggle: noop
    });
  }, "useComposeOptions")
});
var MenuButton = createComponent({
  as: "button",
  memo: true,
  useHook: useMenuButton
});

// node_modules/reakit/es/Menu/MenuDisclosure.js
var import_react12 = __toESM(require_react());
var useMenuDisclosure = createHook({
  name: "MenuDisclosure",
  compose: useMenuButton,
  useProps: /* @__PURE__ */ __name(function useProps9(_, htmlProps) {
    true ? useWarning(true, "`MenuDisclosure` has been renamed to `MenuButton`. Using `<MenuDisclosure />` will no longer work in future versions.", "See https://reakit.io/docs/menu") : void 0;
    return htmlProps;
  }, "useProps")
});
var MenuDisclosure = createComponent({
  as: "button",
  useHook: useMenuDisclosure
});

// node_modules/reakit/es/Menu/MenuGroup.js
var useMenuGroup = createHook({
  name: "MenuGroup",
  compose: useRole,
  keys: MENU_GROUP_KEYS,
  useProps: /* @__PURE__ */ __name(function useProps10(_, htmlProps) {
    return _objectSpread2({
      role: "group"
    }, htmlProps);
  }, "useProps")
});
var MenuGroup = createComponent({
  as: "div",
  useHook: useMenuGroup
});

// node_modules/reakit/es/Menu/MenuItem.js
var import_react13 = __toESM(require_react());
function getTriangleArea(a, b, c) {
  return Math.abs((a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) / 2);
}
__name(getTriangleArea, "getTriangleArea");
function isPointInTriangle(point, a, b, c) {
  var A = getTriangleArea(a, b, c);
  var A1 = getTriangleArea(point, b, c);
  var A2 = getTriangleArea(a, point, c);
  var A3 = getTriangleArea(a, b, point);
  return A === A1 + A2 + A3;
}
__name(isPointInTriangle, "isPointInTriangle");
function getSubmenuAnchorPoints(event, visibleSubmenu) {
  var _visibleSubmenu$getBo = visibleSubmenu.getBoundingClientRect(), top = _visibleSubmenu$getBo.top, right = _visibleSubmenu$getBo.right, bottom = _visibleSubmenu$getBo.bottom, left = _visibleSubmenu$getBo.left;
  var x = left > event.clientX ? left : right;
  return [{
    x,
    y: top
  }, {
    x,
    y: bottom
  }];
}
__name(getSubmenuAnchorPoints, "getSubmenuAnchorPoints");
function useTransitToSubmenu(menu, htmlOnMouseEnter) {
  var onMouseEnterRef = useLiveRef(htmlOnMouseEnter);
  var enterPointRef = (0, import_react13.useRef)(null);
  var submenuTopPointRef = (0, import_react13.useRef)(null);
  var submenuBottomPointRef = (0, import_react13.useRef)(null);
  var previousClientX = (0, import_react13.useRef)(0);
  var previousClientY = (0, import_react13.useRef)(0);
  var assignSubmenuAnchorPoints = (0, import_react13.useCallback)(function(event) {
    if (!(menu !== null && menu !== void 0 && menu.children.length)) return;
    submenuTopPointRef.current = null;
    submenuBottomPointRef.current = null;
    var visibleSubmenu = findVisibleSubmenu(menu.children);
    if (!visibleSubmenu) return;
    var _getSubmenuAnchorPoin = getSubmenuAnchorPoints(event, visibleSubmenu);
    submenuTopPointRef.current = _getSubmenuAnchorPoin[0];
    submenuBottomPointRef.current = _getSubmenuAnchorPoin[1];
  }, [menu === null || menu === void 0 ? void 0 : menu.children]);
  var isMouseInTransitToSubmenu = (0, import_react13.useCallback)(function(event) {
    var isMoving = previousClientX.current !== event.clientX || previousClientY.current !== event.clientY;
    if (event.isTrusted && !isMoving) {
      return true;
    }
    var movementX = Math.abs(previousClientX.current - event.clientX);
    previousClientX.current = event.clientX;
    previousClientY.current = event.clientY;
    var hasAnchorPoints = /* @__PURE__ */ __name(function hasAnchorPoints2() {
      return submenuTopPointRef.current && submenuBottomPointRef.current;
    }, "hasAnchorPoints");
    if (event.type === "mouseleave" && !hasAnchorPoints()) {
      assignSubmenuAnchorPoints(event);
    }
    if (!hasAnchorPoints()) return false;
    return movementX && enterPointRef.current && isPointInTriangle({
      x: event.clientX,
      y: event.clientY
    }, enterPointRef.current, submenuTopPointRef.current, submenuBottomPointRef.current);
  }, [assignSubmenuAnchorPoints]);
  var onMouseEnter = (0, import_react13.useCallback)(function(event) {
    var _onMouseEnterRef$curr;
    (_onMouseEnterRef$curr = onMouseEnterRef.current) === null || _onMouseEnterRef$curr === void 0 ? void 0 : _onMouseEnterRef$curr.call(onMouseEnterRef, event);
    if (event.defaultPrevented) return;
    if ((menu === null || menu === void 0 ? void 0 : menu.role) === "menubar") return;
    enterPointRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    assignSubmenuAnchorPoints(event);
  }, [menu === null || menu === void 0 ? void 0 : menu.role, assignSubmenuAnchorPoints]);
  return {
    onMouseEnter,
    isMouseInTransitToSubmenu
  };
}
__name(useTransitToSubmenu, "useTransitToSubmenu");
function getMouseDestination(event) {
  var relatedTarget = event.relatedTarget;
  if ((relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.nodeType) === Node.ELEMENT_NODE) {
    return event.relatedTarget;
  }
  return event.toElement || null;
}
__name(getMouseDestination, "getMouseDestination");
function hoveringInside(event) {
  var nextElement = getMouseDestination(event);
  if (!nextElement) return false;
  return contains(event.currentTarget, nextElement);
}
__name(hoveringInside, "hoveringInside");
function hoveringExpandedMenu(event, children) {
  if (!(children !== null && children !== void 0 && children.length)) return false;
  var nextElement = getMouseDestination(event);
  if (!nextElement) return false;
  var visibleSubmenu = findVisibleSubmenu(children);
  return visibleSubmenu && contains(visibleSubmenu, nextElement);
}
__name(hoveringExpandedMenu, "hoveringExpandedMenu");
function hoveringAnotherMenuItem(event, items) {
  var nextElement = getMouseDestination(event);
  if (!nextElement) return false;
  return items === null || items === void 0 ? void 0 : items.some(function(item) {
    return item.ref.current && contains(item.ref.current, nextElement);
  });
}
__name(hoveringAnotherMenuItem, "hoveringAnotherMenuItem");
var useMenuItem = createHook({
  name: "MenuItem",
  compose: useCompositeItem,
  keys: MENU_ITEM_KEYS,
  propsAreEqual: /* @__PURE__ */ __name(function propsAreEqual3(prev, next) {
    var prevPopoverStyles = prev.unstable_popoverStyles, prevArrowStyles = prev.unstable_arrowStyles, prevVisible = prev.visible, prevProps = _objectWithoutPropertiesLoose(prev, ["unstable_popoverStyles", "unstable_arrowStyles", "visible"]);
    var nextPopoverStyles = next.unstable_popoverStyles, nextArrowStyles = next.unstable_arrowStyles, nextVisible = next.visible, nextProps = _objectWithoutPropertiesLoose(next, ["unstable_popoverStyles", "unstable_arrowStyles", "visible"]);
    return useCompositeItem.unstable_propsAreEqual(prevProps, nextProps);
  }, "propsAreEqual"),
  useProps: /* @__PURE__ */ __name(function useProps11(options, _ref) {
    var htmlOnMouseEnter = _ref.onMouseEnter, htmlOnMouseMove = _ref.onMouseMove, htmlOnMouseLeave = _ref.onMouseLeave, htmlProps = _objectWithoutPropertiesLoose(_ref, ["onMouseEnter", "onMouseMove", "onMouseLeave"]);
    var menu = (0, import_react13.useContext)(MenuContext);
    var onMouseMoveRef = useLiveRef(htmlOnMouseMove);
    var onMouseLeaveRef = useLiveRef(htmlOnMouseLeave);
    var _useTransitToSubmenu = useTransitToSubmenu(menu, htmlOnMouseEnter), onMouseEnter = _useTransitToSubmenu.onMouseEnter, isMouseInTransitToSubmenu = _useTransitToSubmenu.isMouseInTransitToSubmenu;
    var onMouseMove = (0, import_react13.useCallback)(function(event) {
      var _onMouseMoveRef$curre, _options$move;
      (_onMouseMoveRef$curre = onMouseMoveRef.current) === null || _onMouseMoveRef$curre === void 0 ? void 0 : _onMouseMoveRef$curre.call(onMouseMoveRef, event);
      if (event.defaultPrevented) return;
      if ((menu === null || menu === void 0 ? void 0 : menu.role) === "menubar") return;
      if (isMouseInTransitToSubmenu(event)) return;
      if (hasFocusWithin(event.currentTarget)) return;
      (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, event.currentTarget.id);
    }, [options.move]);
    var onMouseLeave = (0, import_react13.useCallback)(function(event) {
      var _onMouseLeaveRef$curr;
      (_onMouseLeaveRef$curr = onMouseLeaveRef.current) === null || _onMouseLeaveRef$curr === void 0 ? void 0 : _onMouseLeaveRef$curr.call(onMouseLeaveRef, event);
      if (event.defaultPrevented) return;
      if ((menu === null || menu === void 0 ? void 0 : menu.role) === "menubar") return;
      if (hoveringInside(event)) return;
      if (hoveringExpandedMenu(event, menu === null || menu === void 0 ? void 0 : menu.children)) return;
      if (!hoveringAnotherMenuItem(event, options.items)) {
        var _options$move2;
        if (isMouseInTransitToSubmenu(event)) return;
        (_options$move2 = options.move) === null || _options$move2 === void 0 ? void 0 : _options$move2.call(options, null);
      }
    }, [menu === null || menu === void 0 ? void 0 : menu.role, menu === null || menu === void 0 ? void 0 : menu.children, options.items, options.move]);
    return _objectSpread2({
      role: "menuitem",
      onMouseEnter,
      onMouseMove,
      onMouseLeave
    }, htmlProps);
  }, "useProps")
});
var MenuItem = createComponent({
  as: "button",
  memo: true,
  useHook: useMenuItem
});

// node_modules/reakit/es/Menu/MenuItemCheckbox.js
var import_react14 = __toESM(require_react());
var useMenuItemCheckbox = createHook({
  name: "MenuItemCheckbox",
  compose: [useMenuItem, useCheckbox],
  keys: MENU_ITEM_CHECKBOX_KEYS,
  propsAreEqual: /* @__PURE__ */ __name(function propsAreEqual4(prev, next) {
    if (prev.name !== next.name) {
      return useMenuItem.unstable_propsAreEqual(prev, next);
    }
    var prevValues = prev.unstable_values, prevProps = _objectWithoutPropertiesLoose(prev, ["unstable_values"]);
    var nextValues = next.unstable_values, nextProps = _objectWithoutPropertiesLoose(next, ["unstable_values"]);
    if (prevValues[next.name] !== nextValues[next.name]) {
      return false;
    }
    return useMenuItem.unstable_propsAreEqual(prevProps, nextProps);
  }, "propsAreEqual"),
  useOptions: /* @__PURE__ */ __name(function useOptions7(options) {
    var setState = (0, import_react14.useCallback)(function(value) {
      return options.unstable_setValue(options.name, value);
    }, [options.unstable_setValue, options.name]);
    return _objectSpread2(_objectSpread2({}, options), {}, {
      state: options.unstable_values[options.name],
      setState
    });
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps12(options, htmlProps) {
    return _objectSpread2({
      role: "menuitemcheckbox",
      name: options.name
    }, htmlProps);
  }, "useProps")
});
var MenuItemCheckbox = createComponent({
  as: "button",
  memo: true,
  useHook: useMenuItemCheckbox
});

// node_modules/reakit/es/Menu/MenuItemRadio.js
var import_react15 = __toESM(require_react());
var useMenuItemRadio = createHook({
  name: "MenuItemRadio",
  compose: [useMenuItem, useRadio],
  keys: MENU_ITEM_RADIO_KEYS,
  propsAreEqual: /* @__PURE__ */ __name(function propsAreEqual5(prev, next) {
    if (prev.name !== next.name) {
      return useMenuItem.unstable_propsAreEqual(prev, next);
    }
    var prevValues = prev.unstable_values, prevProps = _objectWithoutPropertiesLoose(prev, ["unstable_values"]);
    var nextValues = next.unstable_values, nextProps = _objectWithoutPropertiesLoose(next, ["unstable_values"]);
    if (prevValues[next.name] !== nextValues[next.name]) {
      return false;
    }
    return useMenuItem.unstable_propsAreEqual(prevProps, nextProps);
  }, "propsAreEqual"),
  useOptions: /* @__PURE__ */ __name(function useOptions8(options) {
    var setState = (0, import_react15.useCallback)(function(value) {
      return options.unstable_setValue(options.name, value);
    }, [options.unstable_setValue, options.name]);
    return _objectSpread2(_objectSpread2({}, options), {}, {
      unstable_checkOnFocus: false,
      state: options.unstable_values[options.name],
      setState
    });
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps13(_, htmlProps) {
    return _objectSpread2({
      role: "menuitemradio"
    }, htmlProps);
  }, "useProps")
});
var MenuItemRadio = createComponent({
  as: "button",
  memo: true,
  useHook: useMenuItemRadio
});

// node_modules/reakit/es/Separator/Separator.js
var SEPARATOR_KEYS = ["orientation"];
var useSeparator = createHook({
  name: "Separator",
  compose: useRole,
  keys: SEPARATOR_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions9(_ref) {
    var _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? "horizontal" : _ref$orientation, options = _objectWithoutPropertiesLoose(_ref, ["orientation"]);
    return _objectSpread2({
      orientation
    }, options);
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps14(options, htmlProps) {
    return _objectSpread2({
      role: "separator",
      "aria-orientation": options.orientation
    }, htmlProps);
  }, "useProps")
});
var Separator = createComponent({
  as: "hr",
  memo: true,
  useHook: useSeparator
});

// node_modules/reakit/es/Menu/MenuSeparator.js
var useMenuSeparator = createHook({
  name: "MenuSeparator",
  compose: useSeparator,
  keys: MENU_SEPARATOR_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions10(_ref) {
    var _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? "vertical" : _ref$orientation, options = _objectWithoutPropertiesLoose(_ref, ["orientation"]);
    return _objectSpread2({
      orientation: orientation === "vertical" ? "horizontal" : "vertical"
    }, options);
  }, "useOptions")
});
var MenuSeparator = createComponent({
  as: "hr",
  memo: true,
  useHook: useMenuSeparator
});

// node_modules/reakit/es/Menu/MenuState.js
var import_react16 = __toESM(require_react());
function useMenuState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  var parent = (0, import_react16.useContext)(MenuContext);
  var _useSealedState = useSealedState(initialState), _useSealedState$orien = _useSealedState.orientation, orientation = _useSealedState$orien === void 0 ? "vertical" : _useSealedState$orien, _useSealedState$gutte = _useSealedState.gutter, gutter = _useSealedState$gutte === void 0 ? 0 : _useSealedState$gutte, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["orientation", "gutter"]);
  var placement = sealed.placement || (parent && parent.orientation === "vertical" ? "right-start" : "bottom-start");
  var menuBar = useMenuBarState(_objectSpread2(_objectSpread2({}, sealed), {}, {
    orientation
  }));
  var popover = usePopoverState(_objectSpread2(_objectSpread2({}, sealed), {}, {
    placement,
    gutter
  }));
  (0, import_react16.useEffect)(function() {
    if (!popover.visible) {
      menuBar.reset();
    }
  }, [popover.visible, menuBar.reset]);
  return _objectSpread2(_objectSpread2({}, menuBar), popover);
}
__name(useMenuState, "useMenuState");

export {
  createEvent,
  useCheckbox,
  Checkbox,
  findEnabledItemById,
  COMPOSITE_GROUP_KEYS,
  COMPOSITE_ITEM_WIDGET_KEYS,
  useComposite,
  Composite,
  isTextField,
  unstable_useId,
  unstable_Id,
  setTextFieldValue,
  useCompositeItem,
  CompositeItem,
  useCompositeState,
  RADIO_GROUP_KEYS,
  useRadio,
  Radio,
  useMenuBar,
  MenuBar,
  useMenu,
  Menu,
  useMenuArrow,
  MenuArrow,
  useMenuBarState,
  useMenuButton,
  MenuButton,
  useMenuDisclosure,
  MenuDisclosure,
  useMenuGroup,
  MenuGroup,
  useMenuItem,
  MenuItem,
  useMenuItemCheckbox,
  MenuItemCheckbox,
  useMenuItemRadio,
  MenuItemRadio,
  useSeparator,
  Separator,
  useMenuSeparator,
  MenuSeparator,
  useMenuState
};
//# sourceMappingURL=chunk-QDPWHEAJ.js.map
