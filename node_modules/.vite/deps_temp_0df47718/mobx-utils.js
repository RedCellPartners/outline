import {
  action,
  allowStateChanges,
  autorun,
  computed,
  createAtom,
  extendObservable,
  flow,
  getAtom,
  isAction,
  isComputingDerivation,
  isObservableArray,
  isObservableMap,
  isObservableObject,
  keys,
  observable,
  onBecomeUnobserved,
  runInAction,
  when
} from "./chunk-IHFIALTD.js";
import {
  __name
} from "./chunk-4OCRLPSA.js";

// node_modules/mobx-utils/mobx-utils.module.js
var NOOP = /* @__PURE__ */ __name(function() {
}, "NOOP");
var IDENTITY = /* @__PURE__ */ __name(function(_) {
  return _;
}, "IDENTITY");
function invariant(cond, message) {
  if (message === void 0) {
    message = "Illegal state";
  }
  if (!cond)
    throw new Error("[mobx-utils] " + message);
}
__name(invariant, "invariant");
var deprecatedMessages = [];
function deprecated(msg) {
  if (deprecatedMessages.indexOf(msg) !== -1)
    return;
  deprecatedMessages.push(msg);
  console.error("[mobx-utils] Deprecated: " + msg);
}
__name(deprecated, "deprecated");
function addHiddenProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
__name(addHiddenProp, "addHiddenProp");
var PENDING = "pending";
var FULFILLED = "fulfilled";
var REJECTED = "rejected";
function caseImpl(handlers) {
  switch (this.state) {
    case PENDING:
      return handlers.pending && handlers.pending();
    case REJECTED:
      return handlers.rejected && handlers.rejected(this.value);
    case FULFILLED:
      return handlers.fulfilled && handlers.fulfilled(this.value);
  }
}
__name(caseImpl, "caseImpl");
function createObservablePromise(origPromise) {
  invariant(arguments.length === 1, "fromPromise expects exactly one argument");
  invariant(typeof origPromise === "function" || typeof origPromise === "object" && origPromise && typeof origPromise.then === "function", "Please pass a promise or function to fromPromise");
  if (origPromise.isPromiseBasedObservable === true)
    return origPromise;
  if (typeof origPromise === "function") {
    origPromise = new Promise(origPromise);
  }
  var promise = origPromise;
  origPromise.then(action("observableFromPromise-resolve", function(value) {
    promise.value = value;
    promise.state = FULFILLED;
  }), action("observableFromPromise-reject", function(reason) {
    promise.value = reason;
    promise.state = REJECTED;
  }));
  promise.isPromiseBasedObservable = true;
  promise.case = caseImpl;
  extendObservable(promise, {
    value: void 0,
    state: PENDING
  }, {}, { deep: false });
  return promise;
}
__name(createObservablePromise, "createObservablePromise");
var fromPromise = createObservablePromise;
fromPromise.reject = action("fromPromise.reject", function(reason) {
  var p = fromPromise(Promise.reject(reason));
  p.state = REJECTED;
  p.value = reason;
  return p;
});
fromPromise.resolve = action("fromPromise.resolve", function(value) {
  if (value === void 0) {
    value = void 0;
  }
  var p = fromPromise(Promise.resolve(value));
  p.state = FULFILLED;
  p.value = value;
  return p;
});
function isPromiseBasedObservable(value) {
  return value && value.isPromiseBasedObservable === true;
}
__name(isPromiseBasedObservable, "isPromiseBasedObservable");
function moveItem(target, fromIndex, toIndex) {
  checkIndex(target, fromIndex);
  checkIndex(target, toIndex);
  if (fromIndex === toIndex) {
    return;
  }
  var oldItems = target.$mobx.values;
  var newItems;
  if (fromIndex < toIndex) {
    newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [
      oldItems[fromIndex]
    ], oldItems.slice(toIndex + 1));
  } else {
    newItems = oldItems.slice(0, toIndex).concat([
      oldItems[fromIndex]
    ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));
  }
  target.replace(newItems);
  return target;
}
__name(moveItem, "moveItem");
function checkIndex(target, index) {
  if (index < 0) {
    throw new Error("[mobx.array] Index out of bounds: " + index + " is negative");
  }
  var length = target.$mobx.values.length;
  if (index >= length) {
    throw new Error("[mobx.array] Index out of bounds: " + index + " is not smaller than " + length);
  }
}
__name(checkIndex, "checkIndex");
function lazyObservable(fetch, initialValue) {
  if (initialValue === void 0) {
    initialValue = void 0;
  }
  var started = false;
  var value = observable.box(initialValue, { deep: false });
  var currentFnc = /* @__PURE__ */ __name(function() {
    if (!started) {
      started = true;
      fetch(function(newValue) {
        allowStateChanges(true, function() {
          value.set(newValue);
        });
      });
    }
    return value.get();
  }, "currentFnc");
  var resetFnc = action("lazyObservable-reset", function() {
    value.set(initialValue);
    return value.get();
  });
  return {
    current: currentFnc,
    refresh: /* @__PURE__ */ __name(function() {
      if (started) {
        started = false;
        return currentFnc();
      } else {
        return value.get();
      }
    }, "refresh"),
    reset: /* @__PURE__ */ __name(function() {
      return resetFnc();
    }, "reset")
  };
}
__name(lazyObservable, "lazyObservable");
function fromResource(subscriber, unsubscriber, initialValue) {
  if (unsubscriber === void 0) {
    unsubscriber = NOOP;
  }
  if (initialValue === void 0) {
    initialValue = void 0;
  }
  var isActive = false;
  var isDisposed = false;
  var value = initialValue;
  var suspender = /* @__PURE__ */ __name(function() {
    if (isActive) {
      isActive = false;
      unsubscriber();
    }
  }, "suspender");
  var atom = createAtom("ResourceBasedObservable", function() {
    invariant(!isActive && !isDisposed);
    isActive = true;
    subscriber(function(newValue) {
      allowStateChanges(true, function() {
        value = newValue;
        atom.reportChanged();
      });
    });
  }, suspender);
  return {
    current: /* @__PURE__ */ __name(function() {
      invariant(!isDisposed, "subscribingObservable has already been disposed");
      var isBeingTracked = atom.reportObserved();
      if (!isBeingTracked && !isActive)
        console.warn("Called `get` of an subscribingObservable outside a reaction. Current value will be returned but no new subscription has started");
      return value;
    }, "current"),
    dispose: /* @__PURE__ */ __name(function() {
      isDisposed = true;
      suspender();
    }, "dispose"),
    isAlive: /* @__PURE__ */ __name(function() {
      return isActive;
    }, "isAlive")
  };
}
__name(fromResource, "fromResource");
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function observableSymbol() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}
__name(observableSymbol, "observableSymbol");
function self() {
  return this;
}
__name(self, "self");
function toStream(expression, fireImmediately) {
  if (fireImmediately === void 0) {
    fireImmediately = false;
  }
  var computedValue = computed(expression);
  return _a = {
    subscribe: /* @__PURE__ */ __name(function(observer) {
      return {
        unsubscribe: computedValue.observe(typeof observer === "function" ? function(_a2) {
          var newValue = _a2.newValue;
          return observer(newValue);
        } : function(_a2) {
          var newValue = _a2.newValue;
          return observer.next(newValue);
        }, fireImmediately)
      };
    }, "subscribe")
  }, _a[observableSymbol()] = self, _a;
  var _a;
}
__name(toStream, "toStream");
var StreamListener = (
  /** @class */
  function() {
    function StreamListener2(observable$$1, initialValue) {
      var _this = this;
      this.current = void 0;
      runInAction(function() {
        _this.current = initialValue;
        _this.subscription = observable$$1.subscribe(_this);
      });
    }
    __name(StreamListener2, "StreamListener");
    StreamListener2.prototype.dispose = function() {
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
    };
    StreamListener2.prototype.next = function(value) {
      this.current = value;
    };
    StreamListener2.prototype.complete = function() {
      this.dispose();
    };
    StreamListener2.prototype.error = function(value) {
      this.current = value;
      this.dispose();
    };
    __decorate([
      observable.ref
    ], StreamListener2.prototype, "current", void 0);
    __decorate([
      action.bound
    ], StreamListener2.prototype, "next", null);
    __decorate([
      action.bound
    ], StreamListener2.prototype, "complete", null);
    __decorate([
      action.bound
    ], StreamListener2.prototype, "error", null);
    return StreamListener2;
  }()
);
function fromStream(observable$$1, initialValue) {
  if (initialValue === void 0) {
    initialValue = void 0;
  }
  return new StreamListener(observable$$1, initialValue);
}
__name(fromStream, "fromStream");
var __decorate$1 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RESERVED_NAMES = ["model", "reset", "submit", "isDirty", "isPropertyDirty", "resetProperty"];
var ViewModel = (
  /** @class */
  function() {
    function ViewModel2(model) {
      var _this = this;
      this.model = model;
      this.localValues = observable.map({});
      this.isPropertyDirty = function(key) {
        return _this.localValues.has(key);
      };
      invariant(isObservableObject(model), "createViewModel expects an observable object");
      Object.keys(model).forEach(function(key) {
        invariant(RESERVED_NAMES.indexOf(key) === -1, "The propertyname " + key + " is reserved and cannot be used with viewModels");
        Object.defineProperty(_this, key, {
          enumerable: true,
          configurable: true,
          get: /* @__PURE__ */ __name(function() {
            if (_this.isPropertyDirty(key))
              return _this.localValues.get(key);
            else
              return _this.model[key];
          }, "get"),
          set: action(function(value) {
            if (_this.isPropertyDirty(key) || value !== _this.model[key]) {
              _this.localValues.set(key, value);
            }
          })
        });
      });
    }
    __name(ViewModel2, "ViewModel");
    Object.defineProperty(ViewModel2.prototype, "isDirty", {
      get: /* @__PURE__ */ __name(function() {
        return this.localValues.size > 0;
      }, "get"),
      enumerable: true,
      configurable: true
    });
    ViewModel2.prototype.submit = function() {
      var _this = this;
      keys(this.localValues).forEach(function(key) {
        var source = _this.localValues.get(key);
        var destination = _this.model[key];
        if (isObservableArray(destination)) {
          destination.replace(source);
        } else if (isObservableMap(destination)) {
          destination.clear();
          destination.merge(source);
        } else {
          _this.model[key] = source;
        }
      });
      this.localValues.clear();
    };
    ViewModel2.prototype.reset = function() {
      this.localValues.clear();
    };
    ViewModel2.prototype.resetProperty = function(key) {
      this.localValues.delete(key);
    };
    __decorate$1([
      computed
    ], ViewModel2.prototype, "isDirty", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "submit", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "reset", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "resetProperty", null);
    return ViewModel2;
  }()
);
function createViewModel(model) {
  return new ViewModel(model);
}
__name(createViewModel, "createViewModel");
function whenWithTimeout(expr2, action$$1, timeout, onTimeout) {
  if (timeout === void 0) {
    timeout = 1e4;
  }
  if (onTimeout === void 0) {
    onTimeout = /* @__PURE__ */ __name(function() {
    }, "onTimeout");
  }
  deprecated("whenWithTimeout is deprecated, use mobx.when with timeout option instead");
  return when(expr2, action$$1, {
    timeout,
    onError: onTimeout
  });
}
__name(whenWithTimeout, "whenWithTimeout");
function keepAlive(_1, _2) {
  var computed$$1 = getAtom(_1, _2);
  if (!computed$$1)
    throw new Error("No computed provided, please provide an object created with `computed(() => expr)` or an object + property name");
  return computed$$1.observe(function() {
  });
}
__name(keepAlive, "keepAlive");
function queueProcessor(observableArray, processor, debounce) {
  if (debounce === void 0) {
    debounce = 0;
  }
  if (!isObservableArray(observableArray))
    throw new Error("Expected observable array as first argument");
  if (!isAction(processor))
    processor = action("queueProcessor", processor);
  var runner = /* @__PURE__ */ __name(function() {
    var items = observableArray.slice(0);
    runInAction(function() {
      return observableArray.splice(0);
    });
    items.forEach(processor);
  }, "runner");
  if (debounce > 0)
    return autorun(runner, { delay: debounce });
  else
    return autorun(runner);
}
__name(queueProcessor, "queueProcessor");
function chunkProcessor(observableArray, processor, debounce, maxChunkSize) {
  if (debounce === void 0) {
    debounce = 0;
  }
  if (maxChunkSize === void 0) {
    maxChunkSize = 0;
  }
  if (!isObservableArray(observableArray))
    throw new Error("Expected observable array as first argument");
  if (!isAction(processor))
    processor = action("chunkProcessor", processor);
  var runner = /* @__PURE__ */ __name(function() {
    var _loop_1 = /* @__PURE__ */ __name(function() {
      var chunkSize = maxChunkSize === 0 ? observableArray.length : Math.min(observableArray.length, maxChunkSize);
      var items = observableArray.slice(0, chunkSize);
      runInAction(function() {
        return observableArray.splice(0, chunkSize);
      });
      processor(items);
    }, "_loop_1");
    while (observableArray.length > 0) {
      _loop_1();
    }
  }, "runner");
  if (debounce > 0)
    return autorun(runner, { delay: debounce });
  else
    return autorun(runner);
}
__name(chunkProcessor, "chunkProcessor");
var tickers = {};
function now(interval) {
  if (interval === void 0) {
    interval = 1e3;
  }
  if (!isComputingDerivation()) {
    return Date.now();
  }
  if (!tickers[interval]) {
    if (typeof interval === "number")
      tickers[interval] = createIntervalTicker(interval);
    else
      tickers[interval] = createAnimationFrameTicker();
  }
  return tickers[interval].current();
}
__name(now, "now");
function createIntervalTicker(interval) {
  var subscriptionHandle;
  return fromResource(function(sink) {
    subscriptionHandle = setInterval(function() {
      return sink(Date.now());
    }, interval);
  }, function() {
    clearInterval(subscriptionHandle);
  }, Date.now());
}
__name(createIntervalTicker, "createIntervalTicker");
function createAnimationFrameTicker() {
  var frameBasedTicker = fromResource(function(sink) {
    function scheduleTick() {
      window.requestAnimationFrame(function() {
        sink(Date.now());
        if (frameBasedTicker.isAlive())
          scheduleTick();
      });
    }
    __name(scheduleTick, "scheduleTick");
    scheduleTick();
  }, function() {
  }, Date.now());
  return frameBasedTicker;
}
__name(createAnimationFrameTicker, "createAnimationFrameTicker");
var __assign = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
      t[p] = s[p];
  }
  return t;
};
function asyncAction(arg1, arg2) {
  if (typeof arguments[1] === "string") {
    var name_1 = arguments[1];
    var descriptor_1 = arguments[2];
    if (descriptor_1 && descriptor_1.value) {
      return Object.assign({}, descriptor_1, {
        value: flow(descriptor_1.value)
      });
    } else {
      return Object.assign({}, descriptor_1, {
        set: /* @__PURE__ */ __name(function(v) {
          Object.defineProperty(this, name_1, __assign({}, descriptor_1, { value: flow(v) }));
        }, "set")
      });
    }
  }
  var generator = typeof arg1 === "string" ? arg2 : arg1;
  deprecated("asyncAction is deprecated. use mobx.flow instead");
  return flow(generator);
}
__name(asyncAction, "asyncAction");
function whenAsync(fn, timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  deprecated("whenAsync is deprecated, use mobx.when without effect instead");
  return when(fn, {
    timeout
  });
}
__name(whenAsync, "whenAsync");
function expr(expr2) {
  if (!isComputingDerivation())
    console.warn("'expr' should only be used inside other reactive functions.");
  return computed(expr2).get();
}
__name(expr, "expr");
var memoizationId = 0;
function createTransformer(transformer, onCleanup) {
  invariant(typeof transformer === "function" && transformer.length < 2, "createTransformer expects a function that accepts one argument");
  var views = {};
  function createView(sourceIdentifier, sourceObject) {
    var latestValue;
    var expr2 = computed(function() {
      return latestValue = transformer(sourceObject);
    }, {
      name: "Transformer-" + transformer.name + "-" + sourceIdentifier
    });
    var disposer = onBecomeUnobserved(expr2, function() {
      delete views[sourceIdentifier];
      disposer();
      if (onCleanup)
        onCleanup(latestValue, sourceObject);
    });
    return expr2;
  }
  __name(createView, "createView");
  return function(object) {
    var identifier = getMemoizationId(object);
    var reactiveView = views[identifier];
    if (reactiveView)
      return reactiveView.get();
    reactiveView = views[identifier] = createView(identifier, object);
    return reactiveView.get();
  };
}
__name(createTransformer, "createTransformer");
function getMemoizationId(object) {
  if (typeof object === "string" || typeof object === "number")
    return object;
  if (object === null || typeof object !== "object")
    throw new Error("[mobx-utils] transform expected an object, string or number, got: " + object);
  var tid = object.$transformId;
  if (tid === void 0) {
    tid = ++memoizationId;
    addHiddenProp(object, "$transformId", tid);
  }
  return tid;
}
__name(getMemoizationId, "getMemoizationId");
export {
  FULFILLED,
  IDENTITY,
  NOOP,
  PENDING,
  REJECTED,
  ViewModel,
  addHiddenProp,
  asyncAction,
  chunkProcessor,
  createTransformer,
  createViewModel,
  deprecated,
  expr,
  fromPromise,
  fromResource,
  fromStream,
  invariant,
  isPromiseBasedObservable,
  keepAlive,
  lazyObservable,
  moveItem,
  now,
  queueProcessor,
  toStream,
  whenAsync,
  whenWithTimeout
};
//# sourceMappingURL=mobx-utils.js.map
