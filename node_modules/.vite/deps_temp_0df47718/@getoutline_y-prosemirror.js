import {
  ContentFormat,
  ContentString,
  ContentType,
  Doc,
  Item,
  RelativePosition,
  Snapshot,
  UndoManager,
  YText,
  YXmlElement,
  YXmlFragment,
  YXmlText,
  compareRelativePositions,
  create,
  create2,
  createAbsolutePositionFromRelativePosition,
  createDeleteSet,
  createID,
  createRelativePositionFromJSON,
  createRelativePositionFromTypeIndex,
  createSnapshot,
  doc,
  findRootTypeKey,
  isBrowser,
  isDeleted,
  isParentOf,
  iterateDeletedStructs,
  keys,
  max,
  methodUnimplemented,
  min,
  oneOf,
  setIfUndefined,
  snapshot,
  timeout,
  typeListToArraySnapshot,
  unexpectedCase
} from "./chunk-2OJWYYAH.js";
import {
  Decoration,
  DecorationSet
} from "./chunk-QTUFFZTP.js";
import {
  Plugin,
  PluginKey,
  TextSelection
} from "./chunk-OT7EKHDX.js";
import "./chunk-DIZBEZUH.js";
import {
  Fragment,
  Node,
  Slice
} from "./chunk-VZET4HV4.js";
import {
  __name
} from "./chunk-4OCRLPSA.js";

// node_modules/lib0/mutex.js
var createMutex = /* @__PURE__ */ __name(() => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
}, "createMutex");

// node_modules/lib0/diff.js
var highSurrogateRegex = /[\uD800-\uDBFF]/;
var lowSurrogateRegex = /[\uDC00-\uDFFF]/;
var simpleDiffString = /* @__PURE__ */ __name((a, b) => {
  let left = 0;
  let right = 0;
  while (left < a.length && left < b.length && a[left] === b[left]) {
    left++;
  }
  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--;
  while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {
    right++;
  }
  if (right > 0 && lowSurrogateRegex.test(a[a.length - right])) right--;
  return {
    index: left,
    remove: a.length - left - right,
    insert: b.slice(left, b.length - right)
  };
}, "simpleDiffString");
var simpleDiff = simpleDiffString;

// node_modules/@getoutline/y-prosemirror/src/plugins/keys.js
var ySyncPluginKey = new PluginKey("y-sync");
var yUndoPluginKey = new PluginKey("y-undo");
var yCursorPluginKey = new PluginKey("yjs-cursor");

// node_modules/@getoutline/y-prosemirror/src/plugins/sync-plugin.js
var isVisible = /* @__PURE__ */ __name((item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && /** @type {number} */
snapshot2.sv.get(item.id.client) > item.id.clock && !isDeleted(snapshot2.ds, item.id), "isVisible");
var defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
var getUserColor = /* @__PURE__ */ __name((colorMapping, colors, user) => {
  if (!colorMapping.has(user)) {
    if (colorMapping.size < colors.length) {
      const usedColors = create2();
      colorMapping.forEach((color) => usedColors.add(color));
      colors = colors.filter((color) => !usedColors.has(color));
    }
    colorMapping.set(user, oneOf(colors));
  }
  return (
    /** @type {ColorDef} */
    colorMapping.get(user)
  );
}, "getUserColor");
var ySyncPlugin = /* @__PURE__ */ __name((yXmlFragment, { colors = defaultColors, colorMapping = /* @__PURE__ */ new Map(), permanentUserData = null } = {}) => {
  let changedInitialContent = false;
  let rerenderTimeoutId;
  const plugin = new Plugin({
    props: {
      editable: /* @__PURE__ */ __name((state) => {
        const syncState = ySyncPluginKey.getState(state);
        return syncState.snapshot == null && syncState.prevSnapshot == null;
      }, "editable")
    },
    key: ySyncPluginKey,
    state: {
      init: /* @__PURE__ */ __name((initargs, state) => {
        return {
          type: yXmlFragment,
          doc: yXmlFragment.doc,
          binding: null,
          snapshot: null,
          prevSnapshot: null,
          isChangeOrigin: false,
          colors,
          colorMapping,
          permanentUserData
        };
      }, "init"),
      apply: /* @__PURE__ */ __name((tr, pluginState) => {
        const change = tr.getMeta(ySyncPluginKey);
        if (change !== void 0) {
          pluginState = Object.assign({}, pluginState);
          for (const key in change) {
            pluginState[key] = change[key];
          }
        }
        pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
        if (pluginState.binding !== null) {
          if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
            timeout(0, () => {
              if (pluginState.binding == null || pluginState.binding.isDestroyed) {
                return;
              }
              if (change.restore == null) {
                pluginState.binding._renderSnapshot(change.snapshot, change.prevSnapshot, pluginState);
              } else {
                pluginState.binding._renderSnapshot(change.snapshot, change.snapshot, pluginState);
                delete pluginState.restore;
                delete pluginState.snapshot;
                delete pluginState.prevSnapshot;
                pluginState.binding._prosemirrorChanged(pluginState.binding.prosemirrorView.state.doc);
              }
            });
          }
        }
        return pluginState;
      }, "apply")
    },
    view: /* @__PURE__ */ __name((view) => {
      const binding = new ProsemirrorBinding(yXmlFragment, view);
      if (rerenderTimeoutId != null) {
        clearTimeout(rerenderTimeoutId);
      }
      rerenderTimeoutId = timeout(0, () => {
        binding._forceRerender();
        view.dispatch(view.state.tr.setMeta(ySyncPluginKey, { binding }));
      });
      return {
        update: /* @__PURE__ */ __name(() => {
          const pluginState = plugin.getState(view.state);
          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
            if (changedInitialContent || view.state.doc.content.findDiffStart(view.state.doc.type.createAndFill().content) !== null) {
              changedInitialContent = true;
              binding._prosemirrorChanged(view.state.doc);
            }
          }
        }, "update"),
        destroy: /* @__PURE__ */ __name(() => {
          clearTimeout(rerenderTimeoutId);
          binding.destroy();
        }, "destroy")
      };
    }, "view")
  });
  return plugin;
}, "ySyncPlugin");
var restoreRelativeSelection = /* @__PURE__ */ __name((tr, relSel, binding) => {
  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
    const anchor = relativePositionToAbsolutePosition(binding.doc, binding.type, relSel.anchor, binding.mapping);
    const head = relativePositionToAbsolutePosition(binding.doc, binding.type, relSel.head, binding.mapping);
    if (anchor !== null && head !== null) {
      tr = tr.setSelection(TextSelection.create(tr.doc, anchor, head));
    }
  }
}, "restoreRelativeSelection");
var getRelativeSelection = /* @__PURE__ */ __name((pmbinding, state) => ({
  anchor: absolutePositionToRelativePosition(state.selection.anchor, pmbinding.type, pmbinding.mapping),
  head: absolutePositionToRelativePosition(state.selection.head, pmbinding.type, pmbinding.mapping)
}), "getRelativeSelection");
var _ProsemirrorBinding = class _ProsemirrorBinding {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {any} prosemirrorView The target binding
   */
  constructor(yXmlFragment, prosemirrorView) {
    this.type = yXmlFragment;
    this.prosemirrorView = prosemirrorView;
    this.mux = createMutex();
    this.isDestroyed = false;
    this.mapping = /* @__PURE__ */ new Map();
    this._observeFunction = this._typeChanged.bind(this);
    this.doc = yXmlFragment.doc;
    this.beforeTransactionSelection = null;
    this.beforeAllTransactions = () => {
      if (this.beforeTransactionSelection === null) {
        this.beforeTransactionSelection = getRelativeSelection(this, prosemirrorView.state);
      }
    };
    this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    };
    this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.on("afterAllTransactions", this.afterAllTransactions);
    yXmlFragment.observeDeep(this._observeFunction);
    this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
  }
  _isLocalCursorInView() {
    if (!this.prosemirrorView.hasFocus()) return false;
    if (isBrowser && this._domSelectionInView === null) {
      timeout(0, () => {
        this._domSelectionInView = null;
      });
      this._domSelectionInView = this._isDomSelectionInView();
    }
    return this._domSelectionInView;
  }
  _isDomSelectionInView() {
    const selection = this.prosemirrorView._root.getSelection();
    const range = this.prosemirrorView._root.createRange();
    range.setStart(selection.anchorNode, selection.anchorOffset);
    range.setEnd(selection.focusNode, selection.focusOffset);
    const rects = range.getClientRects();
    if (rects.length === 0) {
      if (range.startContainer && range.collapsed) {
        range.selectNodeContents(range.startContainer);
      }
    }
    const bounding = range.getBoundingClientRect();
    const documentElement = doc.documentElement;
    return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
  }
  renderSnapshot(snapshot2, prevSnapshot) {
    if (!prevSnapshot) {
      prevSnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
    }
    this.prosemirrorView.dispatch(this._tr.setMeta(ySyncPluginKey, { snapshot: snapshot2, prevSnapshot }));
  }
  unrenderSnapshot() {
    this.mapping = /* @__PURE__ */ new Map();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map((t) => createNodeFromYElement(
        /** @type {Y.XmlElement} */
        t,
        this.prosemirrorView.state.schema,
        this.mapping
      )).filter((n) => n !== null);
      const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new Slice(new Fragment(fragmentContent), 0, 0));
      tr.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
      this.prosemirrorView.dispatch(tr);
    });
  }
  _forceRerender() {
    this.mapping = /* @__PURE__ */ new Map();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map((t) => createNodeFromYElement(
        /** @type {Y.XmlElement} */
        t,
        this.prosemirrorView.state.schema,
        this.mapping
      )).filter((n) => n !== null);
      const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new Slice(new Fragment(fragmentContent), 0, 0));
      this.prosemirrorView.dispatch(tr.setMeta(ySyncPluginKey, { isChangeOrigin: true }));
    });
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(snapshot2, prevSnapshot, pluginState) {
    if (!snapshot2) {
      snapshot2 = snapshot(this.doc);
    }
    this.mapping = /* @__PURE__ */ new Map();
    this.mux(() => {
      this.doc.transact((transaction) => {
        const pud = pluginState.permanentUserData;
        if (pud) {
          pud.dss.forEach((ds) => {
            iterateDeletedStructs(transaction, ds, (item) => {
            });
          });
        }
        const computeYChange = /* @__PURE__ */ __name((type, id) => {
          const user = type === "added" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);
          return {
            user,
            type,
            color: getUserColor(pluginState.colorMapping, pluginState.colors, user)
          };
        }, "computeYChange");
        const fragmentContent = typeListToArraySnapshot(this.type, new Snapshot(prevSnapshot.ds, snapshot2.sv)).map((t) => {
          if (!t._item.deleted || isVisible(t._item, snapshot2) || isVisible(t._item, prevSnapshot)) {
            return createNodeFromYElement(t, this.prosemirrorView.state.schema, /* @__PURE__ */ new Map(), snapshot2, prevSnapshot, computeYChange);
          } else {
            return null;
          }
        }).filter((n) => n !== null);
        const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new Slice(new Fragment(fragmentContent), 0, 0));
        this.prosemirrorView.dispatch(tr.setMeta(ySyncPluginKey, { isChangeOrigin: true }));
      }, ySyncPluginKey);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(events, transaction) {
    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
    if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
      return;
    }
    this.mux(() => {
      const delType = /* @__PURE__ */ __name((_, type) => this.mapping.delete(type), "delType");
      iterateDeletedStructs(transaction, transaction.deleteSet, (struct) => struct.constructor === Item && this.mapping.delete(
        /** @type {Y.ContentType} */
        /** @type {Y.Item} */
        struct.content.type
      ));
      transaction.changed.forEach(delType);
      transaction.changedParentTypes.forEach(delType);
      const fragmentContent = this.type.toArray().map((t) => createNodeIfNotExists(
        /** @type {Y.XmlElement | Y.XmlHook} */
        t,
        this.prosemirrorView.state.schema,
        this.mapping
      )).filter((n) => n !== null);
      let tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new Slice(new Fragment(fragmentContent), 0, 0));
      restoreRelativeSelection(tr, this.beforeTransactionSelection, this);
      tr = tr.setMeta(ySyncPluginKey, { isChangeOrigin: true });
      if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
        tr.scrollIntoView();
      }
      this.prosemirrorView.dispatch(tr);
    });
  }
  _prosemirrorChanged(doc2) {
    this.mux(() => {
      this.doc.transact(() => {
        updateYFragment(this.doc, this.type, doc2, this.mapping);
        this.beforeTransactionSelection = getRelativeSelection(this, this.prosemirrorView.state);
      }, ySyncPluginKey);
    });
  }
  destroy() {
    this.isDestroyed = true;
    this.type.unobserveDeep(this._observeFunction);
    this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.off("afterAllTransactions", this.afterAllTransactions);
  }
};
__name(_ProsemirrorBinding, "ProsemirrorBinding");
var ProsemirrorBinding = _ProsemirrorBinding;
var createNodeIfNotExists = /* @__PURE__ */ __name((el, schema, mapping, snapshot2, prevSnapshot, computeYChange) => {
  const node = (
    /** @type {PModel.Node} */
    mapping.get(el)
  );
  if (node === void 0) {
    if (el instanceof YXmlElement) {
      return createNodeFromYElement(el, schema, mapping, snapshot2, prevSnapshot, computeYChange);
    } else {
      throw methodUnimplemented();
    }
  }
  return node;
}, "createNodeIfNotExists");
var createNodeFromYElement = /* @__PURE__ */ __name((el, schema, mapping, snapshot2, prevSnapshot, computeYChange) => {
  const children = [];
  const createChildren = /* @__PURE__ */ __name((type) => {
    if (type.constructor === YXmlElement) {
      const n = createNodeIfNotExists(type, schema, mapping, snapshot2, prevSnapshot, computeYChange);
      if (n !== null) {
        children.push(n);
      }
    } else {
      const ns = createTextNodesFromYText(type, schema, mapping, snapshot2, prevSnapshot, computeYChange);
      if (ns !== null) {
        ns.forEach((textchild) => {
          if (textchild !== null) {
            children.push(textchild);
          }
        });
      }
    }
  }, "createChildren");
  if (snapshot2 === void 0 || prevSnapshot === void 0) {
    el.toArray().forEach(createChildren);
  } else {
    typeListToArraySnapshot(el, new Snapshot(prevSnapshot.ds, snapshot2.sv)).forEach(createChildren);
  }
  try {
    const attrs = el.getAttributes(snapshot2);
    if (snapshot2 !== void 0) {
      if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        snapshot2
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "removed",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "removed" };
      } else if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        prevSnapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "added",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "added" };
      }
    }
    const node = schema.node(el.nodeName, attrs, children);
    mapping.set(el, node);
    return node;
  } catch (e) {
    el.doc.transact((transaction) => {
      el._item.delete(transaction);
    }, ySyncPluginKey);
    mapping.delete(el);
    return null;
  }
}, "createNodeFromYElement");
var createTextNodesFromYText = /* @__PURE__ */ __name((text, schema, mapping, snapshot2, prevSnapshot, computeYChange) => {
  const nodes = [];
  const deltas = text.toDelta(snapshot2, prevSnapshot, computeYChange);
  try {
    for (let i = 0; i < deltas.length; i++) {
      const delta = deltas[i];
      const marks = [];
      for (const markName in delta.attributes) {
        marks.push(schema.mark(markName, delta.attributes[markName]));
      }
      nodes.push(schema.text(delta.insert, marks));
    }
  } catch (e) {
    text.doc.transact((transaction) => {
      text._item.delete(transaction);
    }, ySyncPluginKey);
    return null;
  }
  return nodes;
}, "createTextNodesFromYText");
var createTypeFromTextNodes = /* @__PURE__ */ __name((nodes, mapping) => {
  const type = new YXmlText();
  const delta = nodes.map((node) => ({
    // @ts-ignore
    insert: node.text,
    attributes: marksToAttributes(node.marks)
  }));
  type.applyDelta(delta);
  mapping.set(type, nodes);
  return type;
}, "createTypeFromTextNodes");
var createTypeFromElementNode = /* @__PURE__ */ __name((node, mapping) => {
  const type = new YXmlElement(node.type.name);
  for (const key in node.attrs) {
    const val = node.attrs[key];
    if (val !== null && key !== "ychange") {
      type.setAttribute(key, val);
    }
  }
  type.insert(0, normalizePNodeContent(node).map((n) => createTypeFromTextOrElementNode(n, mapping)));
  mapping.set(type, node);
  return type;
}, "createTypeFromElementNode");
var createTypeFromTextOrElementNode = /* @__PURE__ */ __name((node, mapping) => node instanceof Array ? createTypeFromTextNodes(node, mapping) : createTypeFromElementNode(node, mapping), "createTypeFromTextOrElementNode");
var isObject = /* @__PURE__ */ __name((val) => typeof val === "object" && val !== null, "isObject");
var equalAttrs = /* @__PURE__ */ __name((pattrs, yattrs) => {
  const keys2 = Object.keys(pattrs).filter((key) => pattrs[key] !== null);
  let eq = keys2.length === Object.keys(yattrs).filter((key) => yattrs[key] !== null).length;
  for (let i = 0; i < keys2.length && eq; i++) {
    const key = keys2[i];
    const l = pattrs[key];
    const r = yattrs[key];
    eq = key === "ychange" || l === r || isObject(l) && isObject(r) && equalAttrs(l, r);
  }
  return eq;
}, "equalAttrs");
var normalizePNodeContent = /* @__PURE__ */ __name((pnode) => {
  const c = pnode.content.content;
  const res = [];
  for (let i = 0; i < c.length; i++) {
    const n = c[i];
    if (n.isText) {
      const textNodes = [];
      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {
        textNodes.push(tnode);
      }
      i--;
      res.push(textNodes);
    } else {
      res.push(n);
    }
  }
  return res;
}, "normalizePNodeContent");
var equalYTextPText = /* @__PURE__ */ __name((ytext, ptexts) => {
  const delta = ytext.toDelta();
  return delta.length === ptexts.length && delta.every((d, i) => d.insert === /** @type {any} */
  ptexts[i].text && keys(d.attributes || {}).length === ptexts[i].marks.length && ptexts[i].marks.every((mark) => equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)));
}, "equalYTextPText");
var equalYTypePNode = /* @__PURE__ */ __name((ytype, pnode) => {
  if (ytype instanceof YXmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
    const normalizedContent = normalizePNodeContent(pnode);
    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every((ychild, i) => equalYTypePNode(ychild, normalizedContent[i]));
  }
  return ytype instanceof YXmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
}, "equalYTypePNode");
var mappedIdentity = /* @__PURE__ */ __name((mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every((a, i) => pcontent[i] === a), "mappedIdentity");
var computeChildEqualityFactor = /* @__PURE__ */ __name((ytype, pnode, mapping) => {
  const yChildren = ytype.toArray();
  const pChildren = normalizePNodeContent(pnode);
  const pChildCnt = pChildren.length;
  const yChildCnt = yChildren.length;
  const minCnt = min(yChildCnt, pChildCnt);
  let left = 0;
  let right = 0;
  let foundMappedChild = false;
  for (; left < minCnt; left++) {
    const leftY = yChildren[left];
    const leftP = pChildren[left];
    if (mappedIdentity(mapping.get(leftY), leftP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(leftY, leftP)) {
      break;
    }
  }
  for (; left + right < minCnt; right++) {
    const rightY = yChildren[yChildCnt - right - 1];
    const rightP = pChildren[pChildCnt - right - 1];
    if (mappedIdentity(mapping.get(rightY), rightP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(rightY, rightP)) {
      break;
    }
  }
  return {
    equalityFactor: left + right,
    foundMappedChild
  };
}, "computeChildEqualityFactor");
var ytextTrans = /* @__PURE__ */ __name((ytext) => {
  let str = "";
  let n = ytext._start;
  const nAttrs = {};
  while (n !== null) {
    if (!n.deleted) {
      if (n.countable && n.content instanceof ContentString) {
        str += n.content.str;
      } else if (n.content instanceof ContentFormat) {
        nAttrs[n.content.key] = null;
      }
    }
    n = n.right;
  }
  return {
    str,
    nAttrs
  };
}, "ytextTrans");
var updateYText = /* @__PURE__ */ __name((ytext, ptexts, mapping) => {
  mapping.set(ytext, ptexts);
  const { nAttrs, str } = ytextTrans(ytext);
  const content = ptexts.map((p) => ({ insert: (
    /** @type {any} */
    p.text
  ), attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks)) }));
  const { insert, remove, index } = simpleDiff(str, content.map((c) => c.insert).join(""));
  ytext.delete(index, remove);
  ytext.insert(index, insert);
  ytext.applyDelta(content.map((c) => ({ retain: c.insert.length, attributes: c.attributes })));
}, "updateYText");
var marksToAttributes = /* @__PURE__ */ __name((marks) => {
  const pattrs = {};
  marks.forEach((mark) => {
    if (mark.type.name !== "ychange") {
      pattrs[mark.type.name] = mark.attrs;
    }
  });
  return pattrs;
}, "marksToAttributes");
var updateYFragment = /* @__PURE__ */ __name((y, yDomFragment, pNode, mapping) => {
  if (yDomFragment instanceof YXmlElement && yDomFragment.nodeName !== pNode.type.name) {
    throw new Error("node name mismatch!");
  }
  mapping.set(yDomFragment, pNode);
  if (yDomFragment instanceof YXmlElement) {
    const yDomAttrs = yDomFragment.getAttributes();
    const pAttrs = pNode.attrs;
    for (const key in pAttrs) {
      if (pAttrs[key] !== null) {
        if (yDomAttrs[key] !== pAttrs[key] && key !== "ychange") {
          yDomFragment.setAttribute(key, pAttrs[key]);
        }
      } else {
        yDomFragment.removeAttribute(key);
      }
    }
    for (const key in yDomAttrs) {
      if (pAttrs[key] === void 0) {
        yDomFragment.removeAttribute(key);
      }
    }
  }
  const pChildren = normalizePNodeContent(pNode);
  const pChildCnt = pChildren.length;
  const yChildren = yDomFragment.toArray();
  const yChildCnt = yChildren.length;
  const minCnt = min(pChildCnt, yChildCnt);
  let left = 0;
  let right = 0;
  for (; left < minCnt; left++) {
    const leftY = yChildren[left];
    const leftP = pChildren[left];
    if (!mappedIdentity(mapping.get(leftY), leftP)) {
      if (equalYTypePNode(leftY, leftP)) {
        mapping.set(leftY, leftP);
      } else {
        break;
      }
    }
  }
  for (; right + left + 1 < minCnt; right++) {
    const rightY = yChildren[yChildCnt - right - 1];
    const rightP = pChildren[pChildCnt - right - 1];
    if (!mappedIdentity(mapping.get(rightY), rightP)) {
      if (equalYTypePNode(rightY, rightP)) {
        mapping.set(rightY, rightP);
      } else {
        break;
      }
    }
  }
  y.transact(() => {
    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {
      const leftY = yChildren[left];
      const leftP = pChildren[left];
      const rightY = yChildren[yChildCnt - right - 1];
      const rightP = pChildren[pChildCnt - right - 1];
      if (leftY instanceof YXmlText && leftP instanceof Array) {
        if (!equalYTextPText(leftY, leftP)) {
          updateYText(leftY, leftP, mapping);
        }
        left += 1;
      } else {
        let updateLeft = leftY instanceof YXmlElement && matchNodeName(leftY, leftP);
        let updateRight = rightY instanceof YXmlElement && matchNodeName(rightY, rightP);
        if (updateLeft && updateRight) {
          const equalityLeft = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            mapping
          );
          const equalityRight = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            mapping
          );
          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
            updateRight = false;
          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
            updateLeft = false;
          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
            updateLeft = false;
          } else {
            updateRight = false;
          }
        }
        if (updateLeft) {
          updateYFragment(
            y,
            /** @type {Y.XmlFragment} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            mapping
          );
          left += 1;
        } else if (updateRight) {
          updateYFragment(
            y,
            /** @type {Y.XmlFragment} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            mapping
          );
          right += 1;
        } else {
          yDomFragment.delete(left, 1);
          yDomFragment.insert(left, [createTypeFromTextOrElementNode(leftP, mapping)]);
          left += 1;
        }
      }
    }
    const yDelLen = yChildCnt - left - right;
    if (yDelLen > 0) {
      yDomFragment.delete(left, yDelLen);
    }
    if (left + right < pChildCnt) {
      const ins = [];
      for (let i = left; i < pChildCnt - right; i++) {
        ins.push(createTypeFromTextOrElementNode(pChildren[i], mapping));
      }
      yDomFragment.insert(left, ins);
    }
  }, ySyncPluginKey);
}, "updateYFragment");
var matchNodeName = /* @__PURE__ */ __name((yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name, "matchNodeName");

// node_modules/@getoutline/y-prosemirror/src/lib.js
var viewsToUpdate = null;
var updateMetas = /* @__PURE__ */ __name(() => {
  const ups = (
    /** @type {Map<EditorView, Map<any, any>>} */
    viewsToUpdate
  );
  viewsToUpdate = null;
  ups.forEach((metas, view) => {
    const tr = view.state.tr;
    const syncState = ySyncPluginKey.getState(view.state);
    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
      metas.forEach((val, key) => {
        tr.setMeta(key, val);
      });
      view.dispatch(tr);
    }
  });
}, "updateMetas");
var setMeta = /* @__PURE__ */ __name((view, key, value) => {
  if (!viewsToUpdate) {
    viewsToUpdate = /* @__PURE__ */ new Map();
    timeout(0, updateMetas);
  }
  setIfUndefined(viewsToUpdate, view, create).set(key, value);
}, "setMeta");
var absolutePositionToRelativePosition = /* @__PURE__ */ __name((pos, type, mapping) => {
  if (pos === 0) {
    return createRelativePositionFromTypeIndex(type, 0);
  }
  let n = type._first === null ? null : (
    /** @type {Y.ContentType} */
    type._first.content.type
  );
  while (n !== null && type !== n) {
    if (n instanceof YXmlText) {
      if (n._length >= pos) {
        return createRelativePositionFromTypeIndex(n, pos);
      } else {
        pos -= n._length;
      }
      if (n._item !== null && n._item.next !== null) {
        n = /** @type {Y.ContentType} */
        n._item.next.content.type;
      } else {
        do {
          n = n._item === null ? null : n._item.parent;
          pos--;
        } while (n !== type && n !== null && n._item !== null && n._item.next === null);
        if (n !== null && n !== type) {
          n = n._item === null ? null : (
            /** @type {Y.ContentType} */
            /** @type Y.Item */
            n._item.next.content.type
          );
        }
      }
    } else {
      const pNodeSize = (
        /** @type {any} */
        (mapping.get(n) || { nodeSize: 0 }).nodeSize
      );
      if (n._first !== null && pos < pNodeSize) {
        n = /** @type {Y.ContentType} */
        n._first.content.type;
        pos--;
      } else {
        if (pos === 1 && n._length === 0 && pNodeSize > 1) {
          return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
        }
        pos -= pNodeSize;
        if (n._item !== null && n._item.next !== null) {
          n = /** @type {Y.ContentType} */
          n._item.next.content.type;
        } else {
          if (pos === 0) {
            n = n._item === null ? n : n._item.parent;
            return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
          }
          do {
            n = /** @type {Y.Item} */
            n._item.parent;
            pos--;
          } while (n !== type && /** @type {Y.Item} */
          n._item.next === null);
          if (n !== type) {
            n = /** @type {Y.ContentType} */
            /** @type {Y.Item} */
            /** @type {Y.Item} */
            n._item.next.content.type;
          }
        }
      }
    }
    if (n === null) {
      throw unexpectedCase();
    }
    if (pos === 0 && n.constructor !== YXmlText && n !== type) {
      return createRelativePosition(n._item.parent, n._item);
    }
  }
  return createRelativePositionFromTypeIndex(type, type._length);
}, "absolutePositionToRelativePosition");
var createRelativePosition = /* @__PURE__ */ __name((type, item) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item.id);
}, "createRelativePosition");
var relativePositionToAbsolutePosition = /* @__PURE__ */ __name((y, documentType, relPos, mapping) => {
  const decodedPos = createAbsolutePositionFromRelativePosition(relPos, y);
  if (decodedPos === null || decodedPos.type !== documentType && !isParentOf(documentType, decodedPos.type._item)) {
    return null;
  }
  let type = decodedPos.type;
  let pos = 0;
  if (type.constructor === YXmlText) {
    pos = decodedPos.index;
  } else if (type._item === null || !type._item.deleted) {
    let n = type._first;
    let i = 0;
    while (i < type._length && i < decodedPos.index && n !== null) {
      if (!n.deleted) {
        const t = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        i++;
        if (t instanceof YXmlText) {
          pos += t._length;
        } else {
          pos += /** @type {any} */
          mapping.get(t).nodeSize;
        }
      }
      n = /** @type {Y.Item} */
      n.right;
    }
    pos += 1;
  }
  while (type !== documentType && type._item !== null) {
    const parent = type._item.parent;
    if (parent._item === null || !parent._item.deleted) {
      pos += 1;
      let n = (
        /** @type {Y.AbstractType} */
        parent._first
      );
      while (n !== null) {
        const contentType = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        if (contentType === type) {
          break;
        }
        if (!n.deleted) {
          if (contentType instanceof YXmlText) {
            pos += contentType._length;
          } else {
            pos += /** @type {any} */
            mapping.get(contentType).nodeSize;
          }
        }
        n = n.right;
      }
    }
    type = /** @type {Y.AbstractType} */
    parent;
  }
  return pos - 1;
}, "relativePositionToAbsolutePosition");
function prosemirrorToYDoc(doc2, xmlFragment = "prosemirror") {
  const ydoc = new Doc();
  const type = (
    /** @type {Y.XmlFragment} */
    ydoc.get(xmlFragment, YXmlFragment)
  );
  if (!type.doc) {
    return ydoc;
  }
  updateYFragment(type.doc, type, doc2, /* @__PURE__ */ new Map());
  return type.doc;
}
__name(prosemirrorToYDoc, "prosemirrorToYDoc");
function prosemirrorJSONToYDoc(schema, state, xmlFragment = "prosemirror") {
  const doc2 = Node.fromJSON(schema, state);
  return prosemirrorToYDoc(doc2, xmlFragment);
}
__name(prosemirrorJSONToYDoc, "prosemirrorJSONToYDoc");
function yDocToProsemirror(schema, ydoc) {
  const state = yDocToProsemirrorJSON(ydoc);
  return Node.fromJSON(schema, state);
}
__name(yDocToProsemirror, "yDocToProsemirror");
function yDocToProsemirrorJSON(ydoc, xmlFragment = "prosemirror") {
  const items = ydoc.getXmlFragment(xmlFragment).toArray();
  function serialize(item) {
    let response;
    if (!item.nodeName) {
      const delta = item.toDelta();
      response = delta.map((d) => {
        const text = {
          type: "text",
          text: d.insert
        };
        if (d.attributes) {
          text.marks = Object.keys(d.attributes).map((type) => {
            const attrs = d.attributes[type];
            const mark = {
              type
            };
            if (Object.keys(attrs)) {
              mark.attrs = attrs;
            }
            return mark;
          });
        }
        return text;
      });
    } else {
      response = {
        type: item.nodeName
      };
      const attrs = item.getAttributes();
      if (Object.keys(attrs).length) {
        response.attrs = attrs;
      }
      const children = item.toArray();
      if (children.length) {
        response.content = children.map(serialize).flat();
      }
    }
    return response;
  }
  __name(serialize, "serialize");
  return {
    type: "doc",
    content: items.map(serialize)
  };
}
__name(yDocToProsemirrorJSON, "yDocToProsemirrorJSON");

// node_modules/@getoutline/y-prosemirror/src/plugins/cursor-plugin.js
var defaultCursorBuilder = /* @__PURE__ */ __name((user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name), null);
  cursor.insertBefore(userDiv, null);
  return cursor;
}, "defaultCursorBuilder");
var defaultSelectionBuilder = /* @__PURE__ */ __name((user) => {
  return {
    style: `background-color: ${user.color}70`,
    class: `ProseMirror-yjs-selection`
  };
}, "defaultSelectionBuilder");
var rxValidColor = /^#[0-9a-fA-F]{6}$/;
var createDecorations = /* @__PURE__ */ __name((state, awareness, createCursor, createSelection) => {
  const ystate = ySyncPluginKey.getState(state);
  const y = ystate.doc;
  const decorations = [];
  if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding === null) {
    return DecorationSet.create(state.doc, []);
  }
  awareness.getStates().forEach((aw, clientId) => {
    if (clientId === y.clientID) {
      return;
    }
    if (aw.cursor != null) {
      const user = aw.user || {};
      if (user.color == null) {
        user.color = "#ffa500";
      } else if (!rxValidColor.test(user.color)) {
        console.warn("A user uses an unsupported color format", user);
      }
      if (user.name == null) {
        user.name = `User: ${clientId}`;
      }
      let anchor = relativePositionToAbsolutePosition(y, ystate.type, createRelativePositionFromJSON(aw.cursor.anchor), ystate.binding.mapping);
      let head = relativePositionToAbsolutePosition(y, ystate.type, createRelativePositionFromJSON(aw.cursor.head), ystate.binding.mapping);
      if (anchor !== null && head !== null) {
        const maxsize = max(state.doc.content.size - 1, 0);
        anchor = min(anchor, maxsize);
        head = min(head, maxsize);
        decorations.push(Decoration.widget(head, () => createCursor(user), { key: clientId + "", side: 10 }));
        const from = min(anchor, head);
        const to = max(anchor, head);
        decorations.push(Decoration.inline(from, to, createSelection(user), { inclusiveEnd: true, inclusiveStart: false }));
      }
    }
  });
  return DecorationSet.create(state.doc, decorations);
}, "createDecorations");
var yCursorPlugin = /* @__PURE__ */ __name((awareness, { cursorBuilder = defaultCursorBuilder, selectionBuilder = defaultSelectionBuilder, getSelection = /* @__PURE__ */ __name((state) => state.selection, "getSelection") } = {}, cursorStateField = "cursor") => new Plugin({
  key: yCursorPluginKey,
  state: {
    init(_, state) {
      return createDecorations(state, awareness, cursorBuilder, selectionBuilder);
    },
    apply(tr, prevState, oldState, newState) {
      const ystate = ySyncPluginKey.getState(newState);
      const yCursorState = tr.getMeta(yCursorPluginKey);
      if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
        return createDecorations(newState, awareness, cursorBuilder, selectionBuilder);
      }
      return prevState.map(tr.mapping, tr.doc);
    }
  },
  props: {
    decorations: /* @__PURE__ */ __name((state) => {
      return yCursorPluginKey.getState(state);
    }, "decorations")
  },
  view: /* @__PURE__ */ __name((view) => {
    const awarenessListener = /* @__PURE__ */ __name(() => {
      if (view.docView) {
        setMeta(view, yCursorPluginKey, { awarenessUpdated: true });
      }
    }, "awarenessListener");
    const updateCursorInfo = /* @__PURE__ */ __name(() => {
      const ystate = ySyncPluginKey.getState(view.state);
      const current = awareness.getLocalState() || {};
      if (ystate.binding == null) {
        return;
      }
      if (view.hasFocus()) {
        const selection = getSelection(view.state);
        const anchor = absolutePositionToRelativePosition(selection.anchor, ystate.type, ystate.binding.mapping);
        const head = absolutePositionToRelativePosition(selection.head, ystate.type, ystate.binding.mapping);
        if (current.cursor == null || !compareRelativePositions(createRelativePositionFromJSON(current.cursor.anchor), anchor) || !compareRelativePositions(createRelativePositionFromJSON(current.cursor.head), head)) {
          awareness.setLocalStateField(cursorStateField, {
            anchor,
            head
          });
        }
      } else if (current.cursor != null && relativePositionToAbsolutePosition(ystate.doc, ystate.type, createRelativePositionFromJSON(current.cursor.anchor), ystate.binding.mapping) !== null) {
        awareness.setLocalStateField(cursorStateField, null);
      }
    }, "updateCursorInfo");
    awareness.on("change", awarenessListener);
    view.dom.addEventListener("focusin", updateCursorInfo);
    view.dom.addEventListener("focusout", updateCursorInfo);
    return {
      update: updateCursorInfo,
      destroy: /* @__PURE__ */ __name(() => {
        view.dom.removeEventListener("focusin", updateCursorInfo);
        view.dom.removeEventListener("focusout", updateCursorInfo);
        awareness.off("change", awarenessListener);
        awareness.setLocalStateField(cursorStateField, null);
      }, "destroy")
    };
  }, "view")
}), "yCursorPlugin");

// node_modules/@getoutline/y-prosemirror/src/plugins/undo-plugin.js
var undo = /* @__PURE__ */ __name((state) => {
  const undoManager = yUndoPluginKey.getState(state).undoManager;
  if (undoManager != null) {
    undoManager.undo();
    return true;
  }
}, "undo");
var redo = /* @__PURE__ */ __name((state) => {
  const undoManager = yUndoPluginKey.getState(state).undoManager;
  if (undoManager != null) {
    undoManager.redo();
    return true;
  }
}, "redo");
var defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
var defaultDeleteFilter = /* @__PURE__ */ __name((item, protectedNodes) => !(item instanceof Item) || !(item.content instanceof ContentType) || !(item.content.type instanceof YText || item.content.type instanceof YXmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0, "defaultDeleteFilter");
var yUndoPlugin = /* @__PURE__ */ __name(({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({
  key: yUndoPluginKey,
  state: {
    init: /* @__PURE__ */ __name((initargs, state) => {
      const ystate = ySyncPluginKey.getState(state);
      const _undoManager = undoManager || new UndoManager(ystate.type, {
        trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
        deleteFilter: /* @__PURE__ */ __name((item) => defaultDeleteFilter(item, protectedNodes), "deleteFilter")
      });
      return {
        undoManager: _undoManager,
        prevSel: null,
        hasUndoOps: _undoManager.undoStack.length > 0,
        hasRedoOps: _undoManager.redoStack.length > 0
      };
    }, "init"),
    apply: /* @__PURE__ */ __name((tr, val, oldState, state) => {
      const binding = ySyncPluginKey.getState(state).binding;
      const undoManager2 = val.undoManager;
      const hasUndoOps = undoManager2.undoStack.length > 0;
      const hasRedoOps = undoManager2.redoStack.length > 0;
      if (binding) {
        return {
          undoManager: undoManager2,
          prevSel: getRelativeSelection(binding, oldState),
          hasUndoOps,
          hasRedoOps
        };
      } else {
        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
          return Object.assign({}, val, {
            hasUndoOps: undoManager2.undoStack.length > 0,
            hasRedoOps: undoManager2.redoStack.length > 0
          });
        } else {
          return val;
        }
      }
    }, "apply")
  },
  view: /* @__PURE__ */ __name((view) => {
    const ystate = ySyncPluginKey.getState(view.state);
    const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
    undoManager2.on("stack-item-added", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
      }
    });
    undoManager2.on("stack-item-popped", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
      }
    });
    return {
      destroy: /* @__PURE__ */ __name(() => {
        undoManager2.destroy();
      }, "destroy")
    };
  }, "view")
}), "yUndoPlugin");
export {
  ProsemirrorBinding,
  absolutePositionToRelativePosition,
  createDecorations,
  defaultCursorBuilder,
  defaultDeleteFilter,
  defaultProtectedNodes,
  defaultSelectionBuilder,
  getRelativeSelection,
  isVisible,
  prosemirrorJSONToYDoc,
  prosemirrorToYDoc,
  redo,
  relativePositionToAbsolutePosition,
  setMeta,
  undo,
  updateYFragment,
  yCursorPlugin,
  yCursorPluginKey,
  yDocToProsemirror,
  yDocToProsemirrorJSON,
  ySyncPlugin,
  ySyncPluginKey,
  yUndoPlugin,
  yUndoPluginKey
};
//# sourceMappingURL=@getoutline_y-prosemirror.js.map
