import {
  require_react
} from "./chunk-NSZELEHI.js";
import {
  __commonJS,
  __name,
  __toESM
} from "./chunk-4OCRLPSA.js";

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports, module) {
    "use strict";
    var __DEV__ = true;
    var warning2 = /* @__PURE__ */ __name(function() {
    }, "warning");
    if (__DEV__) {
      printWarning = /* @__PURE__ */ __name(function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      }, "printWarning");
      warning2 = /* @__PURE__ */ __name(function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      }, "warning");
    }
    var printWarning;
    module.exports = warning2;
  }
});

// node_modules/@getoutline/react-roving-tabindex/dist/index.es.js
var import_react = __toESM(require_react());
var import_warning = __toESM(require_warning());
var __assign = /* @__PURE__ */ __name(function() {
  __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  }, "__assign");
  return __assign.apply(this, arguments);
}, "__assign");
var EventKey;
(function(EventKey2) {
  EventKey2["ArrowLeft"] = "ArrowLeft";
  EventKey2["ArrowRight"] = "ArrowRight";
  EventKey2["ArrowUp"] = "ArrowUp";
  EventKey2["ArrowDown"] = "ArrowDown";
  EventKey2["Home"] = "Home";
  EventKey2["End"] = "End";
})(EventKey || (EventKey = {}));
var Navigation;
(function(Navigation2) {
  Navigation2["PREVIOUS"] = "PREVIOUS";
  Navigation2["NEXT"] = "NEXT";
  Navigation2["VERY_FIRST"] = "VERY_FIRST";
  Navigation2["VERY_LAST"] = "VERY_LAST";
  Navigation2["PREVIOUS_ROW"] = "PREVIOUS_ROW";
  Navigation2["NEXT_ROW"] = "NEXT_ROW";
  Navigation2["FIRST_IN_ROW"] = "FIRST_IN_ROW";
  Navigation2["LAST_IN_ROW"] = "LAST_IN_ROW";
})(Navigation || (Navigation = {}));
var ActionType;
(function(ActionType2) {
  ActionType2["REGISTER_TAB_STOP"] = "REGISTER_TAB_STOP";
  ActionType2["UNREGISTER_TAB_STOP"] = "UNREGISTER_TAB_STOP";
  ActionType2["KEY_DOWN"] = "KEY_DOWN";
  ActionType2["CLICKED"] = "CLICKED";
  ActionType2["TAB_STOP_UPDATED"] = "TAB_STOP_UPDATED";
  ActionType2["OPTIONS_UPDATED"] = "OPTIONS_UPDATED";
  ActionType2["FOCUSED"] = "FOCUSED";
  ActionType2["ITEMS_UPDATED"] = "ITEMS_UPDATED";
})(ActionType || (ActionType = {}));
var DOCUMENT_POSITION_FOLLOWING = 4;
function reducer(state, action) {
  switch (action.type) {
    case ActionType.REGISTER_TAB_STOP: {
      var newTabStop = action.payload;
      if (!newTabStop.domElementRef.current) {
        return state;
      }
      var indexToInsertAt = -1;
      for (var i = state.tabStops.length - 1; i >= 0; --i) {
        var loopTabStop = state.tabStops[i];
        if (loopTabStop.id === newTabStop.id) {
          (0, import_warning.default)(false, "'".concat(newTabStop.id, "' tab stop already registered"));
          return state;
        }
        if (indexToInsertAt === -1 && loopTabStop.domElementRef.current && !!(loopTabStop.domElementRef.current.compareDocumentPosition(newTabStop.domElementRef.current) & DOCUMENT_POSITION_FOLLOWING)) {
          indexToInsertAt = i + 1;
          break;
        }
      }
      if (indexToInsertAt === -1) {
        indexToInsertAt = 0;
      }
      var newTabStops = state.tabStops.slice();
      newTabStops.splice(indexToInsertAt, 0, newTabStop);
      return __assign(__assign({}, state), { selectedId: getUpdatedSelectedId(newTabStops, state.selectedId), tabStops: newTabStops, rowStartMap: null });
    }
    case ActionType.UNREGISTER_TAB_STOP: {
      var id_1 = action.payload.id;
      var newTabStops = state.tabStops.filter(function(tabStop2) {
        return tabStop2.id !== id_1;
      });
      if (newTabStops.length === state.tabStops.length) {
        (0, import_warning.default)(false, "'".concat(id_1, "' tab stop already unregistered"));
        return state;
      }
      return __assign(__assign({}, state), { allowFocusing: false, selectedId: getUpdatedSelectedId(newTabStops, state.selectedId), tabStops: newTabStops, rowStartMap: null });
    }
    case ActionType.TAB_STOP_UPDATED: {
      var _a = action.payload, id_2 = _a.id, rowIndex = _a.rowIndex, disabled = _a.disabled;
      var index = state.tabStops.findIndex(function(tabStop2) {
        return tabStop2.id === id_2;
      });
      if (index === -1) {
        (0, import_warning.default)(false, "'".concat(id_2, "' tab stop not registered"));
        return state;
      }
      var tabStop = state.tabStops[index];
      if (tabStop.disabled === disabled && tabStop.rowIndex === rowIndex) {
        return state;
      }
      var newTabStop = __assign(__assign({}, tabStop), { rowIndex, disabled });
      var newTabStops = state.tabStops.slice();
      newTabStops.splice(index, 1, newTabStop);
      return __assign(__assign({}, state), { selectedId: getUpdatedSelectedId(newTabStops, state.selectedId), tabStops: newTabStops, rowStartMap: null });
    }
    case ActionType.FOCUSED: {
      return __assign(__assign({}, state), { selectedId: getUpdatedSelectedId(state.tabStops, action.payload.id) });
    }
    case ActionType.ITEMS_UPDATED: {
      return __assign(__assign({}, state), { items: action.payload.items });
    }
    case ActionType.KEY_DOWN: {
      var _b = action.payload, id_3 = _b.id, key = _b.key, ctrlKey = _b.ctrlKey;
      var index = state.tabStops.findIndex(function(tabStop2) {
        return tabStop2.id === id_3;
      });
      if (index === -1) {
        (0, import_warning.default)(false, "'".concat(id_3, "' tab stop not registered"));
        return state;
      }
      var currentTabStop = state.tabStops[index];
      if (currentTabStop.disabled) {
        return state;
      }
      var isGrid = currentTabStop.rowIndex !== null;
      var isFirst = index === findIndexOfVeryFirstActiveTabStop(state.tabStops);
      var isLast = index === findIndexOfVeryLastActiveTabStop(state.tabStops);
      var navigation = getNavigationValue(key, ctrlKey, isGrid, state.direction, state.loopAround, isFirst, isLast);
      if (!navigation) {
        return state;
      }
      switch (navigation) {
        case Navigation.NEXT:
          {
            for (var i = index + 1; i < state.tabStops.length; ++i) {
              var tabStop = state.tabStops[i];
              if (isGrid && tabStop.rowIndex !== currentTabStop.rowIndex) {
                break;
              }
              if (!tabStop.disabled) {
                return selectTabStop(state, tabStop);
              }
            }
          }
          break;
        case Navigation.PREVIOUS:
          {
            for (var i = index - 1; i >= 0; --i) {
              var tabStop = state.tabStops[i];
              if (isGrid && tabStop.rowIndex !== currentTabStop.rowIndex) {
                break;
              }
              if (!tabStop.disabled) {
                return selectTabStop(state, tabStop);
              }
            }
          }
          break;
        case Navigation.VERY_FIRST:
          {
            var index_1 = findIndexOfVeryFirstActiveTabStop(state.tabStops);
            if (index_1 > -1) {
              return selectTabStop(state, state.tabStops[index_1]);
            }
          }
          break;
        case Navigation.VERY_LAST:
          {
            var index_2 = findIndexOfVeryLastActiveTabStop(state.tabStops);
            if (index_2 > -1) {
              return selectTabStop(state, state.tabStops[index_2]);
            }
          }
          break;
        case Navigation.PREVIOUS_ROW: {
          if (currentTabStop.rowIndex === null || currentTabStop.rowIndex === 0) {
            return state;
          }
          var rowStartMap = state.rowStartMap || createRowStartMap(state);
          var rowStartIndex = rowStartMap.get(currentTabStop.rowIndex);
          if (rowStartIndex === void 0) {
            return state;
          }
          var columnOffset = index - rowStartIndex;
          for (var i = currentTabStop.rowIndex - 1; i >= 0; --i) {
            var rowStartIndex_1 = rowStartMap.get(i);
            if (rowStartIndex_1 === void 0) {
              return state;
            }
            var rowTabStop = state.tabStops[rowStartIndex_1 + columnOffset];
            if (rowTabStop && !rowTabStop.disabled) {
              return selectTabStop(state, rowTabStop, rowStartMap);
            }
          }
          return __assign(__assign({}, state), { allowFocusing: true, rowStartMap });
        }
        case Navigation.NEXT_ROW: {
          var maxRowIndex = state.tabStops[state.tabStops.length - 1].rowIndex;
          if (currentTabStop.rowIndex === null || maxRowIndex === null || currentTabStop.rowIndex === maxRowIndex) {
            return state;
          }
          var rowStartMap = state.rowStartMap || createRowStartMap(state);
          var rowStartIndex = rowStartMap.get(currentTabStop.rowIndex);
          if (rowStartIndex === void 0) {
            return state;
          }
          var columnOffset = index - rowStartIndex;
          for (var i = currentTabStop.rowIndex + 1; i <= maxRowIndex; ++i) {
            var rowStartIndex_2 = rowStartMap.get(i);
            if (rowStartIndex_2 === void 0) {
              return state;
            }
            var rowTabStop = state.tabStops[rowStartIndex_2 + columnOffset];
            if (rowTabStop && !rowTabStop.disabled) {
              return selectTabStop(state, rowTabStop, rowStartMap);
            }
          }
          return __assign(__assign({}, state), { allowFocusing: true, rowStartMap });
        }
        case Navigation.FIRST_IN_ROW:
          {
            if (currentTabStop.rowIndex === null) {
              return state;
            }
            var rowStartMap = state.rowStartMap || createRowStartMap(state);
            var rowStartIndex = rowStartMap.get(currentTabStop.rowIndex);
            if (rowStartIndex === void 0) {
              return state;
            }
            for (var i = rowStartIndex; i < state.tabStops.length; ++i) {
              var tabStop = state.tabStops[i];
              if (tabStop.rowIndex !== currentTabStop.rowIndex) {
                break;
              } else if (!tabStop.disabled) {
                return selectTabStop(state, state.tabStops[i], rowStartMap);
              }
            }
          }
          break;
        case Navigation.LAST_IN_ROW:
          {
            if (currentTabStop.rowIndex === null) {
              return state;
            }
            var rowStartMap = state.rowStartMap || createRowStartMap(state);
            var rowEndIndex = rowStartMap.has(currentTabStop.rowIndex + 1) ? (rowStartMap.get(currentTabStop.rowIndex + 1) || 0) - 1 : state.tabStops.length - 1;
            for (var i = rowEndIndex; i >= 0; --i) {
              var tabStop = state.tabStops[i];
              if (tabStop.rowIndex !== currentTabStop.rowIndex) {
                break;
              } else if (!tabStop.disabled) {
                return selectTabStop(state, state.tabStops[i], rowStartMap);
              }
            }
          }
          break;
      }
      return state;
    }
    case ActionType.CLICKED: {
      var id_4 = action.payload.id;
      var index = state.tabStops.findIndex(function(tabStop2) {
        return tabStop2.id === id_4;
      });
      if (index === -1) {
        (0, import_warning.default)(false, "'".concat(id_4, "' tab stop not registered"));
        return state;
      }
      var currentTabStop = state.tabStops[index];
      return currentTabStop.disabled ? state : selectTabStop(state, currentTabStop, void 0, state.focusOnClick);
    }
    case ActionType.OPTIONS_UPDATED:
      return __assign(__assign({}, state), action.payload);
    default:
      return state;
  }
}
__name(reducer, "reducer");
function findIndexOfVeryFirstActiveTabStop(tabStops) {
  return tabStops.findIndex(function(tabStop) {
    return !tabStop.disabled;
  });
}
__name(findIndexOfVeryFirstActiveTabStop, "findIndexOfVeryFirstActiveTabStop");
function findIndexOfVeryLastActiveTabStop(tabStops) {
  for (var i = tabStops.length - 1; i >= 0; --i) {
    var tabStop = tabStops[i];
    if (!tabStop.disabled) {
      return i;
    }
  }
  return -1;
}
__name(findIndexOfVeryLastActiveTabStop, "findIndexOfVeryLastActiveTabStop");
function getUpdatedSelectedId(tabStops, currentSelectedId) {
  if (currentSelectedId === null) {
    var index_3 = tabStops.findIndex(function(tabStop) {
      return !tabStop.disabled;
    });
    return index_3 === -1 ? null : tabStops[index_3].id;
  }
  var index = tabStops.findIndex(function(tabStop) {
    return tabStop.id === currentSelectedId;
  });
  if (index !== -1 && !tabStops[index].disabled) {
    return currentSelectedId;
  }
  index = tabStops.findIndex(function(tabStop) {
    return !tabStop.disabled;
  });
  return index === -1 ? null : tabStops[index].id;
}
__name(getUpdatedSelectedId, "getUpdatedSelectedId");
function getNavigationValue(key, ctrlKey, isGrid, direction, loopAround, isFirst, isLast) {
  switch (key) {
    case EventKey.ArrowLeft:
      if (isGrid || direction === "horizontal" || direction === "both") {
        return !isGrid && loopAround && isFirst ? Navigation.VERY_LAST : Navigation.PREVIOUS;
      }
      return null;
    case EventKey.ArrowRight:
      if (isGrid || direction === "horizontal" || direction === "both") {
        return !isGrid && loopAround && isLast ? Navigation.VERY_FIRST : Navigation.NEXT;
      }
      return null;
    case EventKey.ArrowUp:
      if (isGrid) {
        return Navigation.PREVIOUS_ROW;
      } else if (direction === "vertical" || direction === "both") {
        return loopAround && isFirst ? Navigation.VERY_LAST : Navigation.PREVIOUS;
      }
      return null;
    case EventKey.ArrowDown:
      if (isGrid) {
        return Navigation.NEXT_ROW;
      } else if (direction === "vertical" || direction === "both") {
        return loopAround && isLast ? Navigation.VERY_FIRST : Navigation.NEXT;
      }
      return null;
    case EventKey.Home:
      return !isGrid || ctrlKey ? Navigation.VERY_FIRST : Navigation.FIRST_IN_ROW;
    case EventKey.End:
      return !isGrid || ctrlKey ? Navigation.VERY_LAST : Navigation.LAST_IN_ROW;
    default:
      return null;
  }
}
__name(getNavigationValue, "getNavigationValue");
function selectTabStop(state, tabStop, rowStartMap, allowFocusing) {
  if (allowFocusing === void 0) {
    allowFocusing = true;
  }
  return __assign(__assign({}, state), { allowFocusing, selectedId: tabStop.id, rowStartMap: rowStartMap || state.rowStartMap });
}
__name(selectTabStop, "selectTabStop");
function createRowStartMap(state) {
  var map = /* @__PURE__ */ new Map();
  for (var i = 0; i < state.tabStops.length; ++i) {
    var rowIndex = state.tabStops[i].rowIndex;
    if (rowIndex !== null && !map.has(rowIndex)) {
      map.set(rowIndex, i);
    }
  }
  return map;
}
__name(createRowStartMap, "createRowStartMap");
var INITIAL_STATE = {
  items: [],
  selectedId: null,
  allowFocusing: false,
  tabStops: [],
  direction: "horizontal",
  focusOnClick: false,
  loopAround: false,
  rowStartMap: null
};
var RovingTabIndexContext = (0, import_react.createContext)({
  state: INITIAL_STATE,
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  dispatch: /* @__PURE__ */ __name(function() {
  }, "dispatch")
});
var Provider = /* @__PURE__ */ __name(function(_a) {
  var children = _a.children, options = _a.options, items = _a.items;
  var _b = (0, import_react.useReducer)(reducer, __assign(__assign({}, INITIAL_STATE), options)), state = _b[0], dispatch = _b[1];
  (0, import_react.useEffect)(function() {
    dispatch({ type: ActionType.ITEMS_UPDATED, payload: { items } });
  }, [items]);
  (0, import_react.useEffect)(function() {
    var _a2, _b2, _c;
    dispatch({
      type: ActionType.OPTIONS_UPDATED,
      payload: {
        direction: (_a2 = options === null || options === void 0 ? void 0 : options.direction) !== null && _a2 !== void 0 ? _a2 : INITIAL_STATE.direction,
        focusOnClick: (_b2 = options === null || options === void 0 ? void 0 : options.focusOnClick) !== null && _b2 !== void 0 ? _b2 : INITIAL_STATE.focusOnClick,
        loopAround: (_c = options === null || options === void 0 ? void 0 : options.loopAround) !== null && _c !== void 0 ? _c : INITIAL_STATE.loopAround
      }
    });
  }, [options === null || options === void 0 ? void 0 : options.direction, options === null || options === void 0 ? void 0 : options.focusOnClick, options === null || options === void 0 ? void 0 : options.loopAround]);
  var context = (0, import_react.useMemo)(function() {
    return { state, dispatch };
  }, [state]);
  return import_react.default.createElement(RovingTabIndexContext.Provider, { value: context }, children);
}, "Provider");
var counter = 0;
function uniqueId() {
  return "rti_".concat(++counter);
}
__name(uniqueId, "uniqueId");
function useRovingTabIndex(domElementRef, disabled, rowIndex) {
  if (rowIndex === void 0) {
    rowIndex = null;
  }
  var idRef = (0, import_react.useRef)(null);
  function getId() {
    if (!idRef.current) {
      idRef.current = uniqueId();
    }
    return idRef.current;
  }
  __name(getId, "getId");
  var isMounted = (0, import_react.useRef)(false);
  var context = (0, import_react.useContext)(RovingTabIndexContext);
  (0, import_react.useEffect)(function() {
    var id = getId();
    context.dispatch({
      type: ActionType.REGISTER_TAB_STOP,
      payload: {
        id,
        domElementRef,
        rowIndex,
        disabled
      }
    });
    return function() {
      context.dispatch({
        type: ActionType.UNREGISTER_TAB_STOP,
        payload: { id }
      });
    };
  }, [context.state.items]);
  (0, import_react.useEffect)(function() {
    if (isMounted.current) {
      context.dispatch({
        type: ActionType.TAB_STOP_UPDATED,
        payload: {
          id: getId(),
          rowIndex,
          disabled
        }
      });
    } else {
      isMounted.current = true;
    }
  }, [rowIndex, disabled]);
  var handleKeyDown = (0, import_react.useCallback)(function(event) {
    var key = EventKey[event.key];
    if (!key) {
      return;
    }
    context.dispatch({
      type: ActionType.KEY_DOWN,
      payload: { id: getId(), key, ctrlKey: event.ctrlKey }
    });
    event.preventDefault();
  }, []);
  var handleClick = (
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (0, import_react.useCallback)(function(_ev) {
      context.dispatch({ type: ActionType.CLICKED, payload: { id: getId() } });
    }, [])
  );
  var handleFocus = (
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (0, import_react.useCallback)(function(_ev) {
      context.dispatch({
        type: ActionType.FOCUSED,
        payload: { id: getId() }
      });
    }, [])
  );
  var selected = getId() === context.state.selectedId;
  var tabIndex = selected ? 0 : -1;
  var focused = selected && context.state.allowFocusing;
  return {
    tabIndex,
    focused,
    onKeyDown: handleKeyDown,
    onClick: handleClick,
    onFocus: handleFocus
  };
}
__name(useRovingTabIndex, "useRovingTabIndex");
function useFocusEffect(focused, ref) {
  (0, import_react.useEffect)(function() {
    if (focused && ref.current) {
      ref.current.focus();
    }
  }, [focused]);
}
__name(useFocusEffect, "useFocusEffect");
export {
  ActionType,
  EventKey,
  Navigation,
  Provider as RovingTabIndexProvider,
  useFocusEffect,
  useRovingTabIndex
};
/*! Bundled license information:

@getoutline/react-roving-tabindex/dist/index.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@getoutline_react-roving-tabindex.js.map
