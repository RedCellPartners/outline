import {
  canUseDOM,
  closest,
  contains,
  getActiveElement,
  getDocument,
  getFirstTabbableIn,
  getLastTabbableIn,
  hasFocusWithin,
  isButton,
  isTabbable,
  useDisclosure,
  useDisclosureContent,
  useDisclosureState,
  useForkRef,
  useIsomorphicEffect,
  useLiveRef,
  useSealedState,
  useWarning,
  warning
} from "./chunk-BQDU2HTA.js";
import {
  _objectSpread2,
  _objectWithoutPropertiesLoose,
  createComponent,
  createHook,
  isObject,
  useCreateElement
} from "./chunk-EDJXIEOR.js";
import {
  disableBodyScroll,
  enableBodyScroll
} from "./chunk-U2TNXTE5.js";
import {
  require_react_dom
} from "./chunk-BCULJ5QE.js";
import {
  require_react
} from "./chunk-NSZELEHI.js";
import {
  __name,
  __toESM
} from "./chunk-4OCRLPSA.js";

// node_modules/reakit-utils/es/removeIndexFromArray.js
function removeIndexFromArray(array, index) {
  if (index === -1) return array;
  return [].concat(array.slice(0, index), array.slice(index + 1));
}
__name(removeIndexFromArray, "removeIndexFromArray");

// node_modules/reakit-utils/es/useUpdateEffect.js
var import_react = __toESM(require_react());
function useUpdateEffect(effect, deps) {
  var mounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    if (mounted.current) {
      return effect();
    }
    mounted.current = true;
    return void 0;
  }, deps);
}
__name(useUpdateEffect, "useUpdateEffect");

// node_modules/reakit-utils/es/getNextActiveElementOnBlur.js
var isIE11 = canUseDOM && "msCrypto" in window;
function getNextActiveElementOnBlur(event) {
  if (isIE11) {
    var activeElement = getActiveElement(event.currentTarget);
    return activeElement;
  }
  return event.relatedTarget;
}
__name(getNextActiveElementOnBlur, "getNextActiveElementOnBlur");

// node_modules/reakit-utils/es/hasFocus.js
function hasFocus(element) {
  var activeElement = getActiveElement(element);
  if (!activeElement) return false;
  if (activeElement === element) return true;
  var activeDescendant = activeElement.getAttribute("aria-activedescendant");
  if (!activeDescendant) return false;
  return activeDescendant === element.id;
}
__name(hasFocus, "hasFocus");

// node_modules/reakit-utils/es/ensureFocus.js
function ensureFocus(element, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, preventScroll = _ref.preventScroll, _ref$isActive = _ref.isActive, isActive = _ref$isActive === void 0 ? hasFocus : _ref$isActive;
  if (isActive(element)) return -1;
  element.focus({
    preventScroll
  });
  if (isActive(element)) return -1;
  return requestAnimationFrame(function() {
    element.focus({
      preventScroll
    });
  });
}
__name(ensureFocus, "ensureFocus");

// node_modules/reakit/es/Dialog/DialogState.js
var import_react2 = __toESM(require_react());
function useDialogState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  var _useSealedState = useSealedState(initialState), _useSealedState$modal = _useSealedState.modal, initialModal = _useSealedState$modal === void 0 ? true : _useSealedState$modal, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["modal"]);
  var disclosure = useDisclosureState(sealed);
  var _React$useState = (0, import_react2.useState)(initialModal), modal = _React$useState[0], setModal = _React$useState[1];
  var disclosureRef = (0, import_react2.useRef)(null);
  return _objectSpread2(_objectSpread2({}, disclosure), {}, {
    modal,
    setModal,
    unstable_disclosureRef: disclosureRef
  });
}
__name(useDialogState, "useDialogState");

// node_modules/reakit/es/Portal/Portal.js
var import_react3 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function getBodyElement() {
  return canUseDOM ? document.body : null;
}
__name(getBodyElement, "getBodyElement");
var PortalContext = (0, import_react3.createContext)(getBodyElement());
function Portal(_ref) {
  var children = _ref.children;
  var context = (0, import_react3.useContext)(PortalContext) || getBodyElement();
  var _React$useState = (0, import_react3.useState)(function() {
    if (canUseDOM) {
      var element = document.createElement("div");
      element.className = Portal.__className;
      return element;
    }
    return null;
  }), hostNode = _React$useState[0];
  useIsomorphicEffect(function() {
    if (!hostNode || !context) return void 0;
    context.appendChild(hostNode);
    return function() {
      context.removeChild(hostNode);
    };
  }, [hostNode, context]);
  if (hostNode) {
    return (0, import_react_dom.createPortal)((0, import_react3.createElement)(PortalContext.Provider, {
      value: hostNode
    }, children), hostNode);
  }
  return null;
}
__name(Portal, "Portal");
Portal.__className = "__reakit-portal";
Portal.__selector = "." + Portal.__className;

// node_modules/reakit-utils/es/removeItemFromArray.js
function removeItemFromArray(array, item) {
  var index = array.indexOf(item);
  return removeIndexFromArray(array, index);
}
__name(removeItemFromArray, "removeItemFromArray");

// node_modules/reakit/es/MenuContext-6af6cf92.js
var import_react4 = __toESM(require_react());
var MenuContext = (0, import_react4.createContext)(null);
function useMenuContext(menuRef, role, options) {
  var orphan = "unstable_orphan" in options && options.unstable_orphan;
  var parent = (0, import_react4.useContext)(MenuContext);
  var _React$useState = (0, import_react4.useState)([]), children = _React$useState[0], setChildren = _React$useState[1];
  var _ref = parent || {}, addChildToParent = _ref.addChild, removeChildFromParent = _ref.removeChild;
  var addChild = (0, import_react4.useCallback)(function(ref) {
    return setChildren(function(refs) {
      return [].concat(refs, [ref]);
    });
  }, []);
  var removeChild = (0, import_react4.useCallback)(function(ref) {
    return setChildren(function(refs) {
      return removeItemFromArray(refs, ref);
    });
  }, []);
  (0, import_react4.useEffect)(function() {
    if (!addChildToParent || orphan) return void 0;
    addChildToParent(menuRef);
    return function() {
      removeChildFromParent === null || removeChildFromParent === void 0 ? void 0 : removeChildFromParent(menuRef);
    };
  }, [menuRef, addChildToParent, removeChildFromParent, orphan]);
  var providerValue = (0, import_react4.useMemo)(function() {
    return {
      orientation: options.orientation,
      next: options.next,
      previous: options.previous,
      ref: menuRef,
      role,
      parent,
      children,
      addChild,
      removeChild
    };
  }, [options.orientation, options.next, options.previous, menuRef, role, parent, children, addChild, removeChild]);
  var wrapElement = (0, import_react4.useCallback)(function(element) {
    return (0, import_react4.createElement)(MenuContext.Provider, {
      value: providerValue
    }, element);
  }, [providerValue]);
  return wrapElement;
}
__name(useMenuContext, "useMenuContext");

// node_modules/reakit/es/DialogBackdropContext-8775f78b.js
var import_react5 = __toESM(require_react());
var DialogBackdropContext = (0, import_react5.createContext)(void 0);

// node_modules/reakit-utils/es/isEmpty.js
function isEmpty(arg) {
  if (Array.isArray(arg)) return !arg.length;
  if (isObject(arg)) return !Object.keys(arg).length;
  if (arg == null) return true;
  if (arg === "") return true;
  return false;
}
__name(isEmpty, "isEmpty");

// node_modules/reakit/es/__keys-ed7b48af.js
var DIALOG_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation", "modal", "unstable_disclosureRef", "setModal"];
var DIALOG_KEYS = [].concat(DIALOG_STATE_KEYS, ["hideOnEsc", "hideOnClickOutside", "preventBodyScroll", "unstable_initialFocusRef", "unstable_finalFocusRef", "unstable_orphan", "unstable_autoFocusOnShow", "unstable_autoFocusOnHide"]);
var DIALOG_BACKDROP_KEYS = DIALOG_STATE_KEYS;
var DIALOG_DISCLOSURE_KEYS = DIALOG_BACKDROP_KEYS;

// node_modules/reakit/es/Dialog/Dialog.js
var import_react6 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
function useDisclosureRef(dialogRef, options) {
  var ref = (0, import_react6.useRef)(null);
  var animating = !!(options.animated && options.animating);
  (0, import_react6.useEffect)(function() {
    if (options.visible || animating) return void 0;
    var onFocus = /* @__PURE__ */ __name(function onFocus2(event) {
      var target = event.target;
      if ("focus" in target) {
        ref.current = target;
        if (options.unstable_disclosureRef) {
          options.unstable_disclosureRef.current = target;
        }
      }
    }, "onFocus");
    var document2 = getDocument(dialogRef.current);
    document2.addEventListener("focusin", onFocus);
    return function() {
      return document2.removeEventListener("focusin", onFocus);
    };
  }, [options.visible, animating, options.unstable_disclosureRef, dialogRef]);
  (0, import_react6.useEffect)(function() {
    var _options$unstable_dis;
    if (!options.visible || animating) return void 0;
    var onMouseDown = /* @__PURE__ */ __name(function onMouseDown2(event) {
      var element = event.currentTarget;
      if (!isButton(element)) return;
      event.preventDefault();
      element.focus();
    }, "onMouseDown");
    var disclosure = ((_options$unstable_dis = options.unstable_disclosureRef) === null || _options$unstable_dis === void 0 ? void 0 : _options$unstable_dis.current) || ref.current;
    disclosure === null || disclosure === void 0 ? void 0 : disclosure.addEventListener("mousedown", onMouseDown);
    return function() {
      return disclosure === null || disclosure === void 0 ? void 0 : disclosure.removeEventListener("mousedown", onMouseDown);
    };
  }, [options.visible, animating, options.unstable_disclosureRef]);
  return options.unstable_disclosureRef || ref;
}
__name(useDisclosureRef, "useDisclosureRef");
function usePreventBodyScroll(targetRef, options) {
  var shouldPrevent = Boolean(options.preventBodyScroll && options.visible);
  (0, import_react6.useEffect)(function() {
    var element = targetRef.current;
    if (!element || !shouldPrevent) return void 0;
    disableBodyScroll(element, {
      reserveScrollBarGap: true
    });
    return function() {
      return enableBodyScroll(element);
    };
  }, [targetRef, shouldPrevent]);
}
__name(usePreventBodyScroll, "usePreventBodyScroll");
function useFocusOnShow(dialogRef, nestedDialogs, options) {
  var initialFocusRef = options.unstable_initialFocusRef;
  var shouldFocus = options.visible && options.unstable_autoFocusOnShow;
  var animating = !!(options.animated && options.animating);
  useUpdateEffect(function() {
    var dialog = dialogRef.current;
    true ? warning(!!shouldFocus && !dialog, "[reakit/Dialog]", "Can't set initial focus on dialog because `ref` wasn't passed to the dialog element.", "See https://reakit.io/docs/dialog") : void 0;
    if (!shouldFocus) return;
    if (!dialog) return;
    if (animating) return;
    if (nestedDialogs.some(function(child) {
      return child.current && !child.current.hidden;
    })) {
      return;
    }
    if (initialFocusRef !== null && initialFocusRef !== void 0 && initialFocusRef.current) {
      initialFocusRef.current.focus({
        preventScroll: true
      });
    } else {
      var tabbable = getFirstTabbableIn(dialog, true);
      var isActive = /* @__PURE__ */ __name(function isActive2() {
        return hasFocusWithin(dialog);
      }, "isActive");
      if (tabbable) {
        ensureFocus(tabbable, {
          preventScroll: true,
          isActive
        });
      } else {
        ensureFocus(dialog, {
          preventScroll: true,
          isActive
        });
        true ? warning(dialog.tabIndex === void 0 || dialog.tabIndex < 0, "It's recommended to have at least one tabbable element inside dialog. The dialog element has been automatically focused.", "If this is the intended behavior, pass `tabIndex={0}` to the dialog element to disable this warning.", "See https://reakit.io/docs/dialog/#initial-focus", dialog) : void 0;
      }
    }
  }, [dialogRef, shouldFocus, animating, nestedDialogs, initialFocusRef]);
}
__name(useFocusOnShow, "useFocusOnShow");
function usePortalRef(dialogRef, options) {
  var portalRef = (0, import_react6.useRef)(null);
  (0, import_react6.useEffect)(function() {
    var dialog = dialogRef.current;
    if (!dialog || !options.visible) return;
    portalRef.current = closest(dialog, Portal.__selector);
  }, [dialogRef, options.visible]);
  return portalRef;
}
__name(usePortalRef, "usePortalRef");
function removeFromDOM(element) {
  if (element.parentNode == null) return;
  element.parentNode.removeChild(element);
}
__name(removeFromDOM, "removeFromDOM");
var focusTrapClassName = "__reakit-focus-trap";
function isFocusTrap(element) {
  var _element$classList;
  return (_element$classList = element.classList) === null || _element$classList === void 0 ? void 0 : _element$classList.contains(focusTrapClassName);
}
__name(isFocusTrap, "isFocusTrap");
function useFocusTrap(dialogRef, visibleModals, options) {
  var portalRef = usePortalRef(dialogRef, options);
  var shouldTrap = options.visible && options.modal;
  var beforeElement = (0, import_react6.useRef)(null);
  var afterElement = (0, import_react6.useRef)(null);
  (0, import_react6.useEffect)(function() {
    if (!shouldTrap) return void 0;
    var portal = portalRef.current;
    if (!portal) {
      true ? warning(true, "Can't trap focus within modal dialog because either `ref` wasn't passed to component or the component wasn't rendered within a portal", "See https://reakit.io/docs/dialog") : void 0;
      return void 0;
    }
    if (!beforeElement.current) {
      var document2 = getDocument(portal);
      beforeElement.current = document2.createElement("div");
      beforeElement.current.className = focusTrapClassName;
      beforeElement.current.tabIndex = 0;
      beforeElement.current.style.position = "fixed";
      beforeElement.current.setAttribute("aria-hidden", "true");
    }
    if (!afterElement.current) {
      afterElement.current = beforeElement.current.cloneNode();
    }
    portal.insertAdjacentElement("beforebegin", beforeElement.current);
    portal.insertAdjacentElement("afterend", afterElement.current);
    return function() {
      if (beforeElement.current) removeFromDOM(beforeElement.current);
      if (afterElement.current) removeFromDOM(afterElement.current);
    };
  }, [portalRef, shouldTrap]);
  (0, import_react6.useEffect)(function() {
    var before = beforeElement.current;
    var after = afterElement.current;
    if (!shouldTrap || !before || !after) return void 0;
    var handleFocus = /* @__PURE__ */ __name(function handleFocus2(event) {
      var dialog = dialogRef.current;
      if (!dialog || visibleModals.length) return;
      event.preventDefault();
      var isAfter = event.target === after;
      var tabbable = isAfter ? getFirstTabbableIn(dialog) : getLastTabbableIn(dialog);
      if (tabbable) {
        tabbable.focus();
      } else {
        dialog.focus();
      }
    }, "handleFocus");
    before.addEventListener("focus", handleFocus);
    after.addEventListener("focus", handleFocus);
    return function() {
      before.removeEventListener("focus", handleFocus);
      after.removeEventListener("focus", handleFocus);
    };
  }, [dialogRef, visibleModals, shouldTrap]);
}
__name(useFocusTrap, "useFocusTrap");
function hidByFocusingAnotherElement(dialogRef) {
  var dialog = dialogRef.current;
  if (!dialog) return false;
  var activeElement = getActiveElement(dialog);
  if (!activeElement) return false;
  if (contains(dialog, activeElement)) return false;
  if (isTabbable(activeElement)) return true;
  if (activeElement.getAttribute("data-dialog") === "true") return true;
  return false;
}
__name(hidByFocusingAnotherElement, "hidByFocusingAnotherElement");
function useFocusOnHide(dialogRef, disclosureRef, options) {
  var shouldFocus = options.unstable_autoFocusOnHide && !options.visible;
  var animating = !!(options.animated && options.animating);
  useUpdateEffect(function() {
    var _options$unstable_fin;
    if (!shouldFocus) return;
    if (animating) return;
    if (hidByFocusingAnotherElement(dialogRef)) {
      return;
    }
    var finalFocusEl = ((_options$unstable_fin = options.unstable_finalFocusRef) === null || _options$unstable_fin === void 0 ? void 0 : _options$unstable_fin.current) || disclosureRef.current;
    if (finalFocusEl) {
      if (finalFocusEl.id) {
        var document2 = getDocument(finalFocusEl);
        var compositeElement = document2.querySelector("[aria-activedescendant='" + finalFocusEl.id + "']");
        if (compositeElement) {
          ensureFocus(compositeElement);
          return;
        }
      }
      ensureFocus(finalFocusEl);
      return;
    }
    true ? warning(true, "Can't return focus after closing dialog. Either render a disclosure component or provide a `unstable_finalFocusRef` prop.", "See https://reakit.io/docs/dialog", dialogRef.current) : void 0;
  }, [shouldFocus, animating, dialogRef, disclosureRef]);
}
__name(useFocusOnHide, "useFocusOnHide");
var DialogContext = (0, import_react6.createContext)({});
function useNestedDialogs(dialogRef, options) {
  var context = (0, import_react6.useContext)(DialogContext);
  var _React$useState = (0, import_react6.useState)([]), dialogs = _React$useState[0], setDialogs = _React$useState[1];
  var _React$useState2 = (0, import_react6.useState)(dialogs), visibleModals = _React$useState2[0], setVisibleModals = _React$useState2[1];
  var addDialog = (0, import_react6.useCallback)(function(ref) {
    var _context$addDialog;
    (_context$addDialog = context.addDialog) === null || _context$addDialog === void 0 ? void 0 : _context$addDialog.call(context, ref);
    setDialogs(function(prevDialogs) {
      return [].concat(prevDialogs, [ref]);
    });
  }, [context.addDialog]);
  var removeDialog = (0, import_react6.useCallback)(function(ref) {
    var _context$removeDialog;
    (_context$removeDialog = context.removeDialog) === null || _context$removeDialog === void 0 ? void 0 : _context$removeDialog.call(context, ref);
    setDialogs(function(prevDialogs) {
      return removeItemFromArray(prevDialogs, ref);
    });
  }, [context.removeDialog]);
  var showDialog = (0, import_react6.useCallback)(function(ref) {
    var _context$showDialog;
    (_context$showDialog = context.showDialog) === null || _context$showDialog === void 0 ? void 0 : _context$showDialog.call(context, ref);
    setVisibleModals(function(prevDialogs) {
      return [].concat(prevDialogs, [ref]);
    });
  }, [context.showDialog]);
  var hideDialog = (0, import_react6.useCallback)(function(ref) {
    var _context$hideDialog;
    (_context$hideDialog = context.hideDialog) === null || _context$hideDialog === void 0 ? void 0 : _context$hideDialog.call(context, ref);
    setVisibleModals(function(prevDialogs) {
      return removeItemFromArray(prevDialogs, ref);
    });
  }, [context.hideDialog]);
  (0, import_react6.useEffect)(function() {
    var _context$addDialog2;
    if (options.unstable_orphan) return void 0;
    (_context$addDialog2 = context.addDialog) === null || _context$addDialog2 === void 0 ? void 0 : _context$addDialog2.call(context, dialogRef);
    return function() {
      var _context$removeDialog2;
      (_context$removeDialog2 = context.removeDialog) === null || _context$removeDialog2 === void 0 ? void 0 : _context$removeDialog2.call(context, dialogRef);
    };
  }, [options.unstable_orphan, context.addDialog, dialogRef, context.removeDialog]);
  (0, import_react6.useEffect)(function() {
    var _context$showDialog2;
    if (options.unstable_orphan) return void 0;
    if (!options.modal) return void 0;
    if (!options.visible) return void 0;
    (_context$showDialog2 = context.showDialog) === null || _context$showDialog2 === void 0 ? void 0 : _context$showDialog2.call(context, dialogRef);
    return function() {
      var _context$hideDialog2;
      (_context$hideDialog2 = context.hideDialog) === null || _context$hideDialog2 === void 0 ? void 0 : _context$hideDialog2.call(context, dialogRef);
    };
  }, [options.unstable_orphan, options.modal, options.visible, context.showDialog, dialogRef, context.hideDialog]);
  (0, import_react6.useEffect)(function() {
    if (context.visible === false && options.visible && !options.unstable_orphan) {
      var _options$hide;
      (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
    }
  }, [context.visible, options.visible, options.hide, options.unstable_orphan]);
  var providerValue = (0, import_react6.useMemo)(function() {
    return {
      visible: options.visible,
      addDialog,
      removeDialog,
      showDialog,
      hideDialog
    };
  }, [options.visible, addDialog, removeDialog, showDialog, hideDialog]);
  var wrap = (0, import_react6.useCallback)(function(element) {
    return (0, import_react6.createElement)(DialogContext.Provider, {
      value: providerValue
    }, element);
  }, [providerValue]);
  return {
    dialogs,
    visibleModals,
    wrap
  };
}
__name(useNestedDialogs, "useNestedDialogs");
function dialogContains(target) {
  return function(dialogRef) {
    var dialog = dialogRef.current;
    if (!dialog) return false;
    if (contains(dialog, target)) return true;
    var document2 = getDocument(dialog);
    var backdrop = document2.querySelector('[data-dialog-ref="' + dialog.id + '"]');
    if (backdrop) {
      return contains(backdrop, target);
    }
    return false;
  };
}
__name(dialogContains, "dialogContains");
function isDisclosure(target, disclosure) {
  return contains(disclosure, target);
}
__name(isDisclosure, "isDisclosure");
function isInDocument(target) {
  var document2 = getDocument(target);
  if (target.tagName === "HTML") {
    return true;
  }
  return contains(document2.body, target);
}
__name(isInDocument, "isInDocument");
function useEventListenerOutside(containerRef, disclosureRef, nestedDialogs, eventType, listener, shouldListen, capture) {
  var listenerRef = useLiveRef(listener);
  (0, import_react6.useEffect)(function() {
    if (!shouldListen) return void 0;
    var onEvent = /* @__PURE__ */ __name(function onEvent2(event) {
      if (!listenerRef.current) return;
      var container = containerRef.current;
      var disclosure = disclosureRef.current;
      var target = event.target;
      if (!container) {
        true ? warning(true, "Can't detect events outside dialog because `ref` wasn't passed to component.", "See https://reakit.io/docs/dialog") : void 0;
        return;
      }
      if (!isInDocument(target)) return;
      if (contains(container, target)) return;
      if (disclosure && isDisclosure(target, disclosure)) return;
      if (isFocusTrap(target) || nestedDialogs.some(dialogContains(target))) {
        return;
      }
      listenerRef.current(event);
    }, "onEvent");
    var document2 = getDocument(containerRef.current);
    document2.addEventListener(eventType, onEvent, capture);
    return function() {
      return document2.removeEventListener(eventType, onEvent, capture);
    };
  }, [containerRef, disclosureRef, nestedDialogs, eventType, shouldListen, listenerRef]);
}
__name(useEventListenerOutside, "useEventListenerOutside");
function useMouseDownRef(dialogRef, options) {
  var mouseDownRef = (0, import_react6.useRef)();
  (0, import_react6.useEffect)(function() {
    if (!options.visible) return void 0;
    if (!options.hideOnClickOutside) return void 0;
    var document2 = getDocument(dialogRef.current);
    var onMouseDown = /* @__PURE__ */ __name(function onMouseDown2(event) {
      mouseDownRef.current = event.target;
    }, "onMouseDown");
    document2.addEventListener("mousedown", onMouseDown);
    return function() {
      return document2.removeEventListener("mousedown", onMouseDown);
    };
  }, [options.visible, options.hideOnClickOutside, dialogRef]);
  return mouseDownRef;
}
__name(useMouseDownRef, "useMouseDownRef");
function useHideOnClickOutside(dialogRef, disclosureRef, nestedDialogs, options) {
  var mouseDownRef = useMouseDownRef(dialogRef, options);
  useEventListenerOutside(dialogRef, disclosureRef, nestedDialogs, "click", function(event) {
    if (mouseDownRef.current === event.target) {
      var _options$hide;
      (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
    }
  }, options.visible && options.hideOnClickOutside);
  useEventListenerOutside(dialogRef, disclosureRef, nestedDialogs, "focusin", function(event) {
    var document2 = getDocument(dialogRef.current);
    if (event.target !== document2 && event.target !== document2.body) {
      var _options$hide2;
      (_options$hide2 = options.hide) === null || _options$hide2 === void 0 ? void 0 : _options$hide2.call(options);
    }
  }, options.visible && options.hideOnClickOutside);
}
__name(useHideOnClickOutside, "useHideOnClickOutside");
function useDisableHoverOutside(portalRef, nestedDialogs, options) {
  var useEvent = /* @__PURE__ */ __name(function useEvent2(eventType) {
    return useEventListenerOutside(portalRef, {
      current: null
    }, nestedDialogs, eventType, function(event) {
      event.stopPropagation();
      event.preventDefault();
    }, options.visible && options.modal, true);
  }, "useEvent");
  useEvent("mouseover");
  useEvent("mousemove");
  useEvent("mouseout");
}
__name(useDisableHoverOutside, "useDisableHoverOutside");
function useFocusOnChildUnmount(dialogRef, options) {
  (0, import_react6.useEffect)(function() {
    var dialog = dialogRef.current;
    if (!options.visible || !dialog) return void 0;
    var observer = new MutationObserver(function(mutations) {
      var target = mutations[0].target;
      if (target !== dialog) return;
      var document2 = getDocument(dialog);
      var activeElement = getActiveElement(dialog);
      if (activeElement === document2.body || isEmpty(activeElement)) {
        dialog.focus();
      }
    });
    observer.observe(dialog, {
      childList: true,
      subtree: true
    });
    return function() {
      observer.disconnect();
    };
  }, [options.visible, dialogRef]);
}
__name(useFocusOnChildUnmount, "useFocusOnChildUnmount");
function isActualElement(element) {
  return element && element.tagName && element.tagName !== "HTML" && element !== getDocument(element).body;
}
__name(isActualElement, "isActualElement");
function useFocusOnBlur(dialogRef, options) {
  var _React$useReducer = (0, import_react6.useReducer)(function(n) {
    return n + 1;
  }, 0), blurred = _React$useReducer[0], scheduleFocus = _React$useReducer[1];
  useIsomorphicEffect(function() {
    var dialog = dialogRef.current;
    if (!options.visible) return;
    if (!blurred) return;
    if (!isActualElement(getActiveElement(dialog))) {
      true ? warning(!dialog, "Can't focus dialog after a nested element got blurred because `ref` wasn't passed to the component", "See https://reakit.io/docs/dialog") : void 0;
      dialog === null || dialog === void 0 ? void 0 : dialog.focus();
    }
  }, [blurred, dialogRef]);
  var onBlur = (0, import_react6.useCallback)(function(event) {
    if (!options.visible) return;
    var nextActiveElement = getNextActiveElementOnBlur(event);
    if (!isActualElement(nextActiveElement)) {
      scheduleFocus();
    }
  }, [options.visible]);
  return onBlur;
}
__name(useFocusOnBlur, "useFocusOnBlur");
var useDialog = createHook({
  name: "Dialog",
  compose: useDisclosureContent,
  keys: DIALOG_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions(_ref) {
    var _ref$modal = _ref.modal, modal = _ref$modal === void 0 ? true : _ref$modal, _ref$hideOnEsc = _ref.hideOnEsc, hideOnEsc = _ref$hideOnEsc === void 0 ? true : _ref$hideOnEsc, _ref$hideOnClickOutsi = _ref.hideOnClickOutside, hideOnClickOutside = _ref$hideOnClickOutsi === void 0 ? true : _ref$hideOnClickOutsi, _ref$preventBodyScrol = _ref.preventBodyScroll, preventBodyScroll = _ref$preventBodyScrol === void 0 ? modal : _ref$preventBodyScrol, _ref$unstable_autoFoc = _ref.unstable_autoFocusOnShow, unstable_autoFocusOnShow = _ref$unstable_autoFoc === void 0 ? true : _ref$unstable_autoFoc, _ref$unstable_autoFoc2 = _ref.unstable_autoFocusOnHide, unstable_autoFocusOnHide = _ref$unstable_autoFoc2 === void 0 ? true : _ref$unstable_autoFoc2, unstable_orphan = _ref.unstable_orphan, options = _objectWithoutPropertiesLoose(_ref, ["modal", "hideOnEsc", "hideOnClickOutside", "preventBodyScroll", "unstable_autoFocusOnShow", "unstable_autoFocusOnHide", "unstable_orphan"]);
    return _objectSpread2({
      modal,
      hideOnEsc,
      hideOnClickOutside,
      preventBodyScroll: modal && preventBodyScroll,
      unstable_autoFocusOnShow,
      unstable_autoFocusOnHide,
      unstable_orphan: modal && unstable_orphan
    }, options);
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps(options, _ref2) {
    var htmlRef = _ref2.ref, htmlOnKeyDown = _ref2.onKeyDown, htmlOnBlur = _ref2.onBlur, htmlWrapElement = _ref2.wrapElement, tabIndex = _ref2.tabIndex, htmlProps = _objectWithoutPropertiesLoose(_ref2, ["ref", "onKeyDown", "onBlur", "wrapElement", "tabIndex"]);
    var dialog = (0, import_react6.useRef)(null);
    var backdrop = (0, import_react6.useContext)(DialogBackdropContext);
    var hasBackdrop = backdrop && backdrop === options.baseId;
    var disclosure = useDisclosureRef(dialog, options);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onBlurRef = useLiveRef(htmlOnBlur);
    var focusOnBlur = useFocusOnBlur(dialog, options);
    var _useNestedDialogs = useNestedDialogs(dialog, options), dialogs = _useNestedDialogs.dialogs, visibleModals = _useNestedDialogs.visibleModals, wrap = _useNestedDialogs.wrap;
    var modal = options.modal && !visibleModals.length ? true : void 0;
    usePreventBodyScroll(dialog, options);
    useFocusTrap(dialog, visibleModals, options);
    useFocusOnChildUnmount(dialog, options);
    useFocusOnShow(dialog, dialogs, options);
    useFocusOnHide(dialog, disclosure, options);
    useHideOnClickOutside(dialog, disclosure, dialogs, options);
    useDisableHoverOutside(dialog, dialogs, options);
    var onKeyDown = (0, import_react6.useCallback)(function(event) {
      var _onKeyDownRef$current;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented) return;
      if (event.key !== "Escape") return;
      if (!options.hideOnEsc) return;
      if (!options.hide) {
        true ? warning(true, "`hideOnEsc` prop is truthy, but `hide` prop wasn't provided.", "See https://reakit.io/docs/dialog", dialog.current) : void 0;
        return;
      }
      event.stopPropagation();
      options.hide();
    }, [options.hideOnEsc, options.hide]);
    var onBlur = (0, import_react6.useCallback)(function(event) {
      var _onBlurRef$current;
      (_onBlurRef$current = onBlurRef.current) === null || _onBlurRef$current === void 0 ? void 0 : _onBlurRef$current.call(onBlurRef, event);
      focusOnBlur(event);
    }, [focusOnBlur]);
    var wrapElement = (0, import_react6.useCallback)(function(element) {
      element = wrap(element);
      if (options.modal && !hasBackdrop) {
        element = (0, import_react6.createElement)(Portal, null, element);
      }
      if (htmlWrapElement) {
        element = htmlWrapElement(element);
      }
      return (
        // Prevents Menu > Dialog > Menu to behave as a sub menu
        (0, import_react6.createElement)(MenuContext.Provider, {
          value: null
        }, element)
      );
    }, [wrap, options.modal, hasBackdrop, htmlWrapElement]);
    return _objectSpread2({
      ref: useForkRef(dialog, htmlRef),
      role: "dialog",
      tabIndex: tabIndex != null ? tabIndex : -1,
      "aria-modal": modal,
      "data-dialog": true,
      onKeyDown,
      onBlur,
      wrapElement
    }, htmlProps);
  }, "useProps")
});
var Dialog = createComponent({
  as: "div",
  useHook: useDialog,
  useCreateElement: /* @__PURE__ */ __name(function useCreateElement$1(type, props, children) {
    true ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/dialog") : void 0;
    return useCreateElement(type, props, children);
  }, "useCreateElement$1")
});

// node_modules/reakit/es/Dialog/DialogDisclosure.js
var import_react7 = __toESM(require_react());
var useDialogDisclosure = createHook({
  name: "DialogDisclosure",
  compose: useDisclosure,
  keys: DIALOG_DISCLOSURE_KEYS,
  useProps: /* @__PURE__ */ __name(function useProps2(options, _ref) {
    var htmlRef = _ref.ref, htmlOnClick = _ref.onClick, htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "onClick"]);
    var ref = (0, import_react7.useRef)(null);
    var onClickRef = useLiveRef(htmlOnClick);
    var _React$useState = (0, import_react7.useState)(false), expanded = _React$useState[0], setExpanded = _React$useState[1];
    var disclosureRef = options.unstable_disclosureRef;
    useIsomorphicEffect(function() {
      var element = ref.current;
      true ? warning(!element, "Can't determine whether the element is the current disclosure because `ref` wasn't passed to the component", "See https://reakit.io/docs/dialog") : void 0;
      if (disclosureRef && !disclosureRef.current) {
        disclosureRef.current = element;
      }
      var isCurrentDisclosure = !(disclosureRef !== null && disclosureRef !== void 0 && disclosureRef.current) || disclosureRef.current === element;
      setExpanded(!!options.visible && isCurrentDisclosure);
    }, [options.visible, disclosureRef]);
    var onClick = (0, import_react7.useCallback)(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented) return;
      if (disclosureRef) {
        disclosureRef.current = event.currentTarget;
      }
    }, [disclosureRef]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      "aria-haspopup": "dialog",
      "aria-expanded": expanded,
      onClick
    }, htmlProps);
  }, "useProps")
});
var DialogDisclosure = createComponent({
  as: "button",
  memo: true,
  useHook: useDialogDisclosure
});

export {
  removeIndexFromArray,
  useUpdateEffect,
  getNextActiveElementOnBlur,
  ensureFocus,
  useDialogState,
  PortalContext,
  Portal,
  removeItemFromArray,
  MenuContext,
  useMenuContext,
  DialogBackdropContext,
  isEmpty,
  DIALOG_BACKDROP_KEYS,
  useDialog,
  Dialog,
  useDialogDisclosure,
  DialogDisclosure
};
//# sourceMappingURL=chunk-NVIKVDCQ.js.map
