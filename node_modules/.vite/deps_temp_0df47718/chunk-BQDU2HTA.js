import {
  _createForOfIteratorHelperLoose2 as _createForOfIteratorHelperLoose,
  _objectSpread2,
  _objectWithoutPropertiesLoose,
  createComponent,
  createHook,
  isObject,
  useRole
} from "./chunk-EDJXIEOR.js";
import {
  require_react
} from "./chunk-NSZELEHI.js";
import {
  __name,
  __toESM
} from "./chunk-4OCRLPSA.js";

// node_modules/reakit-utils/es/useForkRef.js
var import_react = __toESM(require_react());
function setRef(ref, value) {
  if (value === void 0) {
    value = null;
  }
  if (!ref) return;
  if (typeof ref === "function") {
    ref(value);
  } else {
    ref.current = value;
  }
}
__name(setRef, "setRef");
function useForkRef(refA, refB) {
  return (0, import_react.useMemo)(function() {
    if (refA == null && refB == null) {
      return null;
    }
    return function(value) {
      setRef(refA, value);
      setRef(refB, value);
    };
  }, [refA, refB]);
}
__name(useForkRef, "useForkRef");

// node_modules/reakit-utils/es/isButton.js
var buttonInputTypes = ["button", "color", "file", "image", "reset", "submit"];
function isButton(element) {
  if (element.tagName === "BUTTON") return true;
  if (element.tagName === "INPUT") {
    var input = element;
    return buttonInputTypes.indexOf(input.type) !== -1;
  }
  return false;
}
__name(isButton, "isButton");

// node_modules/reakit-utils/es/flatten.js
function flatten(array) {
  var flat = [];
  for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done; ) {
    var maybeArray = _step.value;
    if (Array.isArray(maybeArray)) {
      flat.push.apply(flat, flatten(maybeArray));
    } else {
      flat.push(maybeArray);
    }
  }
  return flat;
}
__name(flatten, "flatten");

// node_modules/reakit-warning/es/warning.js
function warning(condition) {
  if (true) {
    var _console;
    if (!condition) return;
    for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      messages[_key - 1] = arguments[_key];
    }
    var warns = flatten(messages.map(function(message) {
      return [message, "\n"];
    }));
    (_console = console).warn.apply(_console, warns.slice(0, -1));
    try {
      throw Error(warns.join(""));
    } catch (x) {
    }
  }
}
__name(warning, "warning");

// node_modules/reakit-warning/es/index.js
var import_react3 = __toESM(require_react());

// node_modules/reakit-warning/es/useWarning.js
var import_react2 = __toESM(require_react());
function isRefObject(ref) {
  return isObject(ref) && "current" in ref;
}
__name(isRefObject, "isRefObject");
function useWarning(condition) {
  for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    messages[_key - 1] = arguments[_key];
  }
  if (true) {
    (0, import_react2.useEffect)(function() {
      true ? warning.apply(void 0, [condition].concat(messages.map(function(message) {
        return isRefObject(message) ? message.current : message;
      }))) : void 0;
    }, [condition]);
  }
}
__name(useWarning, "useWarning");

// node_modules/reakit-utils/es/getDocument.js
function getDocument(element) {
  return element ? element.ownerDocument || element : document;
}
__name(getDocument, "getDocument");

// node_modules/reakit-utils/es/getWindow.js
var _window;
try {
  _window = window;
} catch (e) {
}
function getWindow(element) {
  if (!element) {
    return _window;
  }
  return getDocument(element).defaultView || _window;
}
__name(getWindow, "getWindow");

// node_modules/reakit-utils/es/canUseDOM.js
function checkIsBrowser() {
  var _window2 = getWindow();
  return Boolean(typeof _window2 !== "undefined" && _window2.document && _window2.document.createElement);
}
__name(checkIsBrowser, "checkIsBrowser");
var canUseDOM = checkIsBrowser();

// node_modules/reakit-utils/es/useIsomorphicEffect.js
var import_react4 = __toESM(require_react());
var useIsomorphicEffect = !canUseDOM ? import_react4.useEffect : import_react4.useLayoutEffect;

// node_modules/reakit-utils/es/useLiveRef.js
var import_react5 = __toESM(require_react());
function useLiveRef(value) {
  var ref = (0, import_react5.useRef)(value);
  useIsomorphicEffect(function() {
    ref.current = value;
  });
  return ref;
}
__name(useLiveRef, "useLiveRef");

// node_modules/reakit-utils/es/isSelfTarget.js
function isSelfTarget(event) {
  return event.target === event.currentTarget;
}
__name(isSelfTarget, "isSelfTarget");

// node_modules/reakit-utils/es/getActiveElement.js
function getActiveElement(element) {
  var _getDocument = getDocument(element), activeElement = _getDocument.activeElement;
  if (!(activeElement !== null && activeElement !== void 0 && activeElement.nodeName)) {
    return null;
  }
  return activeElement;
}
__name(getActiveElement, "getActiveElement");

// node_modules/reakit-utils/es/contains.js
function contains(parent, child) {
  return parent === child || parent.contains(child);
}
__name(contains, "contains");

// node_modules/reakit-utils/es/hasFocusWithin.js
function hasFocusWithin(element) {
  var activeElement = getActiveElement(element);
  if (!activeElement) return false;
  if (contains(element, activeElement)) return true;
  var activeDescendant = activeElement.getAttribute("aria-activedescendant");
  if (!activeDescendant) return false;
  if (activeDescendant === element.id) return true;
  return !!element.querySelector("#" + activeDescendant);
}
__name(hasFocusWithin, "hasFocusWithin");

// node_modules/reakit-utils/es/isPortalEvent.js
function isPortalEvent(event) {
  return !contains(event.currentTarget, event.target);
}
__name(isPortalEvent, "isPortalEvent");

// node_modules/reakit-utils/es/dom.js
function isUA(string) {
  if (!canUseDOM) return false;
  return window.navigator.userAgent.indexOf(string) !== -1;
}
__name(isUA, "isUA");

// node_modules/reakit-utils/es/matches.js
function matches(element, selectors) {
  if ("matches" in element) {
    return element.matches(selectors);
  }
  if ("msMatchesSelector" in element) {
    return element.msMatchesSelector(selectors);
  }
  return element.webkitMatchesSelector(selectors);
}
__name(matches, "matches");

// node_modules/reakit-utils/es/closest.js
function closest(element, selectors) {
  if ("closest" in element) return element.closest(selectors);
  do {
    if (matches(element, selectors)) return element;
    element = element.parentElement || element.parentNode;
  } while (element !== null && element.nodeType === 1);
  return null;
}
__name(closest, "closest");

// node_modules/reakit-utils/es/tabbable.js
var selector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])";
function isVisible(element) {
  var htmlElement = element;
  return htmlElement.offsetWidth > 0 || htmlElement.offsetHeight > 0 || element.getClientRects().length > 0;
}
__name(isVisible, "isVisible");
function hasNegativeTabIndex(element) {
  var tabIndex = parseInt(element.getAttribute("tabindex") || "0", 10);
  return tabIndex < 0;
}
__name(hasNegativeTabIndex, "hasNegativeTabIndex");
function isFocusable(element) {
  return matches(element, selector) && isVisible(element);
}
__name(isFocusable, "isFocusable");
function isTabbable(element) {
  return isFocusable(element) && !hasNegativeTabIndex(element);
}
__name(isTabbable, "isTabbable");
function getAllTabbableIn(container, fallbackToFocusable) {
  var allFocusable = Array.from(container.querySelectorAll(selector));
  var allTabbable = allFocusable.filter(isTabbable);
  if (isTabbable(container)) {
    allTabbable.unshift(container);
  }
  if (!allTabbable.length && fallbackToFocusable) {
    return allFocusable;
  }
  return allTabbable;
}
__name(getAllTabbableIn, "getAllTabbableIn");
function getFirstTabbableIn(container, fallbackToFocusable) {
  var _getAllTabbableIn = getAllTabbableIn(container, fallbackToFocusable), first = _getAllTabbableIn[0];
  return first || null;
}
__name(getFirstTabbableIn, "getFirstTabbableIn");
function getLastTabbableIn(container, fallbackToFocusable) {
  var allTabbable = getAllTabbableIn(container, fallbackToFocusable);
  return allTabbable[allTabbable.length - 1] || null;
}
__name(getLastTabbableIn, "getLastTabbableIn");

// node_modules/reakit/es/Tabbable/Tabbable.js
var import_react6 = __toESM(require_react());
var TABBABLE_KEYS = ["disabled", "focusable"];
var isSafariOrFirefoxOnMac = isUA("Mac") && !isUA("Chrome") && (isUA("Safari") || isUA("Firefox"));
function focusIfNeeded(element) {
  if (!hasFocusWithin(element) && isFocusable(element)) {
    element.focus();
  }
}
__name(focusIfNeeded, "focusIfNeeded");
function isNativeTabbable(element) {
  return ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"].includes(element.tagName);
}
__name(isNativeTabbable, "isNativeTabbable");
function supportsDisabledAttribute(element) {
  return ["BUTTON", "INPUT", "SELECT", "TEXTAREA"].includes(element.tagName);
}
__name(supportsDisabledAttribute, "supportsDisabledAttribute");
function getTabIndex(trulyDisabled, nativeTabbable, supportsDisabled, htmlTabIndex) {
  if (trulyDisabled) {
    if (nativeTabbable && !supportsDisabled) {
      return -1;
    }
    return void 0;
  }
  if (nativeTabbable) {
    return htmlTabIndex;
  }
  return htmlTabIndex || 0;
}
__name(getTabIndex, "getTabIndex");
function useDisableEvent(htmlEventRef, disabled) {
  return (0, import_react6.useCallback)(function(event) {
    var _htmlEventRef$current;
    (_htmlEventRef$current = htmlEventRef.current) === null || _htmlEventRef$current === void 0 ? void 0 : _htmlEventRef$current.call(htmlEventRef, event);
    if (event.defaultPrevented) return;
    if (disabled) {
      event.stopPropagation();
      event.preventDefault();
    }
  }, [htmlEventRef, disabled]);
}
__name(useDisableEvent, "useDisableEvent");
var useTabbable = createHook({
  name: "Tabbable",
  compose: useRole,
  keys: TABBABLE_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions(options, _ref) {
    var disabled = _ref.disabled;
    return _objectSpread2({
      disabled
    }, options);
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps(options, _ref2) {
    var htmlRef = _ref2.ref, htmlTabIndex = _ref2.tabIndex, htmlOnClickCapture = _ref2.onClickCapture, htmlOnMouseDownCapture = _ref2.onMouseDownCapture, htmlOnMouseDown = _ref2.onMouseDown, htmlOnKeyPressCapture = _ref2.onKeyPressCapture, htmlStyle = _ref2.style, htmlProps = _objectWithoutPropertiesLoose(_ref2, ["ref", "tabIndex", "onClickCapture", "onMouseDownCapture", "onMouseDown", "onKeyPressCapture", "style"]);
    var ref = (0, import_react6.useRef)(null);
    var onClickCaptureRef = useLiveRef(htmlOnClickCapture);
    var onMouseDownCaptureRef = useLiveRef(htmlOnMouseDownCapture);
    var onMouseDownRef = useLiveRef(htmlOnMouseDown);
    var onKeyPressCaptureRef = useLiveRef(htmlOnKeyPressCapture);
    var trulyDisabled = !!options.disabled && !options.focusable;
    var _React$useState = (0, import_react6.useState)(true), nativeTabbable = _React$useState[0], setNativeTabbable = _React$useState[1];
    var _React$useState2 = (0, import_react6.useState)(true), supportsDisabled = _React$useState2[0], setSupportsDisabled = _React$useState2[1];
    var style = options.disabled ? _objectSpread2({
      pointerEvents: "none"
    }, htmlStyle) : htmlStyle;
    useIsomorphicEffect(function() {
      var tabbable = ref.current;
      if (!tabbable) {
        true ? warning(true, "Can't determine if the element is a native tabbable element because `ref` wasn't passed to the component.", "See https://reakit.io/docs/tabbable") : void 0;
        return;
      }
      if (!isNativeTabbable(tabbable)) {
        setNativeTabbable(false);
      }
      if (!supportsDisabledAttribute(tabbable)) {
        setSupportsDisabled(false);
      }
    }, []);
    var onClickCapture = useDisableEvent(onClickCaptureRef, options.disabled);
    var onMouseDownCapture = useDisableEvent(onMouseDownCaptureRef, options.disabled);
    var onKeyPressCapture = useDisableEvent(onKeyPressCaptureRef, options.disabled);
    var onMouseDown = (0, import_react6.useCallback)(function(event) {
      var _onMouseDownRef$curre;
      (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
      var element = event.currentTarget;
      if (event.defaultPrevented) return;
      if (!isSafariOrFirefoxOnMac) return;
      if (isPortalEvent(event)) return;
      if (!isButton(element)) return;
      var raf = requestAnimationFrame(function() {
        element.removeEventListener("mouseup", focusImmediately, true);
        focusIfNeeded(element);
      });
      var focusImmediately = /* @__PURE__ */ __name(function focusImmediately2() {
        cancelAnimationFrame(raf);
        focusIfNeeded(element);
      }, "focusImmediately");
      element.addEventListener("mouseup", focusImmediately, {
        once: true,
        capture: true
      });
    }, []);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      style,
      tabIndex: getTabIndex(trulyDisabled, nativeTabbable, supportsDisabled, htmlTabIndex),
      disabled: trulyDisabled && supportsDisabled ? true : void 0,
      "aria-disabled": options.disabled ? true : void 0,
      onClickCapture,
      onMouseDownCapture,
      onMouseDown,
      onKeyPressCapture
    }, htmlProps);
  }, "useProps")
});
var Tabbable = createComponent({
  as: "div",
  useHook: useTabbable
});

// node_modules/reakit/es/Clickable/Clickable.js
var import_react7 = __toESM(require_react());
var CLICKABLE_KEYS = ["unstable_clickOnEnter", "unstable_clickOnSpace"];
function isNativeClick(event) {
  var element = event.currentTarget;
  if (!event.isTrusted) return false;
  return isButton(element) || element.tagName === "INPUT" || element.tagName === "TEXTAREA" || element.tagName === "A" || element.tagName === "SELECT";
}
__name(isNativeClick, "isNativeClick");
var useClickable = createHook({
  name: "Clickable",
  compose: useTabbable,
  keys: CLICKABLE_KEYS,
  useOptions: /* @__PURE__ */ __name(function useOptions2(_ref) {
    var _ref$unstable_clickOn = _ref.unstable_clickOnEnter, unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? true : _ref$unstable_clickOn, _ref$unstable_clickOn2 = _ref.unstable_clickOnSpace, unstable_clickOnSpace = _ref$unstable_clickOn2 === void 0 ? true : _ref$unstable_clickOn2, options = _objectWithoutPropertiesLoose(_ref, ["unstable_clickOnEnter", "unstable_clickOnSpace"]);
    return _objectSpread2({
      unstable_clickOnEnter,
      unstable_clickOnSpace
    }, options);
  }, "useOptions"),
  useProps: /* @__PURE__ */ __name(function useProps2(options, _ref2) {
    var htmlOnKeyDown = _ref2.onKeyDown, htmlOnKeyUp = _ref2.onKeyUp, htmlProps = _objectWithoutPropertiesLoose(_ref2, ["onKeyDown", "onKeyUp"]);
    var _React$useState = (0, import_react7.useState)(false), active = _React$useState[0], setActive = _React$useState[1];
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onKeyUpRef = useLiveRef(htmlOnKeyUp);
    var onKeyDown = (0, import_react7.useCallback)(function(event) {
      var _onKeyDownRef$current;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented) return;
      if (options.disabled) return;
      if (event.metaKey) return;
      if (!isSelfTarget(event)) return;
      var isEnter = options.unstable_clickOnEnter && event.key === "Enter";
      var isSpace = options.unstable_clickOnSpace && event.key === " ";
      if (isEnter || isSpace) {
        if (isNativeClick(event)) return;
        event.preventDefault();
        if (isEnter) {
          event.currentTarget.click();
        } else if (isSpace) {
          setActive(true);
        }
      }
    }, [options.disabled, options.unstable_clickOnEnter, options.unstable_clickOnSpace]);
    var onKeyUp = (0, import_react7.useCallback)(function(event) {
      var _onKeyUpRef$current;
      (_onKeyUpRef$current = onKeyUpRef.current) === null || _onKeyUpRef$current === void 0 ? void 0 : _onKeyUpRef$current.call(onKeyUpRef, event);
      if (event.defaultPrevented) return;
      if (options.disabled) return;
      if (event.metaKey) return;
      var isSpace = options.unstable_clickOnSpace && event.key === " ";
      if (active && isSpace) {
        setActive(false);
        event.currentTarget.click();
      }
    }, [options.disabled, options.unstable_clickOnSpace, active]);
    return _objectSpread2({
      "data-active": active || void 0,
      onKeyDown,
      onKeyUp
    }, htmlProps);
  }, "useProps")
});
var Clickable = createComponent({
  as: "button",
  memo: true,
  useHook: useClickable
});

// node_modules/reakit/es/Button/Button.js
var import_react8 = __toESM(require_react());
var BUTTON_KEYS = [];
var useButton = createHook({
  name: "Button",
  compose: useClickable,
  keys: BUTTON_KEYS,
  useProps: /* @__PURE__ */ __name(function useProps3(_, _ref) {
    var htmlRef = _ref.ref, htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref"]);
    var ref = (0, import_react8.useRef)(null);
    var _React$useState = (0, import_react8.useState)(void 0), role = _React$useState[0], setRole = _React$useState[1];
    var _React$useState2 = (0, import_react8.useState)("button"), type = _React$useState2[0], setType = _React$useState2[1];
    (0, import_react8.useEffect)(function() {
      var element = ref.current;
      if (!element) {
        true ? warning(true, "Can't determine whether the element is a native button because `ref` wasn't passed to the component", "See https://reakit.io/docs/button") : void 0;
        return;
      }
      if (!isButton(element)) {
        if (element.tagName !== "A") {
          setRole("button");
        }
        setType(void 0);
      }
    }, []);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      role,
      type
    }, htmlProps);
  }, "useProps")
});
var Button = createComponent({
  as: "button",
  memo: true,
  useHook: useButton
});

// node_modules/reakit-utils/es/useSealedState.js
var import_react9 = __toESM(require_react());
function useSealedState(initialState) {
  var _React$useState = (0, import_react9.useState)(initialState), sealed = _React$useState[0];
  return sealed;
}
__name(useSealedState, "useSealedState");

// node_modules/reakit/es/Id/IdProvider.js
var import_react10 = __toESM(require_react());
var defaultPrefix = "id";
function generateRandomString(prefix) {
  if (prefix === void 0) {
    prefix = defaultPrefix;
  }
  return (prefix ? prefix + "-" : "") + Math.random().toString(32).substr(2, 6);
}
__name(generateRandomString, "generateRandomString");
var unstable_IdContext = (0, import_react10.createContext)(generateRandomString);
function unstable_IdProvider(_ref) {
  var children = _ref.children, _ref$prefix = _ref.prefix, prefix = _ref$prefix === void 0 ? defaultPrefix : _ref$prefix;
  var count = (0, import_react10.useRef)(0);
  var generateId = (0, import_react10.useCallback)(function(localPrefix) {
    if (localPrefix === void 0) {
      localPrefix = prefix;
    }
    return (localPrefix ? localPrefix + "-" : "") + ++count.current;
  }, [prefix]);
  return (0, import_react10.createElement)(unstable_IdContext.Provider, {
    value: generateId
  }, children);
}
__name(unstable_IdProvider, "unstable_IdProvider");

// node_modules/reakit/es/Id/IdState.js
var import_react11 = __toESM(require_react());
function unstable_useIdState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  var _useSealedState = useSealedState(initialState), initialBaseId = _useSealedState.baseId;
  var generateId = (0, import_react11.useContext)(unstable_IdContext);
  var idCountRef = (0, import_react11.useRef)(0);
  var _React$useState = (0, import_react11.useState)(function() {
    return initialBaseId || generateId();
  }), baseId = _React$useState[0], setBaseId = _React$useState[1];
  return {
    baseId,
    setBaseId,
    unstable_idCountRef: idCountRef
  };
}
__name(unstable_useIdState, "unstable_useIdState");

// node_modules/reakit/es/Disclosure/DisclosureState.js
var import_react12 = __toESM(require_react());
function useLastValue(value) {
  var lastValue = (0, import_react12.useRef)(null);
  useIsomorphicEffect(function() {
    lastValue.current = value;
  }, [value]);
  return lastValue;
}
__name(useLastValue, "useLastValue");
function useDisclosureState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  var _useSealedState = useSealedState(initialState), _useSealedState$visib = _useSealedState.visible, initialVisible = _useSealedState$visib === void 0 ? false : _useSealedState$visib, _useSealedState$anima = _useSealedState.animated, initialAnimated = _useSealedState$anima === void 0 ? false : _useSealedState$anima, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["visible", "animated"]);
  var id = unstable_useIdState(sealed);
  var _React$useState = (0, import_react12.useState)(initialVisible), visible = _React$useState[0], setVisible = _React$useState[1];
  var _React$useState2 = (0, import_react12.useState)(initialAnimated), animated = _React$useState2[0], setAnimated = _React$useState2[1];
  var _React$useState3 = (0, import_react12.useState)(false), animating = _React$useState3[0], setAnimating = _React$useState3[1];
  var lastVisible = useLastValue(visible);
  var visibleHasChanged = lastVisible.current != null && lastVisible.current !== visible;
  if (animated && !animating && visibleHasChanged) {
    setAnimating(true);
  }
  (0, import_react12.useEffect)(function() {
    if (typeof animated === "number" && animating) {
      var timeout = setTimeout(function() {
        return setAnimating(false);
      }, animated);
      return function() {
        clearTimeout(timeout);
      };
    }
    if (animated && animating && true) {
      var _timeout = setTimeout(function() {
        true ? warning(animating, "It's been 8 seconds but stopAnimation has not been called. Does the disclousure element have a CSS transition?") : void 0;
      }, 8e3);
      return function() {
        clearTimeout(_timeout);
      };
    }
    return function() {
    };
  }, [animated, animating]);
  var show = (0, import_react12.useCallback)(function() {
    return setVisible(true);
  }, []);
  var hide = (0, import_react12.useCallback)(function() {
    return setVisible(false);
  }, []);
  var toggle = (0, import_react12.useCallback)(function() {
    return setVisible(function(v) {
      return !v;
    });
  }, []);
  var stopAnimation = (0, import_react12.useCallback)(function() {
    return setAnimating(false);
  }, []);
  return _objectSpread2(_objectSpread2({}, id), {}, {
    visible,
    animated,
    animating,
    show,
    hide,
    toggle,
    setVisible,
    setAnimated,
    stopAnimation
  });
}
__name(useDisclosureState, "useDisclosureState");

// node_modules/reakit/es/__keys-e6a5cfbe.js
var DISCLOSURE_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation"];
var DISCLOSURE_KEYS = DISCLOSURE_STATE_KEYS;
var DISCLOSURE_CONTENT_KEYS = DISCLOSURE_KEYS;

// node_modules/reakit/es/Disclosure/DisclosureContent.js
var import_react13 = __toESM(require_react());
var useDisclosureContent = createHook({
  name: "DisclosureContent",
  compose: useRole,
  keys: DISCLOSURE_CONTENT_KEYS,
  useProps: /* @__PURE__ */ __name(function useProps4(options, _ref) {
    var htmlOnTransitionEnd = _ref.onTransitionEnd, htmlOnAnimationEnd = _ref.onAnimationEnd, htmlStyle = _ref.style, htmlProps = _objectWithoutPropertiesLoose(_ref, ["onTransitionEnd", "onAnimationEnd", "style"]);
    var animating = options.animated && options.animating;
    var _React$useState = (0, import_react13.useState)(null), transition = _React$useState[0], setTransition = _React$useState[1];
    var hidden = !options.visible && !animating;
    var style = hidden ? _objectSpread2({
      display: "none"
    }, htmlStyle) : htmlStyle;
    var onTransitionEndRef = useLiveRef(htmlOnTransitionEnd);
    var onAnimationEndRef = useLiveRef(htmlOnAnimationEnd);
    var raf = (0, import_react13.useRef)(0);
    (0, import_react13.useEffect)(function() {
      if (!options.animated) return void 0;
      raf.current = window.requestAnimationFrame(function() {
        raf.current = window.requestAnimationFrame(function() {
          if (options.visible) {
            setTransition("enter");
          } else if (animating) {
            setTransition("leave");
          } else {
            setTransition(null);
          }
        });
      });
      return function() {
        return window.cancelAnimationFrame(raf.current);
      };
    }, [options.animated, options.visible, animating]);
    var onEnd = (0, import_react13.useCallback)(function(event) {
      if (!isSelfTarget(event)) return;
      if (!animating) return;
      if (options.animated === true) {
        var _options$stopAnimatio;
        (_options$stopAnimatio = options.stopAnimation) === null || _options$stopAnimatio === void 0 ? void 0 : _options$stopAnimatio.call(options);
      }
    }, [options.animated, animating, options.stopAnimation]);
    var onTransitionEnd = (0, import_react13.useCallback)(function(event) {
      var _onTransitionEndRef$c;
      (_onTransitionEndRef$c = onTransitionEndRef.current) === null || _onTransitionEndRef$c === void 0 ? void 0 : _onTransitionEndRef$c.call(onTransitionEndRef, event);
      onEnd(event);
    }, [onEnd]);
    var onAnimationEnd = (0, import_react13.useCallback)(function(event) {
      var _onAnimationEndRef$cu;
      (_onAnimationEndRef$cu = onAnimationEndRef.current) === null || _onAnimationEndRef$cu === void 0 ? void 0 : _onAnimationEndRef$cu.call(onAnimationEndRef, event);
      onEnd(event);
    }, [onEnd]);
    return _objectSpread2({
      id: options.baseId,
      "data-enter": transition === "enter" ? "" : void 0,
      "data-leave": transition === "leave" ? "" : void 0,
      onTransitionEnd,
      onAnimationEnd,
      hidden,
      style
    }, htmlProps);
  }, "useProps")
});
var DisclosureContent = createComponent({
  as: "div",
  useHook: useDisclosureContent
});

// node_modules/reakit/es/Disclosure/Disclosure.js
var import_react14 = __toESM(require_react());
var useDisclosure = createHook({
  name: "Disclosure",
  compose: useButton,
  keys: DISCLOSURE_KEYS,
  useProps: /* @__PURE__ */ __name(function useProps5(options, _ref) {
    var htmlOnClick = _ref.onClick, ariaControls = _ref["aria-controls"], htmlProps = _objectWithoutPropertiesLoose(_ref, ["onClick", "aria-controls"]);
    var onClickRef = useLiveRef(htmlOnClick);
    var controls = ariaControls ? ariaControls + " " + options.baseId : options.baseId;
    var onClick = (0, import_react14.useCallback)(function(event) {
      var _onClickRef$current, _options$toggle;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented) return;
      (_options$toggle = options.toggle) === null || _options$toggle === void 0 ? void 0 : _options$toggle.call(options);
    }, [options.toggle]);
    return _objectSpread2({
      "aria-expanded": !!options.visible,
      "aria-controls": controls,
      onClick
    }, htmlProps);
  }, "useProps")
});
var Disclosure = createComponent({
  as: "button",
  memo: true,
  useHook: useDisclosure
});

export {
  useForkRef,
  isButton,
  warning,
  useWarning,
  getDocument,
  getWindow,
  canUseDOM,
  useIsomorphicEffect,
  useLiveRef,
  isSelfTarget,
  getActiveElement,
  contains,
  hasFocusWithin,
  isPortalEvent,
  isUA,
  closest,
  isTabbable,
  getFirstTabbableIn,
  getLastTabbableIn,
  useTabbable,
  Tabbable,
  useClickable,
  Clickable,
  useButton,
  Button,
  useSealedState,
  unstable_IdContext,
  unstable_IdProvider,
  unstable_useIdState,
  useDisclosureState,
  useDisclosureContent,
  DisclosureContent,
  useDisclosure,
  Disclosure
};
//# sourceMappingURL=chunk-BQDU2HTA.js.map
