{
  "version": 3,
  "sources": ["../../command-score/index.js"],
  "sourcesContent": ["// The scores are arranged so that a continuous match of characters will\n// result in a total score of 1.\n//\n// The best case, this character is a match, and either this is the start\n// of the string, or the previous character was also a match.\nvar SCORE_CONTINUE_MATCH = 1,\n\n    // A new match at the start of a word scores better than a new match\n    // elsewhere as it's more likely that the user will type the starts\n    // of fragments.\n    // (Our notion of word includes CamelCase and hypen-separated, etc.)\n    SCORE_WORD_JUMP = 0.9,\n\n    // Any other match isn't ideal, but we include it for completeness.\n    SCORE_CHARACTER_JUMP = 0.3,\n\n    // If the user transposed two letters, it should be signficantly penalized.\n    //\n    // i.e. \"ouch\" is more likely than \"curtain\" when \"uc\" is typed.\n    SCORE_TRANSPOSITION = 0.1,\n\n    // If the user jumped to half-way through a subsequent word, it should be\n    // very significantly penalized.\n    //\n    // i.e. \"loes\" is very unlikely to match \"loch ness\".\n    // NOTE: this is set to 0 for superhuman right now, but we may want to revisit.\n    SCORE_LONG_JUMP = 0,\n\n    // The goodness of a match should decay slightly with each missing\n    // character.\n    //\n    // i.e. \"bad\" is more likely than \"bard\" when \"bd\" is typed.\n    //\n    // This will not change the order of suggestions based on SCORE_* until\n    // 100 characters are inserted between matches.\n    PENALTY_SKIPPED = 0.999,\n\n    // The goodness of an exact-case match should be higher than a\n    // case-insensitive match by a small amount.\n    //\n    // i.e. \"HTML\" is more likely than \"haml\" when \"HM\" is typed.\n    //\n    // This will not change the order of suggestions based on SCORE_* until\n    // 1000 characters are inserted between matches.\n    PENALTY_CASE_MISMATCH = 0.9999,\n\n    // If the word has more characters than the user typed, it should\n    // be penalised slightly.\n    //\n    // i.e. \"html\" is more likely than \"html5\" if I type \"html\".\n    //\n    // However, it may well be the case that there's a sensible secondary\n    // ordering (like alphabetical) that it makes sense to rely on when\n    // there are many prefix matches, so we don't make the penalty increase\n    // with the number of tokens.\n    PENALTY_NOT_COMPLETE = 0.99;\n\nvar IS_GAP_REGEXP = /[\\\\\\/\\-_+.# \\t\"@\\[\\(\\{&]/,\n    COUNT_GAPS_REGEXP = /[\\\\\\/\\-_+.# \\t\"@\\[\\(\\{&]/g;\n\nfunction commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex) {\n\n    if (abbreviationIndex === abbreviation.length) {\n        if (stringIndex === string.length) {\n            return SCORE_CONTINUE_MATCH;\n\n        }\n        return PENALTY_NOT_COMPLETE;\n    }\n\n    var abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);\n    var index = lowerString.indexOf(abbreviationChar, stringIndex);\n    var highScore = 0;\n\n    var score, transposedScore, wordBreaks;\n\n    while (index >= 0) {\n\n        score = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 1);\n        if (score > highScore) {\n            if (index === stringIndex) {\n                score *= SCORE_CONTINUE_MATCH;\n            } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {\n                score *= SCORE_WORD_JUMP;\n                wordBreaks = string.slice(stringIndex, index - 1).match(COUNT_GAPS_REGEXP);\n                if (wordBreaks && stringIndex > 0) {\n                    score *= Math.pow(PENALTY_SKIPPED, wordBreaks.length);\n                }\n            } else if (IS_GAP_REGEXP.test(string.slice(stringIndex, index - 1))) {\n                score *= SCORE_LONG_JUMP;\n                if (stringIndex > 0) {\n                    score *= Math.pow(PENALTY_SKIPPED, index - stringIndex);\n                }\n            } else {\n                score *= SCORE_CHARACTER_JUMP;\n                if (stringIndex > 0) {\n                    score *= Math.pow(PENALTY_SKIPPED, index - stringIndex);\n                }\n            }\n\n            if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex)) {\n                score *= PENALTY_CASE_MISMATCH;\n            }\n\n        }\n\n        if (score < SCORE_TRANSPOSITION &&\n                lowerString.charAt(index - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) &&\n                lowerString.charAt(index - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {\n            transposedScore = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 2);\n\n            if (transposedScore * SCORE_TRANSPOSITION > score) {\n                score = transposedScore * SCORE_TRANSPOSITION;\n            }\n        }\n\n        if (score > highScore) {\n            highScore = score;\n        }\n\n        index = lowerString.indexOf(abbreviationChar, index + 1);\n    }\n\n    return highScore;\n}\n\nfunction commandScore(string, abbreviation) {\n    /* NOTE:\n     * in the original, we used to do the lower-casing on each recursive call, but this meant that toLowerCase()\n     * was the dominating cost in the algorithm, passing both is a little ugly, but considerably faster.\n     */\n    return commandScoreInner(string, abbreviation, string.toLowerCase(), abbreviation.toLowerCase(), 0, 0);\n}\n\nmodule.exports = commandScore;\n"],
  "mappings": ";;;;;;AAAA;AAAA;AAKA,QAAI,uBAAuB;AAA3B,QAMI,kBAAkB;AANtB,QASI,uBAAuB;AAT3B,QAcI,sBAAsB;AAd1B,QAqBI,kBAAkB;AArBtB,QA8BI,kBAAkB;AA9BtB,QAuCI,wBAAwB;AAvC5B,QAkDI,uBAAuB;AAE3B,QAAI,gBAAgB;AAApB,QACI,oBAAoB;AAExB,aAAS,kBAAkB,QAAQ,cAAc,aAAa,mBAAmB,aAAa,mBAAmB;AAE7G,UAAI,sBAAsB,aAAa,QAAQ;AAC3C,YAAI,gBAAgB,OAAO,QAAQ;AAC/B,iBAAO;AAAA,QAEX;AACA,eAAO;AAAA,MACX;AAEA,UAAI,mBAAmB,kBAAkB,OAAO,iBAAiB;AACjE,UAAI,QAAQ,YAAY,QAAQ,kBAAkB,WAAW;AAC7D,UAAI,YAAY;AAEhB,UAAI,OAAO,iBAAiB;AAE5B,aAAO,SAAS,GAAG;AAEf,gBAAQ,kBAAkB,QAAQ,cAAc,aAAa,mBAAmB,QAAQ,GAAG,oBAAoB,CAAC;AAChH,YAAI,QAAQ,WAAW;AACnB,cAAI,UAAU,aAAa;AACvB,qBAAS;AAAA,UACb,WAAW,cAAc,KAAK,OAAO,OAAO,QAAQ,CAAC,CAAC,GAAG;AACrD,qBAAS;AACT,yBAAa,OAAO,MAAM,aAAa,QAAQ,CAAC,EAAE,MAAM,iBAAiB;AACzE,gBAAI,cAAc,cAAc,GAAG;AAC/B,uBAAS,KAAK,IAAI,iBAAiB,WAAW,MAAM;AAAA,YACxD;AAAA,UACJ,WAAW,cAAc,KAAK,OAAO,MAAM,aAAa,QAAQ,CAAC,CAAC,GAAG;AACjE,qBAAS;AACT,gBAAI,cAAc,GAAG;AACjB,uBAAS,KAAK,IAAI,iBAAiB,QAAQ,WAAW;AAAA,YAC1D;AAAA,UACJ,OAAO;AACH,qBAAS;AACT,gBAAI,cAAc,GAAG;AACjB,uBAAS,KAAK,IAAI,iBAAiB,QAAQ,WAAW;AAAA,YAC1D;AAAA,UACJ;AAEA,cAAI,OAAO,OAAO,KAAK,MAAM,aAAa,OAAO,iBAAiB,GAAG;AACjE,qBAAS;AAAA,UACb;AAAA,QAEJ;AAEA,YAAI,QAAQ,uBACJ,YAAY,OAAO,QAAQ,CAAC,MAAM,kBAAkB,OAAO,oBAAoB,CAAC,KAChF,YAAY,OAAO,QAAQ,CAAC,MAAM,kBAAkB,OAAO,iBAAiB,GAAG;AACnF,4BAAkB,kBAAkB,QAAQ,cAAc,aAAa,mBAAmB,QAAQ,GAAG,oBAAoB,CAAC;AAE1H,cAAI,kBAAkB,sBAAsB,OAAO;AAC/C,oBAAQ,kBAAkB;AAAA,UAC9B;AAAA,QACJ;AAEA,YAAI,QAAQ,WAAW;AACnB,sBAAY;AAAA,QAChB;AAEA,gBAAQ,YAAY,QAAQ,kBAAkB,QAAQ,CAAC;AAAA,MAC3D;AAEA,aAAO;AAAA,IACX;AAhES;AAkET,aAAS,aAAa,QAAQ,cAAc;AAKxC,aAAO,kBAAkB,QAAQ,cAAc,OAAO,YAAY,GAAG,aAAa,YAAY,GAAG,GAAG,CAAC;AAAA,IACzG;AANS;AAQT,WAAO,UAAU;AAAA;AAAA;",
  "names": []
}
