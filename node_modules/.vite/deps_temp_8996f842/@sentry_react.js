import {
  require_hoist_non_react_statics_cjs
} from "./chunk-QQLE6DLA.js";
import "./chunk-ODIEF2BS.js";
import {
  Breadcrumbs,
  BrowserClient,
  BrowserProfilingIntegration,
  BrowserTracing,
  Dedupe,
  Feedback,
  FunctionToString,
  GlobalHandlers,
  HttpContext,
  Hub,
  INTEGRATIONS,
  InboundFilters,
  LinkedErrors,
  ModuleMetadata,
  Replay$1,
  ReplayCanvas,
  SDK_VERSION,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  Scope,
  TryCatch,
  WINDOW,
  addBreadcrumb,
  addEventProcessor,
  addGlobalEventProcessor,
  addIntegration,
  addNonEnumerableProperty,
  addTracingExtensions,
  applySdkMetadata,
  breadcrumbsIntegration,
  browserApiErrorsIntegration,
  browserProfilingIntegration,
  browserTracingIntegration,
  captureConsoleIntegration,
  captureEvent,
  captureException,
  captureMessage,
  captureSession,
  captureUserFeedback,
  chromeStackLineParser,
  close,
  configureScope,
  contextLinesIntegration,
  continueTrace,
  createTransport,
  createUserFeedbackEnvelope,
  debugIntegration,
  dedupeIntegration,
  defaultIntegrations,
  defaultRequestInstrumentationOptions,
  defaultStackLineParsers,
  defaultStackParser,
  endSession,
  eventFromException,
  eventFromMessage,
  exceptionFromError,
  extraErrorDataIntegration,
  extractTraceparentData,
  feedbackIntegration,
  flush,
  forceLoad,
  functionToStringIntegration,
  geckoStackLineParser,
  getActiveSpan,
  getActiveTransaction,
  getClient,
  getCurrentHub,
  getCurrentScope,
  getDefaultIntegrations,
  getGlobalScope,
  getHubFromCarrier,
  getNumberOfUrlSegments,
  getReplay$1,
  getRootSpan,
  getSpanStatusFromHttpCode,
  globalHandlersIntegration,
  httpClientIntegration,
  httpContextIntegration,
  inboundFiltersIntegration,
  init,
  instrumentOutgoingRequests,
  isError,
  isInitialized,
  lastEventId,
  linkedErrorsIntegration,
  logger,
  makeBrowserOfflineTransport,
  makeFetchTransport,
  makeMain,
  makeMultiplexedTransport,
  makeXHRTransport,
  metrics,
  moduleMetadataIntegration,
  onLoad,
  onProfilingStartRouteTransaction,
  opera10StackLineParser,
  opera11StackLineParser,
  parameterize,
  replayCanvasIntegration,
  replayIntegration$1,
  reportingObserverIntegration,
  rewriteFramesIntegration,
  sendFeedback,
  sessionTimingIntegration,
  setContext,
  setCurrentClient,
  setExtra,
  setExtras,
  setHttpStatus,
  setMeasurement,
  setTag,
  setTags,
  setUser,
  showReportDialog,
  spanStatusfromHttpCode,
  spanToJSON,
  startBrowserTracingNavigationSpan,
  startBrowserTracingPageLoadSpan,
  startInactiveSpan,
  startSession,
  startSpan,
  startSpanManual,
  startTransaction,
  timestampInSeconds,
  trace,
  winjsStackLineParser,
  withActiveSpan,
  withIsolationScope,
  withScope,
  wrap
} from "./chunk-FUBDTEPF.js";
import {
  require_react
} from "./chunk-NSZELEHI.js";
import {
  __name,
  __toESM
} from "./chunk-4OCRLPSA.js";

// node_modules/@sentry/react/esm/sdk.js
function init2(options) {
  const opts = {
    ...options
  };
  applySdkMetadata(opts, "react");
  init(opts);
}
__name(init2, "init");

// node_modules/@sentry/react/esm/profiler.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var React = __toESM(require_react());

// node_modules/@sentry/react/esm/constants.js
var REACT_RENDER_OP = "ui.react.render";
var REACT_UPDATE_OP = "ui.react.update";
var REACT_MOUNT_OP = "ui.react.mount";

// node_modules/@sentry/react/esm/profiler.js
var _jsxFileName = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/profiler.tsx";
var UNKNOWN_COMPONENT = "unknown";
var _Profiler = class _Profiler extends React.Component {
  /**
   * The span of the mount activity
   * Made protected for the React Native SDK to access
   */
  /**
   * The span that represents the duration of time between shouldComponentUpdate and componentDidUpdate
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  static __initStatic() {
    this.defaultProps = {
      disabled: false,
      includeRender: true,
      includeUpdates: true
    };
  }
  constructor(props) {
    super(props);
    const { name, disabled = false } = this.props;
    if (disabled) {
      return;
    }
    this._mountSpan = startInactiveSpan({
      name: `<${name}>`,
      onlyIfParent: true,
      op: REACT_MOUNT_OP,
      origin: "auto.ui.react.profiler",
      attributes: { "ui.component_name": name }
    });
  }
  // If a component mounted, we can finish the mount activity.
  componentDidMount() {
    if (this._mountSpan) {
      this._mountSpan.end();
    }
  }
  shouldComponentUpdate({ updateProps, includeUpdates = true }) {
    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {
      const changedProps = Object.keys(updateProps).filter((k) => updateProps[k] !== this.props.updateProps[k]);
      if (changedProps.length > 0) {
        const now = timestampInSeconds();
        this._updateSpan = withActiveSpan(this._mountSpan, () => {
          return startInactiveSpan({
            name: `<${this.props.name}>`,
            onlyIfParent: true,
            op: REACT_UPDATE_OP,
            origin: "auto.ui.react.profiler",
            startTimestamp: now,
            attributes: {
              "ui.component_name": this.props.name,
              "ui.react.changed_props": changedProps
            }
          });
        });
      }
    }
    return true;
  }
  componentDidUpdate() {
    if (this._updateSpan) {
      this._updateSpan.end();
      this._updateSpan = void 0;
    }
  }
  // If a component is unmounted, we can say it is no longer on the screen.
  // This means we can finish the span representing the component render.
  componentWillUnmount() {
    const endTimestamp = timestampInSeconds();
    const { name, includeRender = true } = this.props;
    if (this._mountSpan && includeRender) {
      const startTimestamp = spanToJSON(this._mountSpan).timestamp;
      withActiveSpan(this._mountSpan, () => {
        const renderSpan = startInactiveSpan({
          onlyIfParent: true,
          name: `<${name}>`,
          op: REACT_RENDER_OP,
          origin: "auto.ui.react.profiler",
          startTimestamp,
          attributes: { "ui.component_name": name }
        });
        if (renderSpan) {
          renderSpan.end(endTimestamp);
        }
      });
    }
  }
  render() {
    return this.props.children;
  }
};
__name(_Profiler, "Profiler");
var Profiler = _Profiler;
Profiler.__initStatic();
function withProfiler(WrappedComponent, options) {
  const componentDisplayName = options && options.name || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;
  const Wrapped = /* @__PURE__ */ __name((props) => React.createElement(
    Profiler,
    { ...options, name: componentDisplayName, updateProps: props, __self: this, __source: { fileName: _jsxFileName, lineNumber: 159 } },
    React.createElement(WrappedComponent, { ...props, __self: this, __source: { fileName: _jsxFileName, lineNumber: 160 } })
  ), "Wrapped");
  Wrapped.displayName = `profiler(${componentDisplayName})`;
  (0, import_hoist_non_react_statics.default)(Wrapped, WrappedComponent);
  return Wrapped;
}
__name(withProfiler, "withProfiler");
function useProfiler(name, options = {
  disabled: false,
  hasRenderSpan: true
}) {
  const [mountSpan] = React.useState(() => {
    if (options && options.disabled) {
      return void 0;
    }
    return startInactiveSpan({
      name: `<${name}>`,
      onlyIfParent: true,
      op: REACT_MOUNT_OP,
      origin: "auto.ui.react.profiler",
      attributes: { "ui.component_name": name }
    });
  });
  React.useEffect(() => {
    if (mountSpan) {
      mountSpan.end();
    }
    return () => {
      if (mountSpan && options.hasRenderSpan) {
        const startTimestamp = spanToJSON(mountSpan).timestamp;
        const endTimestamp = timestampInSeconds();
        const renderSpan = startInactiveSpan({
          name: `<${name}>`,
          onlyIfParent: true,
          op: REACT_RENDER_OP,
          origin: "auto.ui.react.profiler",
          startTimestamp,
          attributes: { "ui.component_name": name }
        });
        if (renderSpan) {
          renderSpan.end(endTimestamp);
        }
      }
    };
  }, []);
}
__name(useProfiler, "useProfiler");

// node_modules/@sentry/react/esm/errorboundary.js
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var React2 = __toESM(require_react());

// node_modules/@sentry/react/esm/debug-build.js
var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// node_modules/@sentry/react/esm/errorboundary.js
var _jsxFileName2 = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/errorboundary.tsx";
function isAtLeastReact17(version2) {
  const major = version2.match(/^([^.]+)/);
  return major !== null && parseInt(major[0]) >= 17;
}
__name(isAtLeastReact17, "isAtLeastReact17");
var UNKNOWN_COMPONENT2 = "unknown";
var INITIAL_STATE = {
  componentStack: null,
  error: null,
  eventId: null
};
function setCause(error, cause) {
  const seenErrors = /* @__PURE__ */ new WeakMap();
  function recurse(error2, cause2) {
    if (seenErrors.has(error2)) {
      return;
    }
    if (error2.cause) {
      seenErrors.set(error2, true);
      return recurse(error2.cause, cause2);
    }
    error2.cause = cause2;
  }
  __name(recurse, "recurse");
  recurse(error, cause);
}
__name(setCause, "setCause");
var _ErrorBoundary = class _ErrorBoundary extends React2.Component {
  constructor(props) {
    super(props);
    _ErrorBoundary.prototype.__init.call(this);
    this.state = INITIAL_STATE;
    this._openFallbackReportDialog = true;
    const client = getClient();
    if (client && client.on && props.showDialog) {
      this._openFallbackReportDialog = false;
      client.on("afterSendEvent", (event) => {
        if (!event.type && event.event_id === this._lastEventId) {
          showReportDialog({ ...props.dialogOptions, eventId: this._lastEventId });
        }
      });
    }
  }
  componentDidCatch(error, { componentStack }) {
    const { beforeCapture, onError, showDialog, dialogOptions } = this.props;
    withScope((scope) => {
      if (isAtLeastReact17(React2.version) && isError(error)) {
        const errorBoundaryError = new Error(error.message);
        errorBoundaryError.name = `React ErrorBoundary ${error.name}`;
        errorBoundaryError.stack = componentStack;
        setCause(error, errorBoundaryError);
      }
      if (beforeCapture) {
        beforeCapture(scope, error, componentStack);
      }
      const eventId = captureException(error, {
        captureContext: {
          contexts: { react: { componentStack } }
        },
        // If users provide a fallback component we can assume they are handling the error.
        // Therefore, we set the mechanism depending on the presence of the fallback prop.
        mechanism: { handled: !!this.props.fallback }
      });
      if (onError) {
        onError(error, componentStack, eventId);
      }
      if (showDialog) {
        this._lastEventId = eventId;
        if (this._openFallbackReportDialog) {
          showReportDialog({ ...dialogOptions, eventId });
        }
      }
      this.setState({ error, componentStack, eventId });
    });
  }
  componentDidMount() {
    const { onMount } = this.props;
    if (onMount) {
      onMount();
    }
  }
  componentWillUnmount() {
    const { error, componentStack, eventId } = this.state;
    const { onUnmount } = this.props;
    if (onUnmount) {
      onUnmount(error, componentStack, eventId);
    }
  }
  __init() {
    this.resetErrorBoundary = () => {
      const { onReset } = this.props;
      const { error, componentStack, eventId } = this.state;
      if (onReset) {
        onReset(error, componentStack, eventId);
      }
      this.setState(INITIAL_STATE);
    };
  }
  render() {
    const { fallback, children } = this.props;
    const state = this.state;
    if (state.error) {
      let element = void 0;
      if (typeof fallback === "function") {
        element = fallback({
          error: state.error,
          componentStack: state.componentStack,
          resetError: this.resetErrorBoundary,
          eventId: state.eventId
        });
      } else {
        element = fallback;
      }
      if (React2.isValidElement(element)) {
        return element;
      }
      if (fallback) {
        DEBUG_BUILD && logger.warn("fallback did not produce a valid ReactElement");
      }
      return null;
    }
    if (typeof children === "function") {
      return children();
    }
    return children;
  }
};
__name(_ErrorBoundary, "ErrorBoundary");
var ErrorBoundary = _ErrorBoundary;
function withErrorBoundary(WrappedComponent, errorBoundaryOptions) {
  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT2;
  const Wrapped = /* @__PURE__ */ __name((props) => React2.createElement(
    ErrorBoundary,
    { ...errorBoundaryOptions, __self: this, __source: { fileName: _jsxFileName2, lineNumber: 240 } },
    React2.createElement(WrappedComponent, { ...props, __self: this, __source: { fileName: _jsxFileName2, lineNumber: 241 } })
  ), "Wrapped");
  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;
  (0, import_hoist_non_react_statics2.default)(Wrapped, WrappedComponent);
  return Wrapped;
}
__name(withErrorBoundary, "withErrorBoundary");

// node_modules/@sentry/react/esm/redux.js
var ACTION_BREADCRUMB_CATEGORY = "redux.action";
var ACTION_BREADCRUMB_TYPE = "info";
var defaultOptions = {
  attachReduxState: true,
  actionTransformer: /* @__PURE__ */ __name((action) => action, "actionTransformer"),
  stateTransformer: /* @__PURE__ */ __name((state) => state || null, "stateTransformer")
};
function createReduxEnhancer(enhancerOptions) {
  const options = {
    ...defaultOptions,
    ...enhancerOptions
  };
  return (next) => (reducer, initialState) => {
    options.attachReduxState && getGlobalScope().addEventProcessor((event, hint) => {
      try {
        if (event.type === void 0 && event.contexts.state.state.type === "redux") {
          hint.attachments = [
            ...hint.attachments || [],
            // @ts-expect-error try catch to reduce bundle size
            { filename: "redux_state.json", data: JSON.stringify(event.contexts.state.state.value) }
          ];
        }
      } catch (_) {
      }
      return event;
    });
    const sentryReducer = /* @__PURE__ */ __name((state, action) => {
      const newState = reducer(state, action);
      const scope = getCurrentScope();
      const transformedAction = options.actionTransformer(action);
      if (typeof transformedAction !== "undefined" && transformedAction !== null) {
        scope.addBreadcrumb({
          category: ACTION_BREADCRUMB_CATEGORY,
          data: transformedAction,
          type: ACTION_BREADCRUMB_TYPE
        });
      }
      const transformedState = options.stateTransformer(newState);
      if (typeof transformedState !== "undefined" && transformedState !== null) {
        const client = getClient();
        const options2 = client && client.getOptions();
        const normalizationDepth = options2 && options2.normalizeDepth || 3;
        const newStateContext = { state: { type: "redux", value: transformedState } };
        addNonEnumerableProperty(
          newStateContext,
          "__sentry_override_normalization_depth__",
          3 + // 3 layers for `state.value.transformedState`
          normalizationDepth
          // rest for the actual state
        );
        scope.setContext("state", newStateContext);
      } else {
        scope.setContext("state", null);
      }
      const { configureScopeWithState } = options;
      if (typeof configureScopeWithState === "function") {
        configureScopeWithState(scope, newState);
      }
      return newState;
    }, "sentryReducer");
    return next(sentryReducer, initialState);
  };
}
__name(createReduxEnhancer, "createReduxEnhancer");

// node_modules/@sentry/react/esm/reactrouterv3.js
function reactRouterV3BrowserTracingIntegration(options) {
  const integration = browserTracingIntegration({
    ...options,
    instrumentPageLoad: false,
    instrumentNavigation: false
  });
  const { history, routes, match, instrumentPageLoad = true, instrumentNavigation = true } = options;
  return {
    ...integration,
    afterAllSetup(client) {
      integration.afterAllSetup(client);
      const startPageloadCallback = /* @__PURE__ */ __name((startSpanOptions) => {
        startBrowserTracingPageLoadSpan(client, startSpanOptions);
        return void 0;
      }, "startPageloadCallback");
      const startNavigationCallback = /* @__PURE__ */ __name((startSpanOptions) => {
        startBrowserTracingNavigationSpan(client, startSpanOptions);
        return void 0;
      }, "startNavigationCallback");
      const instrumentation = reactRouterV3Instrumentation(history, routes, match);
      instrumentation(startPageloadCallback, instrumentPageLoad, false);
      instrumentation(startNavigationCallback, false, instrumentNavigation);
    }
  };
}
__name(reactRouterV3BrowserTracingIntegration, "reactRouterV3BrowserTracingIntegration");
function reactRouterV3Instrumentation(history, routes, match) {
  return (startTransaction2, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) => {
    let activeTransaction3;
    let prevName;
    if (startTransactionOnPageLoad && WINDOW && WINDOW.location) {
      normalizeTransactionName(
        routes,
        WINDOW.location,
        match,
        (localName, source = "url") => {
          prevName = localName;
          activeTransaction3 = startTransaction2({
            name: prevName,
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "pageload",
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.pageload.react.reactrouter_v3",
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source
            }
          });
        }
      );
    }
    if (startTransactionOnLocationChange && history.listen) {
      history.listen((location) => {
        if (location.action === "PUSH" || location.action === "POP") {
          if (activeTransaction3) {
            activeTransaction3.end();
          }
          normalizeTransactionName(routes, location, match, (localName, source = "url") => {
            prevName = localName;
            const attributes = {
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "navigation",
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.navigation.react.reactrouter_v3",
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source
            };
            activeTransaction3 = startTransaction2({
              name: prevName,
              attributes
            });
          });
        }
      });
    }
  };
}
__name(reactRouterV3Instrumentation, "reactRouterV3Instrumentation");
function normalizeTransactionName(appRoutes, location, match, callback) {
  let name = location.pathname;
  match(
    {
      location,
      routes: appRoutes
    },
    (error, _redirectLocation, renderProps) => {
      if (error || !renderProps) {
        return callback(name);
      }
      const routePath = getRouteStringFromRoutes(renderProps.routes || []);
      if (routePath.length === 0 || routePath === "/*") {
        return callback(name);
      }
      name = routePath;
      return callback(name, "route");
    }
  );
}
__name(normalizeTransactionName, "normalizeTransactionName");
function getRouteStringFromRoutes(routes) {
  if (!Array.isArray(routes) || routes.length === 0) {
    return "";
  }
  const routesWithPaths = routes.filter((route) => !!route.path);
  let index = -1;
  for (let x = routesWithPaths.length - 1; x >= 0; x--) {
    const route = routesWithPaths[x];
    if (route.path && route.path.startsWith("/")) {
      index = x;
      break;
    }
  }
  return routesWithPaths.slice(index).filter(({ path }) => !!path).map(({ path }) => path).join("");
}
__name(getRouteStringFromRoutes, "getRouteStringFromRoutes");

// node_modules/@sentry/react/esm/reactrouter.js
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs());
var React3 = __toESM(require_react());
var _jsxFileName3 = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/reactrouter.tsx";
var activeTransaction;
function reactRouterV4BrowserTracingIntegration(options) {
  const integration = browserTracingIntegration({
    ...options,
    instrumentPageLoad: false,
    instrumentNavigation: false
  });
  const { history, routes, matchPath, instrumentPageLoad = true, instrumentNavigation = true } = options;
  return {
    ...integration,
    afterAllSetup(client) {
      integration.afterAllSetup(client);
      const startPageloadCallback = /* @__PURE__ */ __name((startSpanOptions) => {
        startBrowserTracingPageLoadSpan(client, startSpanOptions);
        return void 0;
      }, "startPageloadCallback");
      const startNavigationCallback = /* @__PURE__ */ __name((startSpanOptions) => {
        startBrowserTracingNavigationSpan(client, startSpanOptions);
        return void 0;
      }, "startNavigationCallback");
      const instrumentation = reactRouterV4Instrumentation(history, routes, matchPath);
      instrumentation(startPageloadCallback, instrumentPageLoad, false);
      instrumentation(startNavigationCallback, false, instrumentNavigation);
    }
  };
}
__name(reactRouterV4BrowserTracingIntegration, "reactRouterV4BrowserTracingIntegration");
function reactRouterV5BrowserTracingIntegration(options) {
  const integration = browserTracingIntegration({
    ...options,
    instrumentPageLoad: false,
    instrumentNavigation: false
  });
  const { history, routes, matchPath } = options;
  return {
    ...integration,
    afterAllSetup(client) {
      integration.afterAllSetup(client);
      const startPageloadCallback = /* @__PURE__ */ __name((startSpanOptions) => {
        startBrowserTracingPageLoadSpan(client, startSpanOptions);
        return void 0;
      }, "startPageloadCallback");
      const startNavigationCallback = /* @__PURE__ */ __name((startSpanOptions) => {
        startBrowserTracingNavigationSpan(client, startSpanOptions);
        return void 0;
      }, "startNavigationCallback");
      const instrumentation = reactRouterV5Instrumentation(history, routes, matchPath);
      instrumentation(startPageloadCallback, options.instrumentPageLoad, false);
      instrumentation(startNavigationCallback, false, options.instrumentNavigation);
    }
  };
}
__name(reactRouterV5BrowserTracingIntegration, "reactRouterV5BrowserTracingIntegration");
function reactRouterV4Instrumentation(history, routes, matchPath) {
  return createReactRouterInstrumentation(history, "reactrouter_v4", routes, matchPath);
}
__name(reactRouterV4Instrumentation, "reactRouterV4Instrumentation");
function reactRouterV5Instrumentation(history, routes, matchPath) {
  return createReactRouterInstrumentation(history, "reactrouter_v5", routes, matchPath);
}
__name(reactRouterV5Instrumentation, "reactRouterV5Instrumentation");
function createReactRouterInstrumentation(history, instrumentationName, allRoutes = [], matchPath) {
  function getInitPathName() {
    if (history && history.location) {
      return history.location.pathname;
    }
    if (WINDOW && WINDOW.location) {
      return WINDOW.location.pathname;
    }
    return void 0;
  }
  __name(getInitPathName, "getInitPathName");
  function normalizeTransactionName2(pathname) {
    if (allRoutes.length === 0 || !matchPath) {
      return [pathname, "url"];
    }
    const branches = matchRoutes(allRoutes, pathname, matchPath);
    for (let x = 0; x < branches.length; x++) {
      if (branches[x].match.isExact) {
        return [branches[x].match.path, "route"];
      }
    }
    return [pathname, "url"];
  }
  __name(normalizeTransactionName2, "normalizeTransactionName");
  return (customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) => {
    const initPathName = getInitPathName();
    if (startTransactionOnPageLoad && initPathName) {
      const [name, source] = normalizeTransactionName2(initPathName);
      activeTransaction = customStartTransaction({
        name,
        attributes: {
          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "pageload",
          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.pageload.react.${instrumentationName}`,
          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source
        }
      });
    }
    if (startTransactionOnLocationChange && history.listen) {
      history.listen((location, action) => {
        if (action && (action === "PUSH" || action === "POP")) {
          if (activeTransaction) {
            activeTransaction.end();
          }
          const [name, source] = normalizeTransactionName2(location.pathname);
          activeTransaction = customStartTransaction({
            name,
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "navigation",
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.navigation.react.${instrumentationName}`,
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source
            }
          });
        }
      });
    }
  };
}
__name(createReactRouterInstrumentation, "createReactRouterInstrumentation");
function matchRoutes(routes, pathname, matchPath, branch = []) {
  routes.some((route) => {
    const match = route.path ? matchPath(pathname, route) : branch.length ? branch[branch.length - 1].match : computeRootMatch(pathname);
    if (match) {
      branch.push({ route, match });
      if (route.routes) {
        matchRoutes(route.routes, pathname, matchPath, branch);
      }
    }
    return !!match;
  });
  return branch;
}
__name(matchRoutes, "matchRoutes");
function computeRootMatch(pathname) {
  return { path: "/", url: "/", params: {}, isExact: pathname === "/" };
}
__name(computeRootMatch, "computeRootMatch");
function withSentryRouting(Route) {
  const componentDisplayName = Route.displayName || Route.name;
  const WrappedRoute = /* @__PURE__ */ __name((props) => {
    if (props && props.computedMatch && props.computedMatch.isExact) {
      const route = props.computedMatch.path;
      const activeRootSpan = getActiveRootSpan();
      if (activeRootSpan) {
        activeRootSpan.updateName(route);
        activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, "route");
      }
    }
    return React3.createElement(Route, { ...props, __self: this, __source: { fileName: _jsxFileName3, lineNumber: 279 } });
  }, "WrappedRoute");
  WrappedRoute.displayName = `sentryRoute(${componentDisplayName})`;
  (0, import_hoist_non_react_statics3.default)(WrappedRoute, Route);
  return WrappedRoute;
}
__name(withSentryRouting, "withSentryRouting");
function getActiveRootSpan() {
  if (activeTransaction) {
    return activeTransaction;
  }
  const span = getActiveSpan();
  const rootSpan = span ? getRootSpan(span) : void 0;
  if (!rootSpan) {
    return void 0;
  }
  const op = spanToJSON(rootSpan).op;
  return op === "navigation" || op === "pageload" ? rootSpan : void 0;
}
__name(getActiveRootSpan, "getActiveRootSpan");

// node_modules/@sentry/react/esm/reactrouterv6.js
var import_hoist_non_react_statics4 = __toESM(require_hoist_non_react_statics_cjs());
var React4 = __toESM(require_react());
var _jsxFileName4 = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/reactrouterv6.tsx";
var activeTransaction2;
var _useEffect;
var _useLocation;
var _useNavigationType;
var _createRoutesFromChildren;
var _matchRoutes;
var _customStartTransaction;
var _startTransactionOnLocationChange;
var _stripBasename = false;
function reactRouterV6BrowserTracingIntegration(options) {
  const integration = browserTracingIntegration({
    ...options,
    instrumentPageLoad: false,
    instrumentNavigation: false
  });
  const {
    useEffect: useEffect2,
    useLocation,
    useNavigationType,
    createRoutesFromChildren,
    matchRoutes: matchRoutes2,
    stripBasename,
    instrumentPageLoad = true,
    instrumentNavigation = true
  } = options;
  return {
    ...integration,
    afterAllSetup(client) {
      integration.afterAllSetup(client);
      const startNavigationCallback = /* @__PURE__ */ __name((startSpanOptions) => {
        startBrowserTracingNavigationSpan(client, startSpanOptions);
        return void 0;
      }, "startNavigationCallback");
      const initPathName = WINDOW && WINDOW.location && WINDOW.location.pathname;
      if (instrumentPageLoad && initPathName) {
        startBrowserTracingPageLoadSpan(client, {
          name: initPathName,
          attributes: {
            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url",
            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "pageload",
            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.pageload.react.reactrouter_v6"
          }
        });
      }
      _useEffect = useEffect2;
      _useLocation = useLocation;
      _useNavigationType = useNavigationType;
      _matchRoutes = matchRoutes2;
      _createRoutesFromChildren = createRoutesFromChildren;
      _stripBasename = stripBasename || false;
      _customStartTransaction = startNavigationCallback;
      _startTransactionOnLocationChange = instrumentNavigation;
    }
  };
}
__name(reactRouterV6BrowserTracingIntegration, "reactRouterV6BrowserTracingIntegration");
function reactRouterV6Instrumentation(useEffect2, useLocation, useNavigationType, createRoutesFromChildren, matchRoutes2, stripBasename) {
  return (customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) => {
    const initPathName = WINDOW && WINDOW.location && WINDOW.location.pathname;
    if (startTransactionOnPageLoad && initPathName) {
      activeTransaction2 = customStartTransaction({
        name: initPathName,
        attributes: {
          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url",
          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "pageload",
          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.pageload.react.reactrouter_v6"
        }
      });
    }
    _useEffect = useEffect2;
    _useLocation = useLocation;
    _useNavigationType = useNavigationType;
    _matchRoutes = matchRoutes2;
    _createRoutesFromChildren = createRoutesFromChildren;
    _stripBasename = stripBasename || false;
    _customStartTransaction = customStartTransaction;
    _startTransactionOnLocationChange = startTransactionOnLocationChange;
  };
}
__name(reactRouterV6Instrumentation, "reactRouterV6Instrumentation");
function stripBasenameFromPathname(pathname, basename) {
  if (!basename || basename === "/") {
    return pathname;
  }
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return pathname;
  }
  const startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  const nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return pathname;
  }
  return pathname.slice(startIndex) || "/";
}
__name(stripBasenameFromPathname, "stripBasenameFromPathname");
function getNormalizedName(routes, location, branches, basename = "") {
  if (!routes || routes.length === 0) {
    return [_stripBasename ? stripBasenameFromPathname(location.pathname, basename) : location.pathname, "url"];
  }
  let pathBuilder = "";
  if (branches) {
    for (let x = 0; x < branches.length; x++) {
      const branch = branches[x];
      const route = branch.route;
      if (route) {
        if (route.index) {
          return [_stripBasename ? stripBasenameFromPathname(branch.pathname, basename) : branch.pathname, "route"];
        }
        const path = route.path;
        if (path) {
          const newPath = path[0] === "/" || pathBuilder[pathBuilder.length - 1] === "/" ? path : `/${path}`;
          pathBuilder += newPath;
          if (basename + branch.pathname === location.pathname) {
            if (
              // If the route defined on the element is something like
              // <Route path="/stores/:storeId/products/:productId" element={<div>Product</div>} />
              // We should check against the branch.pathname for the number of / seperators
              getNumberOfUrlSegments(pathBuilder) !== getNumberOfUrlSegments(branch.pathname) && // We should not count wildcard operators in the url segments calculation
              pathBuilder.slice(-2) !== "/*"
            ) {
              return [(_stripBasename ? "" : basename) + newPath, "route"];
            }
            return [(_stripBasename ? "" : basename) + pathBuilder, "route"];
          }
        }
      }
    }
  }
  return [_stripBasename ? stripBasenameFromPathname(location.pathname, basename) : location.pathname, "url"];
}
__name(getNormalizedName, "getNormalizedName");
function updatePageloadTransaction(activeRootSpan, location, routes, matches, basename) {
  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location, basename);
  if (activeRootSpan && branches) {
    const [name, source] = getNormalizedName(routes, location, branches, basename);
    activeRootSpan.updateName(name);
    activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);
  }
}
__name(updatePageloadTransaction, "updatePageloadTransaction");
function handleNavigation(location, routes, navigationType, matches, basename) {
  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location, basename);
  if (_startTransactionOnLocationChange && (navigationType === "PUSH" || navigationType === "POP") && branches) {
    if (activeTransaction2) {
      activeTransaction2.end();
    }
    const [name, source] = getNormalizedName(routes, location, branches, basename);
    activeTransaction2 = _customStartTransaction({
      name,
      attributes: {
        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
        [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "navigation",
        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.navigation.react.reactrouter_v6"
      }
    });
  }
}
__name(handleNavigation, "handleNavigation");
function withSentryReactRouterV6Routing(Routes) {
  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes || !_customStartTransaction) {
    DEBUG_BUILD && logger.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.
      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.
      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}. customStartTransaction: ${_customStartTransaction}.`);
    return Routes;
  }
  let isMountRenderPass = true;
  const SentryRoutes = /* @__PURE__ */ __name((props) => {
    const location = _useLocation();
    const navigationType = _useNavigationType();
    _useEffect(
      () => {
        const routes = _createRoutesFromChildren(props.children);
        if (isMountRenderPass) {
          updatePageloadTransaction(getActiveRootSpan2(), location, routes);
          isMountRenderPass = false;
        } else {
          handleNavigation(location, routes, navigationType);
        }
      },
      // `props.children` is purpusely not included in the dependency array, because we do not want to re-run this effect
      // when the children change. We only want to start transactions when the location or navigation type change.
      [location, navigationType]
    );
    return React4.createElement(Routes, { ...props, __self: this, __source: { fileName: _jsxFileName4, lineNumber: 329 } });
  }, "SentryRoutes");
  (0, import_hoist_non_react_statics4.default)(SentryRoutes, Routes);
  return SentryRoutes;
}
__name(withSentryReactRouterV6Routing, "withSentryReactRouterV6Routing");
function wrapUseRoutes(origUseRoutes) {
  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes || !_customStartTransaction) {
    DEBUG_BUILD && logger.warn(
      "reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters."
    );
    return origUseRoutes;
  }
  let isMountRenderPass = true;
  const SentryRoutes = /* @__PURE__ */ __name((props) => {
    const { routes, locationArg } = props;
    const Routes = origUseRoutes(routes, locationArg);
    const location = _useLocation();
    const navigationType = _useNavigationType();
    const stableLocationParam = typeof locationArg === "string" || locationArg && locationArg.pathname ? locationArg : location;
    _useEffect(() => {
      const normalizedLocation = typeof stableLocationParam === "string" ? { pathname: stableLocationParam } : stableLocationParam;
      if (isMountRenderPass) {
        updatePageloadTransaction(getActiveRootSpan2(), normalizedLocation, routes);
        isMountRenderPass = false;
      } else {
        handleNavigation(normalizedLocation, routes, navigationType);
      }
    }, [navigationType, stableLocationParam]);
    return Routes;
  }, "SentryRoutes");
  return (routes, locationArg) => {
    return React4.createElement(SentryRoutes, { routes, locationArg, __self: this, __source: { fileName: _jsxFileName4, lineNumber: 386 } });
  };
}
__name(wrapUseRoutes, "wrapUseRoutes");
function wrapCreateBrowserRouter(createRouterFunction) {
  return function(routes, opts) {
    const router = createRouterFunction(routes, opts);
    const basename = opts && opts.basename;
    const activeRootSpan = getActiveRootSpan2();
    if (router.state.historyAction === "POP" && activeRootSpan) {
      updatePageloadTransaction(activeRootSpan, router.state.location, routes, void 0, basename);
    }
    router.subscribe((state) => {
      const location = state.location;
      if (_startTransactionOnLocationChange && (state.historyAction === "PUSH" || state.historyAction === "POP")) {
        handleNavigation(location, routes, state.historyAction, void 0, basename);
      }
    });
    return router;
  };
}
__name(wrapCreateBrowserRouter, "wrapCreateBrowserRouter");
function getActiveRootSpan2() {
  if (activeTransaction2) {
    return activeTransaction2;
  }
  const span = getActiveSpan();
  const rootSpan = span ? getRootSpan(span) : void 0;
  if (!rootSpan) {
    return void 0;
  }
  const op = spanToJSON(rootSpan).op;
  return op === "navigation" || op === "pageload" ? rootSpan : void 0;
}
__name(getActiveRootSpan2, "getActiveRootSpan");
export {
  Breadcrumbs,
  BrowserClient,
  BrowserProfilingIntegration,
  BrowserTracing,
  Dedupe,
  ErrorBoundary,
  Feedback,
  FunctionToString,
  GlobalHandlers,
  HttpContext,
  Hub,
  InboundFilters,
  INTEGRATIONS as Integrations,
  LinkedErrors,
  ModuleMetadata,
  Profiler,
  Replay$1 as Replay,
  ReplayCanvas,
  SDK_VERSION,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  Scope,
  TryCatch,
  WINDOW,
  addBreadcrumb,
  addEventProcessor,
  addGlobalEventProcessor,
  addIntegration,
  addTracingExtensions,
  breadcrumbsIntegration,
  browserApiErrorsIntegration,
  browserProfilingIntegration,
  browserTracingIntegration,
  captureConsoleIntegration,
  captureEvent,
  captureException,
  captureMessage,
  captureSession,
  captureUserFeedback,
  chromeStackLineParser,
  close,
  configureScope,
  contextLinesIntegration,
  continueTrace,
  createReduxEnhancer,
  createTransport,
  createUserFeedbackEnvelope,
  debugIntegration,
  dedupeIntegration,
  defaultIntegrations,
  defaultRequestInstrumentationOptions,
  defaultStackLineParsers,
  defaultStackParser,
  endSession,
  eventFromException,
  eventFromMessage,
  exceptionFromError,
  extraErrorDataIntegration,
  extractTraceparentData,
  feedbackIntegration,
  flush,
  forceLoad,
  functionToStringIntegration,
  geckoStackLineParser,
  getActiveSpan,
  getActiveTransaction,
  getClient,
  getCurrentHub,
  getCurrentScope,
  getDefaultIntegrations,
  getHubFromCarrier,
  getReplay$1 as getReplay,
  getSpanStatusFromHttpCode,
  globalHandlersIntegration,
  httpClientIntegration,
  httpContextIntegration,
  inboundFiltersIntegration,
  init2 as init,
  instrumentOutgoingRequests,
  isInitialized,
  lastEventId,
  linkedErrorsIntegration,
  makeBrowserOfflineTransport,
  makeFetchTransport,
  makeMain,
  makeMultiplexedTransport,
  makeXHRTransport,
  metrics,
  moduleMetadataIntegration,
  onLoad,
  onProfilingStartRouteTransaction,
  opera10StackLineParser,
  opera11StackLineParser,
  parameterize,
  reactRouterV3BrowserTracingIntegration,
  reactRouterV3Instrumentation,
  reactRouterV4BrowserTracingIntegration,
  reactRouterV4Instrumentation,
  reactRouterV5BrowserTracingIntegration,
  reactRouterV5Instrumentation,
  reactRouterV6BrowserTracingIntegration,
  reactRouterV6Instrumentation,
  replayCanvasIntegration,
  replayIntegration$1 as replayIntegration,
  reportingObserverIntegration,
  rewriteFramesIntegration,
  sendFeedback,
  sessionTimingIntegration,
  setContext,
  setCurrentClient,
  setExtra,
  setExtras,
  setHttpStatus,
  setMeasurement,
  setTag,
  setTags,
  setUser,
  showReportDialog,
  spanStatusfromHttpCode,
  startBrowserTracingNavigationSpan,
  startBrowserTracingPageLoadSpan,
  startInactiveSpan,
  startSession,
  startSpan,
  startSpanManual,
  startTransaction,
  trace,
  useProfiler,
  winjsStackLineParser,
  withActiveSpan,
  withErrorBoundary,
  withIsolationScope,
  withProfiler,
  withScope,
  withSentryReactRouterV6Routing,
  withSentryRouting,
  wrap,
  wrapCreateBrowserRouter,
  wrapUseRoutes
};
//# sourceMappingURL=@sentry_react.js.map
