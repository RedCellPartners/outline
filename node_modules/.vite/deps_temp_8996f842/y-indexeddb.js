import {
  Observable,
  applyUpdate,
  create3 as create,
  create4 as create2,
  encodeStateAsUpdate,
  transact
} from "./chunk-2OJWYYAH.js";
import {
  __name
} from "./chunk-4OCRLPSA.js";

// node_modules/lib0/indexeddb.js
var rtop = /* @__PURE__ */ __name((request) => create2((resolve, reject) => {
  request.onerror = (event) => reject(new Error(event.target.error));
  request.onsuccess = (event) => resolve(event.target.result);
}), "rtop");
var openDB = /* @__PURE__ */ __name((name, initDB) => create2((resolve, reject) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject(create(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve(db);
  };
}), "openDB");
var deleteDB = /* @__PURE__ */ __name((name) => rtop(indexedDB.deleteDatabase(name)), "deleteDB");
var createStores = /* @__PURE__ */ __name((db, definitions) => definitions.forEach(
  (d) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d)
  )
), "createStores");
var transact2 = /* @__PURE__ */ __name((db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
}, "transact");
var count = /* @__PURE__ */ __name((store, range) => rtop(store.count(range)), "count");
var get = /* @__PURE__ */ __name((store, key) => rtop(store.get(key)), "get");
var del = /* @__PURE__ */ __name((store, key) => rtop(store.delete(key)), "del");
var put = /* @__PURE__ */ __name((store, item, key) => rtop(store.put(item, key)), "put");
var addAutoKey = /* @__PURE__ */ __name((store, item) => rtop(store.add(item)), "addAutoKey");
var getAll = /* @__PURE__ */ __name((store, range, limit) => rtop(store.getAll(range, limit)), "getAll");
var queryFirst = /* @__PURE__ */ __name((store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
}, "queryFirst");
var getLastKey = /* @__PURE__ */ __name((store, range = null) => queryFirst(store, range, "prev"), "getLastKey");
var iterateOnRequest = /* @__PURE__ */ __name((request, f) => create2((resolve, reject) => {
  request.onerror = reject;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve();
    }
    cursor.continue();
  };
}), "iterateOnRequest");
var iterateKeys = /* @__PURE__ */ __name((store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key)), "iterateKeys");
var getStore = /* @__PURE__ */ __name((t, store) => t.objectStore(store), "getStore");
var createIDBKeyRangeUpperBound = /* @__PURE__ */ __name((upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen), "createIDBKeyRangeUpperBound");
var createIDBKeyRangeLowerBound = /* @__PURE__ */ __name((lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen), "createIDBKeyRangeLowerBound");

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = /* @__PURE__ */ __name((idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
}, "fetchUpdates");
var storeState = /* @__PURE__ */ __name((idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
}), "storeState");
var clearDocument = /* @__PURE__ */ __name((name) => deleteDB(name), "clearDocument");
var _IndexeddbPersistence = class _IndexeddbPersistence extends Observable {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc) {
    super();
    this.doc = doc;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create2((resolve) => this.on("synced", () => resolve(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = /* @__PURE__ */ __name((updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc)), "beforeApplyUpdatesCallback");
      const afterApplyUpdatesCallback = /* @__PURE__ */ __name(() => {
        if (this._destroyed) return this;
        this.synced = true;
        this.emit("synced", [this]);
      }, "afterApplyUpdatesCallback");
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update, origin) => {
      if (this.db && origin !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};
__name(_IndexeddbPersistence, "IndexeddbPersistence");
var IndexeddbPersistence = _IndexeddbPersistence;
export {
  IndexeddbPersistence,
  PREFERRED_TRIM_SIZE,
  clearDocument,
  fetchUpdates,
  storeState
};
//# sourceMappingURL=y-indexeddb.js.map
