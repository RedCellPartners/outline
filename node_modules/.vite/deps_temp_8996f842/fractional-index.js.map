{
  "version": 3,
  "sources": ["../../fractional-index/index.js"],
  "sourcesContent": ["// Fractional string indexes for ordering items.\n// References\n// - https://www.figma.com/blog/realtime-editing-of-ordered-sequences/\n// Original source\n// - https://observablehq.com/@dgreensp/implementing-fractional-indexing\n//\n// We would like to be able to re-order items in an ordered list by only\n// updating the index of the thing that moved. We can do this by using\n// non-integer indexes, such that moving an item between two other items can be\n// done by making the item's index in between the previous item's index and the\n// next item's index.\n//\n// We will use strings for the indexes instead of decimals to avoid\n// error-prone floating point math and limited ability to represent floats\n// with large decimals.\n\n// base10 configuration\n// export const ZERO = 48; // \"0\"\n// export const UPPER_LIMIT = 58; // ASCII code for \"9\" + 1\n\n// base95 configuration\nconst ZERO = 32; // \" \", beginning of ASCII range\nconst UPPER_LIMIT = 127; // end of ASCII range + 1\n\n// `a` may be empty string or null, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\nfunction fractionalIndex(\n  a,\n  b\n) {\n  if (a === null) {\n    a = \"\";\n  }\n\n  if (b !== null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (\n    a.slice(-1) === String.fromCharCode(ZERO) ||\n    (b && b.slice(-1) === String.fromCharCode(ZERO))\n  ) {\n    throw new Error(\"trailing zero\");\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0;\n    while ((a.charAt(n) || String.fromCharCode(ZERO)) === b.charAt(n)) {\n      n++;\n    }\n    if (n > 0) {\n      return b.slice(0, n) + fractionalIndex(a.slice(n), b.slice(n));\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? a.charCodeAt(0) : ZERO;\n  const digitB = b !== null ? b.charCodeAt(0) : UPPER_LIMIT;\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB));\n    return String.fromCharCode(midDigit);\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1);\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or the largest digit if `b` is null.\n      // given, for example in base10, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return String.fromCharCode(digitA) + fractionalIndex(a.slice(1), null);\n    }\n  }\n}\n\nfractionalIndex.ZERO = ZERO;\nfractionalIndex.UPPER_LIMIT = UPPER_LIMIT;\n\nmodule.exports = fractionalIndex;\n"],
  "mappings": ";;;;;;AAAA;AAAA;AAqBA,QAAM,OAAO;AACb,QAAM,cAAc;AAKpB,aAAS,gBACP,GACA,GACA;AACA,UAAI,MAAM,MAAM;AACd,YAAI;AAAA,MACN;AAEA,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,cAAM,IAAI,MAAM,IAAI,SAAS,CAAC;AAAA,MAChC;AACA,UACE,EAAE,MAAM,EAAE,MAAM,OAAO,aAAa,IAAI,KACvC,KAAK,EAAE,MAAM,EAAE,MAAM,OAAO,aAAa,IAAI,GAC9C;AACA,cAAM,IAAI,MAAM,eAAe;AAAA,MACjC;AACA,UAAI,GAAG;AAIL,YAAI,IAAI;AACR,gBAAQ,EAAE,OAAO,CAAC,KAAK,OAAO,aAAa,IAAI,OAAO,EAAE,OAAO,CAAC,GAAG;AACjE;AAAA,QACF;AACA,YAAI,IAAI,GAAG;AACT,iBAAO,EAAE,MAAM,GAAG,CAAC,IAAI,gBAAgB,EAAE,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AAAA,QAC/D;AAAA,MACF;AAEA,YAAM,SAAS,IAAI,EAAE,WAAW,CAAC,IAAI;AACrC,YAAM,SAAS,MAAM,OAAO,EAAE,WAAW,CAAC,IAAI;AAC9C,UAAI,SAAS,SAAS,GAAG;AACvB,cAAM,WAAW,KAAK,MAAM,OAAO,SAAS,OAAO;AACnD,eAAO,OAAO,aAAa,QAAQ;AAAA,MACrC,OAAO;AAEL,YAAI,KAAK,EAAE,SAAS,GAAG;AACrB,iBAAO,EAAE,MAAM,GAAG,CAAC;AAAA,QACrB,OAAO;AAOL,iBAAO,OAAO,aAAa,MAAM,IAAI,gBAAgB,EAAE,MAAM,CAAC,GAAG,IAAI;AAAA,QACvE;AAAA,MACF;AAAA,IACF;AAjDS;AAmDT,oBAAgB,OAAO;AACvB,oBAAgB,cAAc;AAE9B,WAAO,UAAU;AAAA;AAAA;",
  "names": []
}
