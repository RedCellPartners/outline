{
  "version": 3,
  "sources": ["../../mobx-utils/mobx-utils.module.js"],
  "sourcesContent": ["import { _allowStateChanges, _isComputingDerivation, action, autorun, computed, createAtom, extendObservable, flow, getAtom, isAction, isObservableArray, isObservableMap, isObservableObject, keys, observable, onBecomeUnobserved, runInAction, when } from 'mobx';\n\nvar NOOP = function () { };\nvar IDENTITY = function (_) { return _; };\nfunction invariant(cond, message) {\n    if (message === void 0) { message = \"Illegal state\"; }\n    if (!cond)\n        throw new Error(\"[mobx-utils] \" + message);\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1)\n        return;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx-utils] Deprecated: \" + msg);\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\n\nvar PENDING = \"pending\";\nvar FULFILLED = \"fulfilled\";\nvar REJECTED = \"rejected\";\nfunction caseImpl(handlers) {\n    switch (this.state) {\n        case PENDING:\n            return handlers.pending && handlers.pending();\n        case REJECTED:\n            return handlers.rejected && handlers.rejected(this.value);\n        case FULFILLED:\n            return handlers.fulfilled && handlers.fulfilled(this.value);\n    }\n}\nfunction createObservablePromise(origPromise) {\n    invariant(arguments.length === 1, \"fromPromise expects exactly one argument\");\n    invariant(typeof origPromise === \"function\" ||\n        (typeof origPromise === \"object\" &&\n            origPromise &&\n            typeof origPromise.then === \"function\"), \"Please pass a promise or function to fromPromise\");\n    if (origPromise.isPromiseBasedObservable === true)\n        return origPromise;\n    if (typeof origPromise === \"function\") {\n        // If it is a (reject, resolve function, wrap it)\n        origPromise = new Promise(origPromise);\n    }\n    var promise = origPromise;\n    origPromise.then(action(\"observableFromPromise-resolve\", function (value) {\n        promise.value = value;\n        promise.state = FULFILLED;\n    }), action(\"observableFromPromise-reject\", function (reason) {\n        promise.value = reason;\n        promise.state = REJECTED;\n    }));\n    promise.isPromiseBasedObservable = true;\n    promise.case = caseImpl;\n    extendObservable(promise, {\n        value: undefined,\n        state: PENDING\n    }, {}, { deep: false });\n    return promise;\n}\n/**\n * `fromPromise` takes a Promise and returns a new Promise wrapping the original one. The returned Promise is also extended with 2 observable properties that track\n * the status of the promise. The returned object has the following observable properties:\n *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference.\n *  - `state`: one of `\"pending\"`, `\"fulfilled\"` or `\"rejected\"`\n *\n * And the following methods:\n * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.\n * - `then((value: TValue) => TResult1 | PromiseLike<TResult1>, [(rejectReason: any) => any])`: chains additional handlers to the provided promise.\n *\n * The returned object implements `PromiseLike<TValue>`, so you can chain additional `Promise` handlers using `then`. You may also use it with `await` in `async` functions.\n *\n * Note that the status strings are available as constants:\n * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`\n *\n * Observable promises can be created immediately in a certain state using\n * `fromPromise.reject(reason)` or `fromPromise.resolve(value?)`.\n * The main advantage of `fromPromise.resolve(value)` over `fromPromise(Promise.resolve(value))` is that the first _synchronously_ starts in the desired state.\n *\n * It is possible to directly create a promise using a resolve, reject function:\n * `fromPromise((resolve, reject) => setTimeout(() => resolve(true), 1000))`\n *\n * @example\n * const fetchResult = fromPromise(fetch(\"http://someurl\"))\n *\n * // combine with when..\n * when(\n *   () => fetchResult.state !== \"pending\"\n *   () => {\n *     console.log(\"Got \", fetchResult.value)\n *   }\n * )\n *\n * // or a mobx-react component..\n * const myComponent = observer(({ fetchResult }) => {\n *   switch(fetchResult.state) {\n *      case \"pending\": return <div>Loading...</div>\n *      case \"rejected\": return <div>Ooops... {fetchResult.value}</div>\n *      case \"fulfilled\": return <div>Gotcha: {fetchResult.value}</div>\n *   }\n * })\n *\n * // or using the case method instead of switch:\n *\n * const myComponent = observer(({ fetchResult }) =>\n *   fetchResult.case({\n *     pending:   () => <div>Loading...</div>,\n *     rejected:  error => <div>Ooops.. {error}</div>,\n *     fulfilled: value => <div>Gotcha: {value}</div>,\n *   }))\n *\n * // chain additional handler(s) to the resolve/reject:\n *\n * fetchResult.then(\n *   (result) =>  doSomeTransformation(result),\n *   (rejectReason) => console.error('fetchResult was rejected, reason: ' + rejectReason)\n * ).then(\n *   (transformedResult) => console.log('transformed fetchResult: ' + transformedResult)\n * )\n *\n * @param {IThenable<T>} promise The promise which will be observed\n * @returns {IPromiseBasedObservable<T>}\n */\nvar fromPromise = createObservablePromise;\nfromPromise.reject = action(\"fromPromise.reject\", function (reason) {\n    var p = fromPromise(Promise.reject(reason));\n    p.state = REJECTED;\n    p.value = reason;\n    return p;\n});\nfromPromise.resolve = action(\"fromPromise.resolve\", function (value) {\n    if (value === void 0) { value = undefined; }\n    var p = fromPromise(Promise.resolve(value));\n    p.state = FULFILLED;\n    p.value = value;\n    return p;\n});\n/**\n * Returns true if the provided value is a promise-based observable.\n * @param value any\n * @returns {boolean}\n */\nfunction isPromiseBasedObservable(value) {\n    return value && value.isPromiseBasedObservable === true;\n}\n\n/**\n * Moves an item from one position to another, checking that the indexes given are within bounds.\n *\n * @example\n * const source = observable([1, 2, 3])\n * moveItem(source, 0, 1)\n * console.log(source.map(x => x)) // [2, 1, 3]\n *\n * @export\n * @param {ObservableArray<T>} target\n * @param {number} fromIndex\n * @param {number} toIndex\n * @returns {ObservableArray<T>}\n */\nfunction moveItem(target, fromIndex, toIndex) {\n    checkIndex(target, fromIndex);\n    checkIndex(target, toIndex);\n    if (fromIndex === toIndex) {\n        return;\n    }\n    var oldItems = target.$mobx.values;\n    var newItems;\n    if (fromIndex < toIndex) {\n        newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [\n            oldItems[fromIndex]\n        ], oldItems.slice(toIndex + 1));\n    }\n    else {\n        // toIndex < fromIndex\n        newItems = oldItems.slice(0, toIndex).concat([\n            oldItems[fromIndex]\n        ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n    }\n    target.replace(newItems);\n    return target;\n}\n/**\n * Checks whether the specified index is within bounds. Throws if not.\n *\n * @private\n * @param {ObservableArray<any>} target\n * @param {number }index\n */\nfunction checkIndex(target, index) {\n    if (index < 0) {\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n    }\n    var length = target.$mobx.values.length;\n    if (index >= length) {\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n    }\n}\n\n/**\n * `lazyObservable` creates an observable around a `fetch` method that will not be invoked\n * until the observable is needed the first time.\n * The fetch method receives a `sink` callback which can be used to replace the\n * current value of the lazyObservable. It is allowed to call `sink` multiple times\n * to keep the lazyObservable up to date with some external resource.\n *\n * Note that it is the `current()` call itself which is being tracked by MobX,\n * so make sure that you don't dereference to early.\n *\n * @example\n * const userProfile = lazyObservable(\n *   sink => fetch(\"/myprofile\").then(profile => sink(profile))\n * )\n *\n * // use the userProfile in a React component:\n * const Profile = observer(({ userProfile }) =>\n *   userProfile.current() === undefined\n *   ? <div>Loading user profile...</div>\n *   : <div>{userProfile.current().displayName}</div>\n * )\n *\n * // triggers refresh the userProfile\n * userProfile.refresh()\n *\n * @param {(sink: (newValue: T) => void) => void} fetch method that will be called the first time the value of this observable is accessed. The provided sink can be used to produce a new value, synchronously or asynchronously\n * @param {T} [initialValue=undefined] optional initialValue that will be returned from `current` as long as the `sink` has not been called at least once\n * @returns {{\n *     current(): T,\n *     refresh(): T,\n *     reset(): T\n * }}\n */\nfunction lazyObservable(fetch, initialValue) {\n    if (initialValue === void 0) { initialValue = undefined; }\n    var started = false;\n    var value = observable.box(initialValue, { deep: false });\n    var currentFnc = function () {\n        if (!started) {\n            started = true;\n            fetch(function (newValue) {\n                _allowStateChanges(true, function () {\n                    value.set(newValue);\n                });\n            });\n        }\n        return value.get();\n    };\n    var resetFnc = action(\"lazyObservable-reset\", function () {\n        value.set(initialValue);\n        return value.get();\n    });\n    return {\n        current: currentFnc,\n        refresh: function () {\n            if (started) {\n                started = false;\n                return currentFnc();\n            }\n            else {\n                return value.get();\n            }\n        },\n        reset: function () {\n            return resetFnc();\n        }\n    };\n}\n\n/**\n * `fromResource` creates an observable whose current state can be inspected using `.current()`,\n * and which can be kept in sync with some external datasource that can be subscribed to.\n *\n * The created observable will only subscribe to the datasource if it is in use somewhere,\n * (un)subscribing when needed. To enable `fromResource` to do that two callbacks need to be provided,\n * one to subscribe, and one to unsubscribe. The subscribe callback itself will receive a `sink` callback, which can be used\n * to update the current state of the observable, allowing observes to react.\n *\n * Whatever is passed to `sink` will be returned by `current()`. The values passed to the sink will not be converted to\n * observables automatically, but feel free to do so.\n * It is the `current()` call itself which is being tracked,\n * so make sure that you don't dereference to early.\n *\n * For inspiration, an example integration with the apollo-client on [github](https://github.com/apollostack/apollo-client/issues/503#issuecomment-241101379),\n * or the [implementation](https://github.com/mobxjs/mobx-utils/blob/1d17cf7f7f5200937f68cc0b5e7ec7f3f71dccba/src/now.ts#L43-L57) of `mobxUtils.now`\n *\n * The following example code creates an observable that connects to a `dbUserRecord`,\n * which comes from an imaginary database and notifies when it has changed.\n *\n * @example\n * function createObservableUser(dbUserRecord) {\n *   let currentSubscription;\n *   return fromResource(\n *     (sink) => {\n *       // sink the current state\n *       sink(dbUserRecord.fields)\n *       // subscribe to the record, invoke the sink callback whenever new data arrives\n *       currentSubscription = dbUserRecord.onUpdated(() => {\n *         sink(dbUserRecord.fields)\n *       })\n *     },\n *     () => {\n *       // the user observable is not in use at the moment, unsubscribe (for now)\n *       dbUserRecord.unsubscribe(currentSubscription)\n *     }\n *   )\n * }\n *\n * // usage:\n * const myUserObservable = createObservableUser(myDatabaseConnector.query(\"name = 'Michel'\"))\n *\n * // use the observable in autorun\n * autorun(() => {\n *   // printed everytime the database updates its records\n *   console.log(myUserObservable.current().displayName)\n * })\n *\n * // ... or a component\n * const userComponent = observer(({ user }) =>\n *   <div>{user.current().displayName}</div>\n * )\n *\n * @export\n * @template T\n * @param {(sink: (newValue: T) => void) => void} subscriber\n * @param {IDisposer} [unsubscriber=NOOP]\n * @param {T} [initialValue=undefined] the data that will be returned by `get()` until the `sink` has emitted its first data\n * @returns {{\n *     current(): T;\n *     dispose(): void;\n *     isAlive(): boolean;\n * }}\n */\nfunction fromResource(subscriber, unsubscriber, initialValue) {\n    if (unsubscriber === void 0) { unsubscriber = NOOP; }\n    if (initialValue === void 0) { initialValue = undefined; }\n    var isActive = false;\n    var isDisposed = false;\n    var value = initialValue;\n    var suspender = function () {\n        if (isActive) {\n            isActive = false;\n            unsubscriber();\n        }\n    };\n    var atom = createAtom(\"ResourceBasedObservable\", function () {\n        invariant(!isActive && !isDisposed);\n        isActive = true;\n        subscriber(function (newValue) {\n            _allowStateChanges(true, function () {\n                value = newValue;\n                atom.reportChanged();\n            });\n        });\n    }, suspender);\n    return {\n        current: function () {\n            invariant(!isDisposed, \"subscribingObservable has already been disposed\");\n            var isBeingTracked = atom.reportObserved();\n            if (!isBeingTracked && !isActive)\n                console.warn(\"Called `get` of an subscribingObservable outside a reaction. Current value will be returned but no new subscription has started\");\n            return value;\n        },\n        dispose: function () {\n            isDisposed = true;\n            suspender();\n        },\n        isAlive: function () { return isActive; }\n    };\n}\n\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nfunction observableSymbol() {\n    return (typeof Symbol === \"function\" && Symbol.observable) || \"@@observable\";\n}\nfunction self() {\n    return this;\n}\n/**\n * Converts an expression to an observable stream (a.k.a. TC 39 Observable / RxJS observable).\n * The provided expression is tracked by mobx as long as there are subscribers, automatically\n * emitting when new values become available. The expressions respect (trans)actions.\n *\n * @example\n *\n * const user = observable({\n *   firstName: \"C.S\",\n *   lastName: \"Lewis\"\n * })\n *\n * Rx.Observable\n *   .from(mobxUtils.toStream(() => user.firstname + user.lastName))\n *   .scan(nameChanges => nameChanges + 1, 0)\n *   .subscribe(nameChanges => console.log(\"Changed name \", nameChanges, \"times\"))\n *\n * @export\n * @template T\n * @param {() => T} expression\n * @param {boolean} fireImmediately (by default false)\n * @returns {IObservableStream<T>}\n */\nfunction toStream(expression, fireImmediately) {\n    if (fireImmediately === void 0) { fireImmediately = false; }\n    var computedValue = computed(expression);\n    return _a = {\n            subscribe: function (observer) {\n                return {\n                    unsubscribe: computedValue.observe(typeof observer === \"function\"\n                        ? function (_a) {\n                            var newValue = _a.newValue;\n                            return observer(newValue);\n                        }\n                        : function (_a) {\n                            var newValue = _a.newValue;\n                            return observer.next(newValue);\n                        }, fireImmediately)\n                };\n            }\n        },\n        _a[observableSymbol()] = self,\n        _a;\n    var _a;\n}\nvar StreamListener = /** @class */ (function () {\n    function StreamListener(observable$$1, initialValue) {\n        var _this = this;\n        this.current = undefined;\n        runInAction(function () {\n            _this.current = initialValue;\n            _this.subscription = observable$$1.subscribe(_this);\n        });\n    }\n    StreamListener.prototype.dispose = function () {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    };\n    StreamListener.prototype.next = function (value) {\n        this.current = value;\n    };\n    StreamListener.prototype.complete = function () {\n        this.dispose();\n    };\n    StreamListener.prototype.error = function (value) {\n        this.current = value;\n        this.dispose();\n    };\n    __decorate([\n        observable.ref\n    ], StreamListener.prototype, \"current\", void 0);\n    __decorate([\n        action.bound\n    ], StreamListener.prototype, \"next\", null);\n    __decorate([\n        action.bound\n    ], StreamListener.prototype, \"complete\", null);\n    __decorate([\n        action.bound\n    ], StreamListener.prototype, \"error\", null);\n    return StreamListener;\n}());\n/**\n *\n * Converts an subscribable, observable stream (TC 39 observable / RxJS stream)\n * into an object which stores the current value (as `current`). The subscription can be cancelled through the `dispose` method.\n * Takes an initial value as second optional argument\n *\n * @example\n * const debouncedClickDelta = MobxUtils.fromStream(Rx.Observable.fromEvent(button, 'click')\n *     .throttleTime(1000)\n *     .map(event => event.clientX)\n *     .scan((count, clientX) => count + clientX, 0)\n * )\n *\n * autorun(() => {\n *     console.log(\"distance moved\", debouncedClickDelta.current)\n * })\n *\n * @export\n * @template T\n * @param {IObservableStream<T>} observable\n * @returns {{\n *     current: T;\n *     dispose(): void;\n * }}\n */\nfunction fromStream(observable$$1, initialValue) {\n    if (initialValue === void 0) { initialValue = undefined; }\n    return new StreamListener(observable$$1, initialValue);\n}\n\nvar __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar RESERVED_NAMES = [\"model\", \"reset\", \"submit\", \"isDirty\", \"isPropertyDirty\", \"resetProperty\"];\nvar ViewModel = /** @class */ (function () {\n    function ViewModel(model) {\n        var _this = this;\n        this.model = model;\n        this.localValues = observable.map({});\n        this.isPropertyDirty = function (key) {\n            return _this.localValues.has(key);\n        };\n        invariant(isObservableObject(model), \"createViewModel expects an observable object\");\n        Object.keys(model).forEach(function (key) {\n            invariant(RESERVED_NAMES.indexOf(key) === -1, \"The propertyname \" + key + \" is reserved and cannot be used with viewModels\");\n            Object.defineProperty(_this, key, {\n                enumerable: true,\n                configurable: true,\n                get: function () {\n                    if (_this.isPropertyDirty(key))\n                        return _this.localValues.get(key);\n                    else\n                        return _this.model[key];\n                },\n                set: action(function (value) {\n                    if (_this.isPropertyDirty(key) || value !== _this.model[key]) {\n                        _this.localValues.set(key, value);\n                    }\n                })\n            });\n        });\n    }\n    Object.defineProperty(ViewModel.prototype, \"isDirty\", {\n        get: function () {\n            return this.localValues.size > 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ViewModel.prototype.submit = function () {\n        var _this = this;\n        keys(this.localValues).forEach(function (key) {\n            var source = _this.localValues.get(key);\n            var destination = _this.model[key];\n            if (isObservableArray(destination)) {\n                destination.replace(source);\n            }\n            else if (isObservableMap(destination)) {\n                destination.clear();\n                destination.merge(source);\n            }\n            else {\n                \n                _this.model[key] = source;\n            }\n        });\n        this.localValues.clear();\n    };\n    ViewModel.prototype.reset = function () {\n        this.localValues.clear();\n    };\n    ViewModel.prototype.resetProperty = function (key) {\n        this.localValues.delete(key);\n    };\n    __decorate$1([\n        computed\n    ], ViewModel.prototype, \"isDirty\", null);\n    __decorate$1([\n        action.bound\n    ], ViewModel.prototype, \"submit\", null);\n    __decorate$1([\n        action.bound\n    ], ViewModel.prototype, \"reset\", null);\n    __decorate$1([\n        action.bound\n    ], ViewModel.prototype, \"resetProperty\", null);\n    return ViewModel;\n}());\n/**\n * `createViewModel` takes an object with observable properties (model)\n * and wraps a viewmodel around it. The viewmodel proxies all enumerable property of the original model with the following behavior:\n *  - as long as no new value has been assigned to the viewmodel property, the original property will be returned.\n *  - any future change in the model will be visible in the viewmodel as well unless the viewmodel property was dirty at the time of the attempted change.\n *  - once a new value has been assigned to a property of the viewmodel, that value will be returned during a read of that property in the future. However, the original model remain untouched until `submit()` is called.\n *\n * The viewmodel exposes the following additional methods, besides all the enumerable properties of the model:\n * - `submit()`: copies all the values of the viewmodel to the model and resets the state\n * - `reset()`: resets the state of the viewmodel, abandoning all local modifications\n * - `resetProperty(propName)`: resets the specified property of the viewmodel\n * - `isDirty`: observable property indicating if the viewModel contains any modifications\n * - `isPropertyDirty(propName)`: returns true if the specified property is dirty\n * - `model`: The original model object for which this viewModel was created\n *\n * You may use observable arrays, maps and objects with `createViewModel` but keep in mind to assign fresh instances of those to the viewmodel's properties, otherwise you would end up modifying the properties of the original model.\n * Note that if you read a non-dirty property, viewmodel only proxies the read to the model. You therefore need to assign a fresh instance not only the first time you make the assignment but also after calling `reset()` or `submit()`.\n *\n * @example\n * class Todo {\n *   \\@observable title = \"Test\"\n * }\n *\n * const model = new Todo()\n * const viewModel = createViewModel(model);\n *\n * autorun(() => console.log(viewModel.model.title, \",\", viewModel.title))\n * // prints \"Test, Test\"\n * model.title = \"Get coffee\"\n * // prints \"Get coffee, Get coffee\", viewModel just proxies to model\n * viewModel.title = \"Get tea\"\n * // prints \"Get coffee, Get tea\", viewModel's title is now dirty, and the local value will be printed\n * viewModel.submit()\n * // prints \"Get tea, Get tea\", changes submitted from the viewModel to the model, viewModel is proxying again\n * viewModel.title = \"Get cookie\"\n * // prints \"Get tea, Get cookie\" // viewModel has diverged again\n * viewModel.reset()\n * // prints \"Get tea, Get tea\", changes of the viewModel have been abandoned\n *\n * @param {T} model\n * @returns {(T & IViewModel<T>)}\n * ```\n */\nfunction createViewModel(model) {\n    return new ViewModel(model);\n}\n\n/**\n * Like normal `when`, except that this `when` will automatically dispose if the condition isn't met within a certain amount of time.\n *\n * @example\n * test(\"expect store to load\", t => {\n *   const store = {\n *     items: [],\n *     loaded: false\n *   }\n *   fetchDataForStore((data) => {\n *     store.items = data;\n *     store.loaded = true;\n *   })\n *   whenWithTimeout(\n *     () => store.loaded\n *     () => t.end()\n *     2000,\n *     () => t.fail(\"store didn't load with 2 secs\")\n *   )\n * })\n *\n *\n * @export\n * @param {() => boolean} expr see when, the expression to await\n * @param {() => void} action see when, the action to execut when expr returns truthy\n * @param {number} [timeout=10000] maximum amount when spends waiting before giving up\n * @param {any} [onTimeout=() => {}] the ontimeout handler will be called if the condition wasn't met within the given time\n * @returns {IDisposer} disposer function that can be used to cancel the when prematurely. Neither action or onTimeout will be fired if disposed\n */\nfunction whenWithTimeout(expr, action$$1, timeout, onTimeout) {\n    if (timeout === void 0) { timeout = 10000; }\n    if (onTimeout === void 0) { onTimeout = function () { }; }\n    deprecated(\"whenWithTimeout is deprecated, use mobx.when with timeout option instead\");\n    return when(expr, action$$1, {\n        timeout: timeout,\n        onError: onTimeout\n    });\n}\n\n/**\n * MobX normally suspends any computed value that is not in use by any reaction,\n * and lazily re-evaluates the expression if needed outside a reaction while not in use.\n * `keepAlive` marks a computed value as always in use, meaning that it will always fresh, but never disposed automatically.\n *\n * @example\n * const obj = observable({\n *   number: 3,\n *   doubler: function() { return this.number * 2 }\n * })\n * const stop = keepAlive(obj, \"doubler\")\n *\n * @param {Object} target an object that has a computed property, created by `@computed` or `extendObservable`\n * @param {string} property the name of the property to keep alive\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\n */\n/**\n * @example\n * const number = observable(3)\n * const doubler = computed(() => number.get() * 2)\n * const stop = keepAlive(doubler)\n * // doubler will now stay in sync reactively even when there are no further observers\n * stop()\n * // normal behavior, doubler results will be recomputed if not observed but needed, but lazily\n *\n * @param {IComputedValue<any>} computedValue created using the `computed` function\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\n */\nfunction keepAlive(_1, _2) {\n    var computed$$1 = getAtom(_1, _2);\n    if (!computed$$1)\n        throw new Error(\"No computed provided, please provide an object created with `computed(() => expr)` or an object + property name\");\n    return computed$$1.observe(function () { });\n}\n\n/**\n * `queueProcessor` takes an observable array, observes it and calls `processor`\n * once for each item added to the observable array, optionally deboucing the action\n *\n * @example\n * const pendingNotifications = observable([])\n * const stop = queueProcessor(pendingNotifications, msg => {\n *   // show Desktop notification\n *   new Notification(msg);\n * })\n *\n * // usage:\n * pendingNotifications.push(\"test!\")\n *\n * @param {T[]} observableArray observable array instance to track\n * @param {(item: T) => void} processor action to call per item\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\n * @returns {IDisposer} stops the processor\n */\nfunction queueProcessor(observableArray, processor, debounce) {\n    if (debounce === void 0) { debounce = 0; }\n    if (!isObservableArray(observableArray))\n        throw new Error(\"Expected observable array as first argument\");\n    if (!isAction(processor))\n        processor = action(\"queueProcessor\", processor);\n    var runner = function () {\n        // construct a final set\n        var items = observableArray.slice(0);\n        // clear the queue for next iteration\n        runInAction(function () { return observableArray.splice(0); });\n        // fire processor\n        items.forEach(processor);\n    };\n    if (debounce > 0)\n        return autorun(runner, { delay: debounce });\n    else\n        return autorun(runner);\n}\n\n/**\n * `chunkProcessor` takes an observable array, observes it and calls `processor`\n * once for a chunk of items added to the observable array, optionally deboucing the action.\n * The maximum chunk size can be limited by number.\n * This allows both, splitting larger into smaller chunks or (when debounced) combining smaller\n * chunks and/or single items into reasonable chunks of work.\n *\n * @example\n * const trackedActions = observable([])\n * const stop = chunkProcessor(trackedActions, chunkOfMax10Items => {\n *   sendTrackedActionsToServer(chunkOfMax10Items);\n * }, 100, 10)\n *\n * // usage:\n * trackedActions.push(\"scrolled\")\n * trackedActions.push(\"hoveredButton\")\n * // when both pushes happen within 100ms, there will be only one call to server\n *\n * @param {T[]} observableArray observable array instance to track\n * @param {(item: T[]) => void} processor action to call per item\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\n * @param {number} [maxChunkSize=0] optionally do not call on full array but smaller chunks. With 0 it will process the full array.\n * @returns {IDisposer} stops the processor\n */\nfunction chunkProcessor(observableArray, processor, debounce, maxChunkSize) {\n    if (debounce === void 0) { debounce = 0; }\n    if (maxChunkSize === void 0) { maxChunkSize = 0; }\n    if (!isObservableArray(observableArray))\n        throw new Error(\"Expected observable array as first argument\");\n    if (!isAction(processor))\n        processor = action(\"chunkProcessor\", processor);\n    var runner = function () {\n        var _loop_1 = function () {\n            var chunkSize = maxChunkSize === 0\n                ? observableArray.length\n                : Math.min(observableArray.length, maxChunkSize);\n            // construct a final set\n            var items = observableArray.slice(0, chunkSize);\n            // clear the slice for next iteration\n            runInAction(function () { return observableArray.splice(0, chunkSize); });\n            // fire processor\n            processor(items);\n        };\n        while (observableArray.length > 0) {\n            _loop_1();\n        }\n    };\n    if (debounce > 0)\n        return autorun(runner, { delay: debounce });\n    else\n        return autorun(runner);\n}\n\nvar tickers = {};\n/**\n * Returns the current date time as epoch number.\n * The date time is read from an observable which is updated automatically after the given interval.\n * So basically it treats time as an observable.\n *\n * The function takes an interval as parameter, which indicates how often `now()` will return a new value.\n * If no interval is given, it will update each second. If \"frame\" is specified, it will update each time a\n * `requestAnimationFrame` is available.\n *\n * Multiple clocks with the same interval will automatically be synchronized.\n *\n * Countdown example: https://jsfiddle.net/mweststrate/na0qdmkw/\n *\n * @example\n *\n * const start = Date.now()\n *\n * autorun(() => {\n *   console.log(\"Seconds elapsed: \", (mobxUtils.now() - start) / 1000)\n * })\n *\n *\n * @export\n * @param {(number | \"frame\")} [interval=1000] interval in milliseconds about how often the interval should update\n * @returns\n */\nfunction now(interval) {\n    if (interval === void 0) { interval = 1000; }\n    if (!_isComputingDerivation()) {\n        // See #40\n        return Date.now();\n    }\n    if (!tickers[interval]) {\n        if (typeof interval === \"number\")\n            tickers[interval] = createIntervalTicker(interval);\n        else\n            tickers[interval] = createAnimationFrameTicker();\n    }\n    return tickers[interval].current();\n}\nfunction createIntervalTicker(interval) {\n    var subscriptionHandle;\n    return fromResource(function (sink) {\n        subscriptionHandle = setInterval(function () { return sink(Date.now()); }, interval);\n    }, function () {\n        clearInterval(subscriptionHandle);\n    }, Date.now());\n}\nfunction createAnimationFrameTicker() {\n    var frameBasedTicker = fromResource(function (sink) {\n        function scheduleTick() {\n            window.requestAnimationFrame(function () {\n                sink(Date.now());\n                if (frameBasedTicker.isAlive())\n                    scheduleTick();\n            });\n        }\n        scheduleTick();\n    }, function () { }, Date.now());\n    return frameBasedTicker;\n}\n\nvar __assign = (undefined && undefined.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n/**\n * _deprecated_ this functionality can now be found as `flow` in the mobx package. However, `flow` is not applicable as decorator, where `asyncAction` still is.\n *\n *\n *\n * `asyncAction` takes a generator function and automatically wraps all parts of the process in actions. See the examples below.\n * `asyncAction` can be used both as decorator or to wrap functions.\n *\n * - It is important that `asyncAction should always be used with a generator function (recognizable as `function*` or `*name` syntax)\n * - Each yield statement should return a Promise. The generator function will continue as soon as the promise settles, with the settled value\n * - When the generator function finishes, you can return a normal value. The `asyncAction` wrapped function will always produce a promise delivering that value.\n *\n * When using the mobx devTools, an asyncAction will emit `action` events with names like:\n * * `\"fetchUsers - runid: 6 - init\"`\n * * `\"fetchUsers - runid: 6 - yield 0\"`\n * * `\"fetchUsers - runid: 6 - yield 1\"`\n *\n * The `runId` represents the generator instance. In other words, if `fetchUsers` is invoked multiple times concurrently, the events with the same `runid` belong toghether.\n * The `yield` number indicates the progress of the generator. `init` indicates spawning (it won't do anything, but you can find the original arguments of the `asyncAction` here).\n * `yield 0` ... `yield n` indicates the code block that is now being executed. `yield 0` is before the first `yield`, `yield 1` after the first one etc. Note that yield numbers are not determined lexically but by the runtime flow.\n *\n * `asyncActions` requires `Promise` and `generators` to be available on the target environment. Polyfill `Promise` if needed. Both TypeScript and Babel can compile generator functions down to ES5.\n *\n *  N.B. due to a [babel limitation](https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy/issues/26), in Babel generatos cannot be combined with decorators. See also [#70](https://github.com/mobxjs/mobx-utils/issues/70)\n *\n *\n * @example\n * import {asyncAction} from \"mobx-utils\"\n *\n * let users = []\n *\n * const fetchUsers = asyncAction(\"fetchUsers\", function* (url) {\n *   const start = Date.now()\n *   const data = yield window.fetch(url)\n *   users = yield data.json()\n *   return start - Date.now()\n * })\n *\n * fetchUsers(\"http://users.com\").then(time => {\n *   console.dir(\"Got users\", users, \"in \", time, \"ms\")\n * })\n *\n * @example\n * import {asyncAction} from \"mobx-utils\"\n *\n * mobx.configure({ enforceActions: true }) // don't allow state modifications outside actions\n *\n * class Store {\n * \t\\@observable githubProjects = []\n * \t\\@state = \"pending\" // \"pending\" / \"done\" / \"error\"\n *\n * \t\\@asyncAction\n * \t*fetchProjects() { // <- note the star, this a generator function!\n * \t\tthis.githubProjects = []\n * \t\tthis.state = \"pending\"\n * \t\ttry {\n * \t\t\tconst projects = yield fetchGithubProjectsSomehow() // yield instead of await\n * \t\t\tconst filteredProjects = somePreprocessing(projects)\n * \t\t\t// the asynchronous blocks will automatically be wrapped actions\n * \t\t\tthis.state = \"done\"\n * \t\t\tthis.githubProjects = filteredProjects\n * \t\t} catch (error) {\n * \t\t\tthis.state = \"error\"\n * \t\t}\n * \t}\n * }\n *\n * @export\n * @returns {Promise}\n */\nfunction asyncAction(arg1, arg2) {\n    // decorator\n    if (typeof arguments[1] === \"string\") {\n        var name_1 = arguments[1];\n        var descriptor_1 = arguments[2];\n        if (descriptor_1 && descriptor_1.value) {\n            return Object.assign({}, descriptor_1, {\n                value: flow(descriptor_1.value)\n            });\n        }\n        else {\n            return Object.assign({}, descriptor_1, {\n                set: function (v) {\n                    Object.defineProperty(this, name_1, __assign({}, descriptor_1, { value: flow(v) }));\n                }\n            });\n        }\n    }\n    // direct invocation\n    var generator = typeof arg1 === \"string\" ? arg2 : arg1;\n    deprecated(\"asyncAction is deprecated. use mobx.flow instead\");\n    return flow(generator); // name get's dropped..\n}\n\n/**\n * Like normal `when`, except that this `when` will return a promise that resolves when the expression becomes truthy\n *\n * @example\n * await whenAsync(() => !state.someBoolean)\n *\n * @export\n * @param {() => boolean} fn see when, the expression to await\n * @param {number} timeout maximum amount of time to wait, before the promise rejects\n * @returns Promise for when an observable eventually matches some condition. Rejects if timeout is provided and has expired\n */\nfunction whenAsync(fn, timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    deprecated(\"whenAsync is deprecated, use mobx.when without effect instead\");\n    return when(fn, {\n        timeout: timeout\n    });\n}\n\n/**\n * expr can be used to create temporarily views inside views.\n * This can be improved to improve performance if a value changes often, but usually doesn't affect the outcome of an expression.\n *\n * In the following example the expression prevents that a component is rerender _each time_ the selection changes;\n * instead it will only rerenders when the current todo is (de)selected.\n *\n * @example\n * const Todo = observer((props) => {\n *     const todo = props.todo;\n *     const isSelected = mobxUtils.expr(() => props.viewState.selection === todo);\n *     return <div className={isSelected ? \"todo todo-selected\" : \"todo\"}>{todo.title}</div>\n * });\n *\n */\nfunction expr(expr) {\n    if (!_isComputingDerivation())\n        console.warn(\"'expr' should only be used inside other reactive functions.\");\n    // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired\n    return computed(expr).get();\n}\n\nvar memoizationId = 0;\n/**\n * Creates a function that maps an object to a view.\n * The mapping is memoized.\n *\n * See: https://mobx.js.org/refguide/create-transformer.html\n */\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    // Memoizes: object id -> reactive view that applies transformer to the object\n    var views = {};\n    function createView(sourceIdentifier, sourceObject) {\n        var latestValue;\n        var expr = computed(function () {\n            return (latestValue = transformer(sourceObject));\n        }, {\n            name: \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier\n        });\n        var disposer = onBecomeUnobserved(expr, function () {\n            delete views[sourceIdentifier];\n            disposer();\n            if (onCleanup)\n                onCleanup(latestValue, sourceObject);\n        });\n        return expr;\n    }\n    return function (object) {\n        var identifier = getMemoizationId(object);\n        var reactiveView = views[identifier];\n        if (reactiveView)\n            return reactiveView.get();\n        // Not in cache; create a reactive view\n        reactiveView = views[identifier] = createView(identifier, object);\n        return reactiveView.get();\n    };\n}\nfunction getMemoizationId(object) {\n    if (typeof object === \"string\" || typeof object === \"number\")\n        return object;\n    if (object === null || typeof object !== \"object\")\n        throw new Error(\"[mobx-utils] transform expected an object, string or number, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = ++memoizationId;\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\n\nexport { PENDING, FULFILLED, REJECTED, fromPromise, isPromiseBasedObservable, moveItem, lazyObservable, fromResource, toStream, fromStream, ViewModel, createViewModel, whenWithTimeout, keepAlive, queueProcessor, chunkProcessor, now, NOOP, IDENTITY, invariant, deprecated, addHiddenProp, asyncAction, whenAsync, expr, createTransformer };\n"],
  "mappings": "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",
  "names": ["_a", "StreamListener", "ViewModel", "expr"]
}
